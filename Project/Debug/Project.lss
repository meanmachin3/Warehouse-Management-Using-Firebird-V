
Project.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000096  00800200  0000370a  0000379e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000370a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000000d5  00800296  00800296  00003834  2**0
                  ALLOC
  3 .stab         000033fc  00000000  00000000  00003834  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000009aa  00000000  00000000  00006c30  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000000c0  00000000  00000000  000075e0  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002626  00000000  00000000  000076a0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000045e  00000000  00000000  00009cc6  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000dfe  00000000  00000000  0000a124  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000007e8  00000000  00000000  0000af24  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000008e0  00000000  00000000  0000b70c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001bc4  00000000  00000000  0000bfec  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000b0  00000000  00000000  0000dbb0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 b3 00 	jmp	0x166	; 0x166 <__ctors_end>
       4:	0c 94 34 02 	jmp	0x468	; 0x468 <__vector_1>
       8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
       c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      10:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      14:	0c 94 6e 03 	jmp	0x6dc	; 0x6dc <__vector_5>
      18:	0c 94 49 03 	jmp	0x692	; 0x692 <__vector_6>
      1c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      20:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      24:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      28:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      2c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      30:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      34:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      38:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      3c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      40:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      44:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      48:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      4c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      50:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      54:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      58:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      5c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      60:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      64:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      68:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      6c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      70:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      74:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      78:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      7c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      80:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      84:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      88:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      8c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      90:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      94:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      98:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      9c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      a0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      a4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      a8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      ac:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      b0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      b4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      b8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      bc:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      c0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      c4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      c8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      cc:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      d0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      d4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      d8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      dc:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      e0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      e4:	07 63       	ori	r16, 0x37	; 55
      e6:	42 36       	cpi	r20, 0x62	; 98
      e8:	b7 9b       	sbis	0x16, 7	; 22
      ea:	d8 a7       	lds	r29, 0x78
      ec:	1a 39       	cpi	r17, 0x9A	; 154
      ee:	68 56       	subi	r22, 0x68	; 104
      f0:	18 ae       	sts	0xb8, r17
      f2:	ba ab       	sts	0x5a, r27
      f4:	55 8c       	ldd	r5, Z+29	; 0x1d
      f6:	1d 3c       	cpi	r17, 0xCD	; 205
      f8:	b7 cc       	rjmp	.-1682   	; 0xfffffa68 <__eeprom_end+0xff7efa68>
      fa:	57 63       	ori	r21, 0x37	; 55
      fc:	bd 6d       	ori	r27, 0xDD	; 221
      fe:	ed fd       	.word	0xfded	; ????
     100:	75 3e       	cpi	r23, 0xE5	; 229
     102:	f6 17       	cp	r31, r22
     104:	72 31       	cpi	r23, 0x12	; 18
     106:	bf 00       	.word	0x00bf	; ????
     108:	00 00       	nop
     10a:	80 3f       	cpi	r24, 0xF0	; 240
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 00       	nop
     110:	be 92       	st	-X, r11
     112:	24 49       	sbci	r18, 0x94	; 148
     114:	12 3e       	cpi	r17, 0xE2	; 226
     116:	ab aa       	sts	0x9b, r26
     118:	aa 2a       	or	r10, r26
     11a:	be cd       	rjmp	.-1156   	; 0xfffffc98 <__eeprom_end+0xff7efc98>
     11c:	cc cc       	rjmp	.-1640   	; 0xfffffab6 <__eeprom_end+0xff7efab6>
     11e:	4c 3e       	cpi	r20, 0xEC	; 236
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	be ab       	sts	0x5e, r27
     126:	aa aa       	sts	0x9a, r26
     128:	aa 3e       	cpi	r26, 0xEA	; 234
     12a:	00 00       	nop
     12c:	00 00       	nop
     12e:	bf 00       	.word	0x00bf	; ????
     130:	00 00       	nop
     132:	80 3f       	cpi	r24, 0xF0	; 240
     134:	00 00       	nop
     136:	00 00       	nop
     138:	00 08       	sbc	r0, r0
     13a:	41 78       	andi	r20, 0x81	; 129
     13c:	d3 bb       	out	0x13, r29	; 19
     13e:	43 87       	std	Z+11, r20	; 0x0b
     140:	d1 13       	cpse	r29, r17
     142:	3d 19       	sub	r19, r13
     144:	0e 3c       	cpi	r16, 0xCE	; 206
     146:	c3 bd       	out	0x23, r28	; 35
     148:	42 82       	std	Z+2, r4	; 0x02
     14a:	ad 2b       	or	r26, r29
     14c:	3e 68       	ori	r19, 0x8E	; 142
     14e:	ec 82       	std	Y+4, r14	; 0x04
     150:	76 be       	out	0x36, r7	; 54
     152:	d9 8f       	std	Y+25, r29	; 0x19
     154:	e1 a9       	sts	0x41, r30
     156:	3e 4c       	sbci	r19, 0xCE	; 206
     158:	80 ef       	ldi	r24, 0xF0	; 240
     15a:	ff be       	out	0x3f, r15	; 63
     15c:	01 c4       	rjmp	.+2050   	; 0x960 <servo_1+0x1c>
     15e:	ff 7f       	andi	r31, 0xFF	; 255
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
	...

00000166 <__ctors_end>:
     166:	11 24       	eor	r1, r1
     168:	1f be       	out	0x3f, r1	; 63
     16a:	cf ef       	ldi	r28, 0xFF	; 255
     16c:	d1 e2       	ldi	r29, 0x21	; 33
     16e:	de bf       	out	0x3e, r29	; 62
     170:	cd bf       	out	0x3d, r28	; 61
     172:	00 e0       	ldi	r16, 0x00	; 0
     174:	0c bf       	out	0x3c, r16	; 60

00000176 <__do_copy_data>:
     176:	12 e0       	ldi	r17, 0x02	; 2
     178:	a0 e0       	ldi	r26, 0x00	; 0
     17a:	b2 e0       	ldi	r27, 0x02	; 2
     17c:	ea e0       	ldi	r30, 0x0A	; 10
     17e:	f7 e3       	ldi	r31, 0x37	; 55
     180:	00 e0       	ldi	r16, 0x00	; 0
     182:	0b bf       	out	0x3b, r16	; 59
     184:	02 c0       	rjmp	.+4      	; 0x18a <__do_copy_data+0x14>
     186:	07 90       	elpm	r0, Z+
     188:	0d 92       	st	X+, r0
     18a:	a6 39       	cpi	r26, 0x96	; 150
     18c:	b1 07       	cpc	r27, r17
     18e:	d9 f7       	brne	.-10     	; 0x186 <__do_copy_data+0x10>

00000190 <__do_clear_bss>:
     190:	13 e0       	ldi	r17, 0x03	; 3
     192:	a6 e9       	ldi	r26, 0x96	; 150
     194:	b2 e0       	ldi	r27, 0x02	; 2
     196:	01 c0       	rjmp	.+2      	; 0x19a <.do_clear_bss_start>

00000198 <.do_clear_bss_loop>:
     198:	1d 92       	st	X+, r1

0000019a <.do_clear_bss_start>:
     19a:	ab 36       	cpi	r26, 0x6B	; 107
     19c:	b1 07       	cpc	r27, r17
     19e:	e1 f7       	brne	.-8      	; 0x198 <.do_clear_bss_loop>
     1a0:	0e 94 f0 13 	call	0x27e0	; 0x27e0 <main>
     1a4:	0c 94 83 1b 	jmp	0x3706	; 0x3706 <_exit>

000001a8 <__bad_interrupt>:
     1a8:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000001ac <lcd_set_4bit>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     1ac:	86 e6       	ldi	r24, 0x66	; 102
     1ae:	9e e0       	ldi	r25, 0x0E	; 14
     1b0:	01 97       	sbiw	r24, 0x01	; 1
     1b2:	f1 f7       	brne	.-4      	; 0x1b0 <lcd_set_4bit+0x4>
     1b4:	00 00       	nop
//Function to Reset LCD
void lcd_set_4bit()
{
	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     1b6:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     1b8:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
     1ba:	80 e3       	ldi	r24, 0x30	; 48
     1bc:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     1be:	42 9a       	sbi	0x08, 2	; 8
     1c0:	ef ef       	ldi	r30, 0xFF	; 255
     1c2:	f7 e4       	ldi	r31, 0x47	; 71
     1c4:	31 97       	sbiw	r30, 0x01	; 1
     1c6:	f1 f7       	brne	.-4      	; 0x1c4 <lcd_set_4bit+0x18>
     1c8:	00 c0       	rjmp	.+0      	; 0x1ca <lcd_set_4bit+0x1e>
     1ca:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     1cc:	42 98       	cbi	0x08, 2	; 8
     1ce:	e6 e6       	ldi	r30, 0x66	; 102
     1d0:	fe e0       	ldi	r31, 0x0E	; 14
     1d2:	31 97       	sbiw	r30, 0x01	; 1
     1d4:	f1 f7       	brne	.-4      	; 0x1d2 <lcd_set_4bit+0x26>
     1d6:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     1d8:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     1da:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
     1dc:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     1de:	42 9a       	sbi	0x08, 2	; 8
     1e0:	ef ef       	ldi	r30, 0xFF	; 255
     1e2:	f7 e4       	ldi	r31, 0x47	; 71
     1e4:	31 97       	sbiw	r30, 0x01	; 1
     1e6:	f1 f7       	brne	.-4      	; 0x1e4 <lcd_set_4bit+0x38>
     1e8:	00 c0       	rjmp	.+0      	; 0x1ea <lcd_set_4bit+0x3e>
     1ea:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     1ec:	42 98       	cbi	0x08, 2	; 8
     1ee:	e6 e6       	ldi	r30, 0x66	; 102
     1f0:	fe e0       	ldi	r31, 0x0E	; 14
     1f2:	31 97       	sbiw	r30, 0x01	; 1
     1f4:	f1 f7       	brne	.-4      	; 0x1f2 <lcd_set_4bit+0x46>
     1f6:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     1f8:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     1fa:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
     1fc:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     1fe:	42 9a       	sbi	0x08, 2	; 8
     200:	8f ef       	ldi	r24, 0xFF	; 255
     202:	97 e4       	ldi	r25, 0x47	; 71
     204:	01 97       	sbiw	r24, 0x01	; 1
     206:	f1 f7       	brne	.-4      	; 0x204 <lcd_set_4bit+0x58>
     208:	00 c0       	rjmp	.+0      	; 0x20a <lcd_set_4bit+0x5e>
     20a:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     20c:	42 98       	cbi	0x08, 2	; 8
     20e:	e6 e6       	ldi	r30, 0x66	; 102
     210:	fe e0       	ldi	r31, 0x0E	; 14
     212:	31 97       	sbiw	r30, 0x01	; 1
     214:	f1 f7       	brne	.-4      	; 0x212 <lcd_set_4bit+0x66>
     216:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     218:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     21a:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x20;				//Sending 2 to initialise LCD 4-bit mode
     21c:	80 e2       	ldi	r24, 0x20	; 32
     21e:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     220:	42 9a       	sbi	0x08, 2	; 8
     222:	8f ef       	ldi	r24, 0xFF	; 255
     224:	97 e4       	ldi	r25, 0x47	; 71
     226:	01 97       	sbiw	r24, 0x01	; 1
     228:	f1 f7       	brne	.-4      	; 0x226 <lcd_set_4bit+0x7a>
     22a:	00 c0       	rjmp	.+0      	; 0x22c <lcd_set_4bit+0x80>
     22c:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     22e:	42 98       	cbi	0x08, 2	; 8

	
}
     230:	08 95       	ret

00000232 <lcd_wr_command>:
void lcd_wr_command(unsigned char cmd)
{
	unsigned char temp;
	temp = cmd;
	temp = temp & 0xF0;
	lcd_port &= 0x0F;
     232:	98 b1       	in	r25, 0x08	; 8
     234:	9f 70       	andi	r25, 0x0F	; 15
     236:	98 b9       	out	0x08, r25	; 8
	lcd_port |= temp;
     238:	98 b1       	in	r25, 0x08	; 8
//Function to Write Command on LCD
void lcd_wr_command(unsigned char cmd)
{
	unsigned char temp;
	temp = cmd;
	temp = temp & 0xF0;
     23a:	28 2f       	mov	r18, r24
     23c:	20 7f       	andi	r18, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= temp;
     23e:	92 2b       	or	r25, r18
     240:	98 b9       	out	0x08, r25	; 8
	cbit(lcd_port,RS);
     242:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     244:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     246:	42 9a       	sbi	0x08, 2	; 8
     248:	ef ef       	ldi	r30, 0xFF	; 255
     24a:	f7 e4       	ldi	r31, 0x47	; 71
     24c:	31 97       	sbiw	r30, 0x01	; 1
     24e:	f1 f7       	brne	.-4      	; 0x24c <lcd_wr_command+0x1a>
     250:	00 c0       	rjmp	.+0      	; 0x252 <lcd_wr_command+0x20>
     252:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     254:	42 98       	cbi	0x08, 2	; 8
	
	cmd = cmd & 0x0F;
	cmd = cmd<<4;
	lcd_port &= 0x0F;
     256:	98 b1       	in	r25, 0x08	; 8
     258:	9f 70       	andi	r25, 0x0F	; 15
     25a:	98 b9       	out	0x08, r25	; 8
	lcd_port |= cmd;
     25c:	98 b1       	in	r25, 0x08	; 8
	sbit(lcd_port,EN);
	_delay_ms(5);
	cbit(lcd_port,EN);
	
	cmd = cmd & 0x0F;
	cmd = cmd<<4;
     25e:	82 95       	swap	r24
     260:	80 7f       	andi	r24, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= cmd;
     262:	89 2b       	or	r24, r25
     264:	88 b9       	out	0x08, r24	; 8
	cbit(lcd_port,RS);
     266:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     268:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     26a:	42 9a       	sbi	0x08, 2	; 8
     26c:	8f ef       	ldi	r24, 0xFF	; 255
     26e:	97 e4       	ldi	r25, 0x47	; 71
     270:	01 97       	sbiw	r24, 0x01	; 1
     272:	f1 f7       	brne	.-4      	; 0x270 <lcd_wr_command+0x3e>
     274:	00 c0       	rjmp	.+0      	; 0x276 <lcd_wr_command+0x44>
     276:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     278:	42 98       	cbi	0x08, 2	; 8
}
     27a:	08 95       	ret

0000027c <lcd_wr_char>:
void lcd_wr_char(char letter)
{
	char temp;
	temp = letter;
	temp = (temp & 0xF0);
	lcd_port &= 0x0F;
     27c:	98 b1       	in	r25, 0x08	; 8
     27e:	9f 70       	andi	r25, 0x0F	; 15
     280:	98 b9       	out	0x08, r25	; 8
	lcd_port |= temp;
     282:	98 b1       	in	r25, 0x08	; 8
//Function to Write Data on LCD
void lcd_wr_char(char letter)
{
	char temp;
	temp = letter;
	temp = (temp & 0xF0);
     284:	28 2f       	mov	r18, r24
     286:	20 7f       	andi	r18, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= temp;
     288:	92 2b       	or	r25, r18
     28a:	98 b9       	out	0x08, r25	; 8
	sbit(lcd_port,RS);
     28c:	40 9a       	sbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     28e:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     290:	42 9a       	sbi	0x08, 2	; 8
     292:	ef ef       	ldi	r30, 0xFF	; 255
     294:	f7 e4       	ldi	r31, 0x47	; 71
     296:	31 97       	sbiw	r30, 0x01	; 1
     298:	f1 f7       	brne	.-4      	; 0x296 <lcd_wr_char+0x1a>
     29a:	00 c0       	rjmp	.+0      	; 0x29c <lcd_wr_char+0x20>
     29c:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     29e:	42 98       	cbi	0x08, 2	; 8

	letter = letter & 0x0F;
	letter = letter<<4;
	lcd_port &= 0x0F;
     2a0:	98 b1       	in	r25, 0x08	; 8
     2a2:	9f 70       	andi	r25, 0x0F	; 15
     2a4:	98 b9       	out	0x08, r25	; 8
	lcd_port |= letter;
     2a6:	98 b1       	in	r25, 0x08	; 8
	sbit(lcd_port,EN);
	_delay_ms(5);
	cbit(lcd_port,EN);

	letter = letter & 0x0F;
	letter = letter<<4;
     2a8:	82 95       	swap	r24
     2aa:	80 7f       	andi	r24, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= letter;
     2ac:	89 2b       	or	r24, r25
     2ae:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,RS);
     2b0:	40 9a       	sbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     2b2:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     2b4:	42 9a       	sbi	0x08, 2	; 8
     2b6:	8f ef       	ldi	r24, 0xFF	; 255
     2b8:	97 e4       	ldi	r25, 0x47	; 71
     2ba:	01 97       	sbiw	r24, 0x01	; 1
     2bc:	f1 f7       	brne	.-4      	; 0x2ba <lcd_wr_char+0x3e>
     2be:	00 c0       	rjmp	.+0      	; 0x2c0 <lcd_wr_char+0x44>
     2c0:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     2c2:	42 98       	cbi	0x08, 2	; 8
}
     2c4:	08 95       	ret

000002c6 <lcd_home>:


//Function to bring cursor at home position
void lcd_home()
{
	lcd_wr_command(0x80);
     2c6:	80 e8       	ldi	r24, 0x80	; 128
     2c8:	0e 94 19 01 	call	0x232	; 0x232 <lcd_wr_command>
}
     2cc:	08 95       	ret

000002ce <lcd_string>:


//Function to Print String on LCD
void lcd_string(char *str)
{
     2ce:	cf 93       	push	r28
     2d0:	df 93       	push	r29
     2d2:	ec 01       	movw	r28, r24
	while(*str != '\0')
     2d4:	88 81       	ld	r24, Y
     2d6:	88 23       	and	r24, r24
     2d8:	31 f0       	breq	.+12     	; 0x2e6 <lcd_string+0x18>
	lcd_wr_command(0x80);
}


//Function to Print String on LCD
void lcd_string(char *str)
     2da:	21 96       	adiw	r28, 0x01	; 1
{
	while(*str != '\0')
	{
		lcd_wr_char(*str);
     2dc:	0e 94 3e 01 	call	0x27c	; 0x27c <lcd_wr_char>


//Function to Print String on LCD
void lcd_string(char *str)
{
	while(*str != '\0')
     2e0:	89 91       	ld	r24, Y+
     2e2:	88 23       	and	r24, r24
     2e4:	d9 f7       	brne	.-10     	; 0x2dc <lcd_string+0xe>
	{
		lcd_wr_char(*str);
		str++;
	}
}
     2e6:	df 91       	pop	r29
     2e8:	cf 91       	pop	r28
     2ea:	08 95       	ret

000002ec <lcd_cursor>:

//Position the LCD cursor at "row", "column".

void lcd_cursor (char row, char column)
{
	switch (row) {
     2ec:	82 30       	cpi	r24, 0x02	; 2
     2ee:	79 f0       	breq	.+30     	; 0x30e <lcd_cursor+0x22>
     2f0:	83 30       	cpi	r24, 0x03	; 3
     2f2:	18 f4       	brcc	.+6      	; 0x2fa <lcd_cursor+0xe>
     2f4:	81 30       	cpi	r24, 0x01	; 1
     2f6:	c9 f4       	brne	.+50     	; 0x32a <lcd_cursor+0x3e>
     2f8:	05 c0       	rjmp	.+10     	; 0x304 <lcd_cursor+0x18>
     2fa:	83 30       	cpi	r24, 0x03	; 3
     2fc:	69 f0       	breq	.+26     	; 0x318 <lcd_cursor+0x2c>
     2fe:	84 30       	cpi	r24, 0x04	; 4
     300:	a1 f4       	brne	.+40     	; 0x32a <lcd_cursor+0x3e>
     302:	0f c0       	rjmp	.+30     	; 0x322 <lcd_cursor+0x36>
		case 1: lcd_wr_command (0x80 + column - 1); break;
     304:	86 2f       	mov	r24, r22
     306:	81 58       	subi	r24, 0x81	; 129
     308:	0e 94 19 01 	call	0x232	; 0x232 <lcd_wr_command>
     30c:	08 95       	ret
		case 2: lcd_wr_command (0xc0 + column - 1); break;
     30e:	86 2f       	mov	r24, r22
     310:	81 54       	subi	r24, 0x41	; 65
     312:	0e 94 19 01 	call	0x232	; 0x232 <lcd_wr_command>
     316:	08 95       	ret
		case 3: lcd_wr_command (0x94 + column - 1); break;
     318:	86 2f       	mov	r24, r22
     31a:	8d 56       	subi	r24, 0x6D	; 109
     31c:	0e 94 19 01 	call	0x232	; 0x232 <lcd_wr_command>
     320:	08 95       	ret
		case 4: lcd_wr_command (0xd4 + column - 1); break;
     322:	86 2f       	mov	r24, r22
     324:	8d 52       	subi	r24, 0x2D	; 45
     326:	0e 94 19 01 	call	0x232	; 0x232 <lcd_wr_command>
     32a:	08 95       	ret

0000032c <lcd_print>:
	}
}

//Function To Print Any input value upto the desired digit on LCD
void lcd_print (char row, char coloumn, unsigned int value, int digits)
{
     32c:	0f 93       	push	r16
     32e:	1f 93       	push	r17
     330:	cf 93       	push	r28
     332:	df 93       	push	r29
     334:	8a 01       	movw	r16, r20
     336:	e9 01       	movw	r28, r18
	unsigned char flag=0;
	if(row==0||coloumn==0)
     338:	88 23       	and	r24, r24
     33a:	11 f0       	breq	.+4      	; 0x340 <lcd_print+0x14>
     33c:	66 23       	and	r22, r22
     33e:	19 f4       	brne	.+6      	; 0x346 <lcd_print+0x1a>
	{
		lcd_home();
     340:	0e 94 63 01 	call	0x2c6	; 0x2c6 <lcd_home>
     344:	02 c0       	rjmp	.+4      	; 0x34a <lcd_print+0x1e>
	}
	else
	{
		lcd_cursor(row,coloumn);
     346:	0e 94 76 01 	call	0x2ec	; 0x2ec <lcd_cursor>
	}
	if(digits==5 || flag==1)
     34a:	c5 30       	cpi	r28, 0x05	; 5
     34c:	d1 05       	cpc	r29, r1
     34e:	71 f4       	brne	.+28     	; 0x36c <lcd_print+0x40>
	{
		million=value/10000+48;
     350:	c8 01       	movw	r24, r16
     352:	60 e1       	ldi	r22, 0x10	; 16
     354:	77 e2       	ldi	r23, 0x27	; 39
     356:	0e 94 5c 1b 	call	0x36b8	; 0x36b8 <__udivmodhi4>
     35a:	cb 01       	movw	r24, r22
     35c:	c0 96       	adiw	r24, 0x30	; 48
     35e:	90 93 46 03 	sts	0x0346, r25
     362:	80 93 45 03 	sts	0x0345, r24
		lcd_wr_char(million);
     366:	0e 94 3e 01 	call	0x27c	; 0x27c <lcd_wr_char>
     36a:	03 c0       	rjmp	.+6      	; 0x372 <lcd_print+0x46>
		flag=1;
	}
	if(digits==4 || flag==1)
     36c:	c4 30       	cpi	r28, 0x04	; 4
     36e:	d1 05       	cpc	r29, r1
     370:	b9 f4       	brne	.+46     	; 0x3a0 <lcd_print+0x74>
	{
		temp = value/1000;
     372:	c8 01       	movw	r24, r16
     374:	68 ee       	ldi	r22, 0xE8	; 232
     376:	73 e0       	ldi	r23, 0x03	; 3
     378:	0e 94 5c 1b 	call	0x36b8	; 0x36b8 <__udivmodhi4>
     37c:	cb 01       	movw	r24, r22
     37e:	70 93 4b 03 	sts	0x034B, r23
     382:	60 93 4a 03 	sts	0x034A, r22
		thousand = temp%10 + 48;
     386:	6a e0       	ldi	r22, 0x0A	; 10
     388:	70 e0       	ldi	r23, 0x00	; 0
     38a:	0e 94 5c 1b 	call	0x36b8	; 0x36b8 <__udivmodhi4>
     38e:	c0 96       	adiw	r24, 0x30	; 48
     390:	90 93 66 03 	sts	0x0366, r25
     394:	80 93 65 03 	sts	0x0365, r24
		lcd_wr_char(thousand);
     398:	0e 94 3e 01 	call	0x27c	; 0x27c <lcd_wr_char>
		flag=1;
     39c:	81 e0       	ldi	r24, 0x01	; 1
     39e:	01 c0       	rjmp	.+2      	; 0x3a2 <lcd_print+0x76>
}

//Function To Print Any input value upto the desired digit on LCD
void lcd_print (char row, char coloumn, unsigned int value, int digits)
{
	unsigned char flag=0;
     3a0:	80 e0       	ldi	r24, 0x00	; 0
		temp = value/1000;
		thousand = temp%10 + 48;
		lcd_wr_char(thousand);
		flag=1;
	}
	if(digits==3 || flag==1)
     3a2:	c3 30       	cpi	r28, 0x03	; 3
     3a4:	d1 05       	cpc	r29, r1
     3a6:	11 f0       	breq	.+4      	; 0x3ac <lcd_print+0x80>
     3a8:	81 30       	cpi	r24, 0x01	; 1
     3aa:	b1 f4       	brne	.+44     	; 0x3d8 <lcd_print+0xac>
	{
		temp = value/100;
     3ac:	c8 01       	movw	r24, r16
     3ae:	64 e6       	ldi	r22, 0x64	; 100
     3b0:	70 e0       	ldi	r23, 0x00	; 0
     3b2:	0e 94 5c 1b 	call	0x36b8	; 0x36b8 <__udivmodhi4>
     3b6:	cb 01       	movw	r24, r22
     3b8:	70 93 4b 03 	sts	0x034B, r23
     3bc:	60 93 4a 03 	sts	0x034A, r22
		hundred = temp%10 + 48;
     3c0:	6a e0       	ldi	r22, 0x0A	; 10
     3c2:	70 e0       	ldi	r23, 0x00	; 0
     3c4:	0e 94 5c 1b 	call	0x36b8	; 0x36b8 <__udivmodhi4>
     3c8:	c0 96       	adiw	r24, 0x30	; 48
     3ca:	90 93 61 03 	sts	0x0361, r25
     3ce:	80 93 60 03 	sts	0x0360, r24
		lcd_wr_char(hundred);
     3d2:	0e 94 3e 01 	call	0x27c	; 0x27c <lcd_wr_char>
		flag=1;
     3d6:	81 e0       	ldi	r24, 0x01	; 1
	}
	if(digits==2 || flag==1)
     3d8:	c2 30       	cpi	r28, 0x02	; 2
     3da:	d1 05       	cpc	r29, r1
     3dc:	11 f0       	breq	.+4      	; 0x3e2 <lcd_print+0xb6>
     3de:	81 30       	cpi	r24, 0x01	; 1
     3e0:	b1 f4       	brne	.+44     	; 0x40e <lcd_print+0xe2>
	{
		temp = value/10;
     3e2:	2a e0       	ldi	r18, 0x0A	; 10
     3e4:	30 e0       	ldi	r19, 0x00	; 0
     3e6:	c8 01       	movw	r24, r16
     3e8:	b9 01       	movw	r22, r18
     3ea:	0e 94 5c 1b 	call	0x36b8	; 0x36b8 <__udivmodhi4>
     3ee:	cb 01       	movw	r24, r22
     3f0:	70 93 4b 03 	sts	0x034B, r23
     3f4:	60 93 4a 03 	sts	0x034A, r22
		tens = temp%10 + 48;
     3f8:	b9 01       	movw	r22, r18
     3fa:	0e 94 5c 1b 	call	0x36b8	; 0x36b8 <__udivmodhi4>
     3fe:	c0 96       	adiw	r24, 0x30	; 48
     400:	90 93 5b 03 	sts	0x035B, r25
     404:	80 93 5a 03 	sts	0x035A, r24
		lcd_wr_char(tens);
     408:	0e 94 3e 01 	call	0x27c	; 0x27c <lcd_wr_char>
		flag=1;
     40c:	81 e0       	ldi	r24, 0x01	; 1
	}
	if(digits==1 || flag==1)
     40e:	c1 30       	cpi	r28, 0x01	; 1
     410:	d1 05       	cpc	r29, r1
     412:	11 f0       	breq	.+4      	; 0x418 <lcd_print+0xec>
     414:	81 30       	cpi	r24, 0x01	; 1
     416:	61 f4       	brne	.+24     	; 0x430 <lcd_print+0x104>
	{
		unit = value%10 + 48;
     418:	c8 01       	movw	r24, r16
     41a:	6a e0       	ldi	r22, 0x0A	; 10
     41c:	70 e0       	ldi	r23, 0x00	; 0
     41e:	0e 94 5c 1b 	call	0x36b8	; 0x36b8 <__udivmodhi4>
     422:	c0 96       	adiw	r24, 0x30	; 48
     424:	90 93 64 03 	sts	0x0364, r25
     428:	80 93 63 03 	sts	0x0363, r24
		lcd_wr_char(unit);
     42c:	0e 94 3e 01 	call	0x27c	; 0x27c <lcd_wr_char>
	}
	if(digits>5)
     430:	c6 30       	cpi	r28, 0x06	; 6
     432:	d1 05       	cpc	r29, r1
     434:	1c f0       	brlt	.+6      	; 0x43c <lcd_print+0x110>
	{
		lcd_wr_char('E');
     436:	85 e4       	ldi	r24, 0x45	; 69
     438:	0e 94 3e 01 	call	0x27c	; 0x27c <lcd_wr_char>
	}
	
}
     43c:	df 91       	pop	r29
     43e:	cf 91       	pop	r28
     440:	1f 91       	pop	r17
     442:	0f 91       	pop	r16
     444:	08 95       	ret

00000446 <buzzer_pin_config>:
unsigned char ADC_Value;
unsigned char sharp, distance, adc_reading;
unsigned int value;	//stores sharp sensor values in mm.

void buzzer_pin_config(void) {
    DDRC = DDRC | 0x08; //Setting PORTC 3 as output
     446:	3b 9a       	sbi	0x07, 3	; 7
    PORTC = PORTC & 0xF7; //Setting PORTC 3 logic low to turnoff buzzer
     448:	43 98       	cbi	0x08, 3	; 8
}
     44a:	08 95       	ret

0000044c <color_sensor_pin_config>:

void color_sensor_pin_config(void) {
    DDRD = DDRD | 0xFE; //set PD0 as input for color sensor output
     44c:	8a b1       	in	r24, 0x0a	; 10
     44e:	8e 6f       	ori	r24, 0xFE	; 254
     450:	8a b9       	out	0x0a, r24	; 10
    PORTD = PORTD | 0x01; //Enable internal pull-up for PORTD 0 pin
     452:	58 9a       	sbi	0x0b, 0	; 11
}
     454:	08 95       	ret

00000456 <color_sensor_pin_interrupt_init>:

void color_sensor_pin_interrupt_init(void) //Interrupt 0 enable
    {
        cli(); //Clears the global interrupt
     456:	f8 94       	cli
        EICRA = EICRA | 0x02; // INT0 is set to trigger with falling edge
     458:	e9 e6       	ldi	r30, 0x69	; 105
     45a:	f0 e0       	ldi	r31, 0x00	; 0
     45c:	80 81       	ld	r24, Z
     45e:	82 60       	ori	r24, 0x02	; 2
     460:	80 83       	st	Z, r24
        EIMSK = EIMSK | 0x01; // Enable Interrupt INT0 for color sensor
     462:	e8 9a       	sbi	0x1d, 0	; 29
        sei(); // Enables the global interrupt
     464:	78 94       	sei
    }
     466:	08 95       	ret

00000468 <__vector_1>:


ISR(INT0_vect) {
     468:	1f 92       	push	r1
     46a:	0f 92       	push	r0
     46c:	0f b6       	in	r0, 0x3f	; 63
     46e:	0f 92       	push	r0
     470:	11 24       	eor	r1, r1
     472:	8f 93       	push	r24
     474:	9f 93       	push	r25
     476:	af 93       	push	r26
     478:	bf 93       	push	r27
    pulse++; //increment on receiving pulse from the color sensor
     47a:	80 91 33 03 	lds	r24, 0x0333
     47e:	90 91 34 03 	lds	r25, 0x0334
     482:	a0 91 35 03 	lds	r26, 0x0335
     486:	b0 91 36 03 	lds	r27, 0x0336
     48a:	01 96       	adiw	r24, 0x01	; 1
     48c:	a1 1d       	adc	r26, r1
     48e:	b1 1d       	adc	r27, r1
     490:	80 93 33 03 	sts	0x0333, r24
     494:	90 93 34 03 	sts	0x0334, r25
     498:	a0 93 35 03 	sts	0x0335, r26
     49c:	b0 93 36 03 	sts	0x0336, r27
}
     4a0:	bf 91       	pop	r27
     4a2:	af 91       	pop	r26
     4a4:	9f 91       	pop	r25
     4a6:	8f 91       	pop	r24
     4a8:	0f 90       	pop	r0
     4aa:	0f be       	out	0x3f, r0	; 63
     4ac:	0f 90       	pop	r0
     4ae:	1f 90       	pop	r1
     4b0:	18 95       	reti

000004b2 <left_encoder_pin_config>:

void left_encoder_pin_config(void) {
    DDRE = DDRE & 0xEF; //Set the direction of the PORTE 4 pin as input
     4b2:	6c 98       	cbi	0x0d, 4	; 13
    PORTE = PORTE | 0x10; //Enable internal pull-up for PORTE 4 pin
     4b4:	74 9a       	sbi	0x0e, 4	; 14
}
     4b6:	08 95       	ret

000004b8 <right_encoder_pin_config>:

void right_encoder_pin_config(void) {
    DDRE = DDRE & 0xDF; //Set the direction of the PORTE 4 pin as input
     4b8:	6d 98       	cbi	0x0d, 5	; 13
    PORTE = PORTE | 0x20; //Enable internal pull-up for PORTE 4 pin
     4ba:	75 9a       	sbi	0x0e, 5	; 14
}
     4bc:	08 95       	ret

000004be <servo1_pin_config>:

void servo1_pin_config(void) {
    DDRB = DDRB | 0x20; //making PORTB 5 pin output
     4be:	25 9a       	sbi	0x04, 5	; 4
    PORTB = PORTB | 0x20; //setting PORTB 5 pin to logic 1
     4c0:	2d 9a       	sbi	0x05, 5	; 5
}
     4c2:	08 95       	ret

000004c4 <servo2_pin_config>:

void servo2_pin_config(void) {
    DDRB = DDRB | 0x40; //making PORTB 6 pin output
     4c4:	26 9a       	sbi	0x04, 6	; 4
    PORTB = PORTB | 0x40; //setting PORTB 6 pin to logic 1
     4c6:	2e 9a       	sbi	0x05, 6	; 5
}
     4c8:	08 95       	ret

000004ca <servo3_pin_config>:

void servo3_pin_config(void) {
    DDRB = DDRB | 0x80; //making PORTB 7 pin output
     4ca:	27 9a       	sbi	0x04, 7	; 4
    PORTB = PORTB | 0x80; //setting PORTB 7 pin to logic 1
     4cc:	2f 9a       	sbi	0x05, 7	; 5
}
     4ce:	08 95       	ret

000004d0 <lcd_port_config>:

void lcd_port_config(void) {
    DDRC = DDRC | 0xF7; //all the LCD pin's direction set as output
     4d0:	87 b1       	in	r24, 0x07	; 7
     4d2:	87 6f       	ori	r24, 0xF7	; 247
     4d4:	87 b9       	out	0x07, r24	; 7
    PORTC = PORTC & 0x80; // all the LCD pins are set to logic 0 except PORTC 7
     4d6:	88 b1       	in	r24, 0x08	; 8
     4d8:	80 78       	andi	r24, 0x80	; 128
     4da:	88 b9       	out	0x08, r24	; 8
}
     4dc:	08 95       	ret

000004de <adc_pin_config>:

void adc_pin_config(void) {
    DDRF = 0x00; //set PORTF direction as input
     4de:	10 ba       	out	0x10, r1	; 16
    PORTF = 0x00; //set PORTF pins floating
     4e0:	11 ba       	out	0x11, r1	; 17
    DDRK = 0x00; //set PORTK direction as input
     4e2:	10 92 07 01 	sts	0x0107, r1
    PORTK = 0x00; //set PORTK pins floating
     4e6:	10 92 08 01 	sts	0x0108, r1
}
     4ea:	08 95       	ret

000004ec <motion_pin_config>:

void motion_pin_config(void) {
    DDRA = DDRA | 0x0F; //set direction of the PORTA 3 to PORTA 0 pins as output
     4ec:	81 b1       	in	r24, 0x01	; 1
     4ee:	8f 60       	ori	r24, 0x0F	; 15
     4f0:	81 b9       	out	0x01, r24	; 1
    PORTA = PORTA & 0xF0; // set initial value of the PORTA 3 to PORTA 0 pins to logic 0
     4f2:	82 b1       	in	r24, 0x02	; 2
     4f4:	80 7f       	andi	r24, 0xF0	; 240
     4f6:	82 b9       	out	0x02, r24	; 2
    DDRL = DDRL | 0x18; //Setting PL3 and PL4 pins as output for PWM generation
     4f8:	ea e0       	ldi	r30, 0x0A	; 10
     4fa:	f1 e0       	ldi	r31, 0x01	; 1
     4fc:	80 81       	ld	r24, Z
     4fe:	88 61       	ori	r24, 0x18	; 24
     500:	80 83       	st	Z, r24
    PORTL = PORTL | 0x18; //PL3 and PL4 pins are for velocity control using PWM
     502:	eb e0       	ldi	r30, 0x0B	; 11
     504:	f1 e0       	ldi	r31, 0x01	; 1
     506:	80 81       	ld	r24, Z
     508:	88 61       	ori	r24, 0x18	; 24
     50a:	80 83       	st	Z, r24
}
     50c:	08 95       	ret

0000050e <LED_bargraph_config>:

void LED_bargraph_config(void) {
    DDRJ = 0xFF; //PORT J is configured as output
     50e:	8f ef       	ldi	r24, 0xFF	; 255
     510:	80 93 04 01 	sts	0x0104, r24
    PORTJ = 0x00; //Output is set to 0
     514:	10 92 05 01 	sts	0x0105, r1
}
     518:	08 95       	ret

0000051a <port_init>:

void port_init(void) {
    buzzer_pin_config();
     51a:	0e 94 23 02 	call	0x446	; 0x446 <buzzer_pin_config>
    lcd_port_config();
     51e:	0e 94 68 02 	call	0x4d0	; 0x4d0 <lcd_port_config>
    LED_bargraph_config();
     522:	0e 94 87 02 	call	0x50e	; 0x50e <LED_bargraph_config>
    left_encoder_pin_config();
     526:	0e 94 59 02 	call	0x4b2	; 0x4b2 <left_encoder_pin_config>
    right_encoder_pin_config();
     52a:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <right_encoder_pin_config>
    servo1_pin_config();
     52e:	0e 94 5f 02 	call	0x4be	; 0x4be <servo1_pin_config>
    servo2_pin_config();
     532:	0e 94 62 02 	call	0x4c4	; 0x4c4 <servo2_pin_config>
    servo3_pin_config();
     536:	0e 94 65 02 	call	0x4ca	; 0x4ca <servo3_pin_config>
    adc_pin_config();
     53a:	0e 94 6f 02 	call	0x4de	; 0x4de <adc_pin_config>
    motion_pin_config();
     53e:	0e 94 76 02 	call	0x4ec	; 0x4ec <motion_pin_config>
    color_sensor_pin_config();
     542:	0e 94 26 02 	call	0x44c	; 0x44c <color_sensor_pin_config>
}
     546:	08 95       	ret

00000548 <Sharp_GP2D12_estimation>:

unsigned int Sharp_GP2D12_estimation(unsigned char adc_reading) {
     548:	0f 93       	push	r16
     54a:	1f 93       	push	r17
    float distance;
    unsigned int distanceInt;
    distance = (int)(10.00 * (2799.6 * (1.00 / (pow(adc_reading, 1.1546)))));
     54c:	68 2f       	mov	r22, r24
     54e:	70 e0       	ldi	r23, 0x00	; 0
     550:	80 e0       	ldi	r24, 0x00	; 0
     552:	90 e0       	ldi	r25, 0x00	; 0
     554:	0e 94 06 19 	call	0x320c	; 0x320c <__floatunsisf>
     558:	2f ee       	ldi	r18, 0xEF	; 239
     55a:	39 ec       	ldi	r19, 0xC9	; 201
     55c:	43 e9       	ldi	r20, 0x93	; 147
     55e:	5f e3       	ldi	r21, 0x3F	; 63
     560:	0e 94 f7 19 	call	0x33ee	; 0x33ee <pow>
     564:	b6 2f       	mov	r27, r22
     566:	a7 2f       	mov	r26, r23
     568:	38 2f       	mov	r19, r24
     56a:	29 2f       	mov	r18, r25
     56c:	60 e0       	ldi	r22, 0x00	; 0
     56e:	70 e0       	ldi	r23, 0x00	; 0
     570:	80 e8       	ldi	r24, 0x80	; 128
     572:	9f e3       	ldi	r25, 0x3F	; 63
     574:	42 2f       	mov	r20, r18
     576:	0b 2f       	mov	r16, r27
     578:	1a 2f       	mov	r17, r26
     57a:	23 2f       	mov	r18, r19
     57c:	34 2f       	mov	r19, r20
     57e:	a9 01       	movw	r20, r18
     580:	98 01       	movw	r18, r16
     582:	0e 94 6d 18 	call	0x30da	; 0x30da <__divsf3>
     586:	2a e9       	ldi	r18, 0x9A	; 154
     588:	39 ef       	ldi	r19, 0xF9	; 249
     58a:	4e e2       	ldi	r20, 0x2E	; 46
     58c:	55 e4       	ldi	r21, 0x45	; 69
     58e:	0e 94 94 19 	call	0x3328	; 0x3328 <__mulsf3>
     592:	20 e0       	ldi	r18, 0x00	; 0
     594:	30 e0       	ldi	r19, 0x00	; 0
     596:	40 e2       	ldi	r20, 0x20	; 32
     598:	51 e4       	ldi	r21, 0x41	; 65
     59a:	0e 94 94 19 	call	0x3328	; 0x3328 <__mulsf3>
     59e:	0e 94 d5 18 	call	0x31aa	; 0x31aa <__fixsfsi>
     5a2:	88 27       	eor	r24, r24
     5a4:	77 fd       	sbrc	r23, 7
     5a6:	80 95       	com	r24
     5a8:	98 2f       	mov	r25, r24
     5aa:	0e 94 08 19 	call	0x3210	; 0x3210 <__floatsisf>
    distanceInt = (int) distance;
     5ae:	0e 94 d5 18 	call	0x31aa	; 0x31aa <__fixsfsi>
    if (distanceInt > 800) {
        distanceInt = 800;
    }
    return distanceInt;
     5b2:	86 2f       	mov	r24, r22
     5b4:	97 2f       	mov	r25, r23
     5b6:	23 e0       	ldi	r18, 0x03	; 3
     5b8:	81 32       	cpi	r24, 0x21	; 33
     5ba:	92 07       	cpc	r25, r18
     5bc:	10 f0       	brcs	.+4      	; 0x5c2 <Sharp_GP2D12_estimation+0x7a>
     5be:	80 e2       	ldi	r24, 0x20	; 32
     5c0:	93 e0       	ldi	r25, 0x03	; 3
}
     5c2:	1f 91       	pop	r17
     5c4:	0f 91       	pop	r16
     5c6:	08 95       	ret

000005c8 <timer1_init>:

void timer1_init(void) {
    TCCR1B = 0x00; //stop
     5c8:	e1 e8       	ldi	r30, 0x81	; 129
     5ca:	f0 e0       	ldi	r31, 0x00	; 0
     5cc:	10 82       	st	Z, r1
    TCNT1H = 0xFC; //Counter high value to which OCR1xH value is to be compared with
     5ce:	8c ef       	ldi	r24, 0xFC	; 252
     5d0:	80 93 85 00 	sts	0x0085, r24
    TCNT1L = 0x01; //Counter low value to which OCR1xH value is to be compared with
     5d4:	81 e0       	ldi	r24, 0x01	; 1
     5d6:	80 93 84 00 	sts	0x0084, r24
    OCR1AH = 0x03; //Output compare Register high value for servo 1
     5da:	93 e0       	ldi	r25, 0x03	; 3
     5dc:	90 93 89 00 	sts	0x0089, r25
    OCR1AL = 0xFF; //Output Compare Register low Value For servo 1
     5e0:	8f ef       	ldi	r24, 0xFF	; 255
     5e2:	80 93 88 00 	sts	0x0088, r24
    OCR1BH = 0x03; //Output compare Register high value for servo 2
     5e6:	90 93 8b 00 	sts	0x008B, r25
    OCR1BL = 0xFF; //Output Compare Register low Value For servo 2
     5ea:	80 93 8a 00 	sts	0x008A, r24
    OCR1CH = 0x03; //Output compare Register high value for servo 3
     5ee:	90 93 8d 00 	sts	0x008D, r25
    OCR1CL = 0xFF; //Output Compare Register low Value For servo 3
     5f2:	80 93 8c 00 	sts	0x008C, r24
    ICR1H = 0x03;
     5f6:	90 93 87 00 	sts	0x0087, r25
    ICR1L = 0xFF;
     5fa:	80 93 86 00 	sts	0x0086, r24
    TCCR1A = 0xAB;
     5fe:	8b ea       	ldi	r24, 0xAB	; 171
     600:	80 93 80 00 	sts	0x0080, r24
    /*{COM1A1=1, COM1A0=0; COM1B1=1, COM1B0=0; COM1C1=1 COM1C0=0}
     					For Overriding normal port functionality to OCRnA outputs.
    				  {WGM11=1, WGM10=1} Along With WGM12 in TCCR1B for Selecting FAST PWM Mode*/
    TCCR1C = 0x00;
     604:	10 92 82 00 	sts	0x0082, r1
    TCCR1B = 0x0C; //WGM12=1; CS12=1, CS11=0, CS10=0 (Prescaler=256)
     608:	8c e0       	ldi	r24, 0x0C	; 12
     60a:	80 83       	st	Z, r24
}
     60c:	08 95       	ret

0000060e <timer5_init>:

void timer5_init() {
    TCCR5B = 0x00; //Stop
     60e:	e1 e2       	ldi	r30, 0x21	; 33
     610:	f1 e0       	ldi	r31, 0x01	; 1
     612:	10 82       	st	Z, r1
    TCNT5H = 0xFF; //Counter higher 8-bit value to which OCR5xH value is compared with
     614:	8f ef       	ldi	r24, 0xFF	; 255
     616:	80 93 25 01 	sts	0x0125, r24
    TCNT5L = 0x01; //Counter lower 8-bit value to which OCR5xH value is compared with
     61a:	91 e0       	ldi	r25, 0x01	; 1
     61c:	90 93 24 01 	sts	0x0124, r25
    OCR5AH = 0x00; //Output compare register high value for Left Motor
     620:	10 92 29 01 	sts	0x0129, r1
    OCR5AL = 0xFF; //Output compare register low value for Left Motor
     624:	80 93 28 01 	sts	0x0128, r24
    OCR5BH = 0x00; //Output compare register high value for Right Motor
     628:	10 92 2b 01 	sts	0x012B, r1
    OCR5BL = 0xFF; //Output compare register low value for Right Motor
     62c:	80 93 2a 01 	sts	0x012A, r24
    OCR5CH = 0x00; //Output compare register high value for Motor C1
     630:	10 92 2d 01 	sts	0x012D, r1
    OCR5CL = 0xFF; //Output compare register low value for Motor C1
     634:	80 93 2c 01 	sts	0x012C, r24
    TCCR5A = 0xA9; //COM5A1=1, COM5A0=0; COM5B1=1, COM5B0=0; COM5C1=1
     638:	89 ea       	ldi	r24, 0xA9	; 169
     63a:	80 93 20 01 	sts	0x0120, r24
    // COM5C0=0
    //For Overriding normal port functionality to OCRnA outputs. WGM51=0, WGM50=1 Along With GM52 //in TCCR5B for Selecting FAST PWM 8-bit Mode
    TCCR5B = 0x0B; //WGM12=1; CS12=0, CS11=1, CS10=1 (Prescaler=64)
     63e:	8b e0       	ldi	r24, 0x0B	; 11
     640:	80 83       	st	Z, r24
}
     642:	08 95       	ret

00000644 <buzzer_on>:

void buzzer_on(void) {
    unsigned char port_restore = 0;
    port_restore = PINC;
     644:	86 b1       	in	r24, 0x06	; 6
    port_restore = port_restore | 0x08;
     646:	88 60       	ori	r24, 0x08	; 8
    PORTC = port_restore;
     648:	88 b9       	out	0x08, r24	; 8
}
     64a:	08 95       	ret

0000064c <buzzer_off>:

void buzzer_off(void) {
    unsigned char port_restore = 0;
    port_restore = PINC;
     64c:	86 b1       	in	r24, 0x06	; 6
    port_restore = port_restore & 0xF7;
     64e:	87 7f       	andi	r24, 0xF7	; 247
    PORTC = port_restore;
     650:	88 b9       	out	0x08, r24	; 8
}
     652:	08 95       	ret

00000654 <velocity>:

void velocity(unsigned char left_motor, unsigned char right_motor) {
    OCR5AL = (unsigned char) left_motor;
     654:	80 93 28 01 	sts	0x0128, r24
    OCR5BL = (unsigned char) right_motor;
     658:	60 93 2a 01 	sts	0x012A, r22
}
     65c:	08 95       	ret

0000065e <motion_set>:

void motion_set(unsigned char Direction) {
    unsigned char PortARestore = 0;
    Direction &= 0x0F; // removing upper nibble as it is not needed
    PortARestore = PORTA; // reading the PORTA's original status
     65e:	92 b1       	in	r25, 0x02	; 2
    PortARestore &= 0xF0; // setting lower direction nibble to 0
     660:	90 7f       	andi	r25, 0xF0	; 240
    OCR5BL = (unsigned char) right_motor;
}

void motion_set(unsigned char Direction) {
    unsigned char PortARestore = 0;
    Direction &= 0x0F; // removing upper nibble as it is not needed
     662:	8f 70       	andi	r24, 0x0F	; 15
    PortARestore = PORTA; // reading the PORTA's original status
    PortARestore &= 0xF0; // setting lower direction nibble to 0
    PortARestore |= Direction; // adding lower nibble for direction command and
     664:	98 2b       	or	r25, r24
    // restoring the PORTA status
    PORTA = PortARestore; // setting the command to the port
     666:	92 b9       	out	0x02, r25	; 2
}
     668:	08 95       	ret

0000066a <forward>:

void forward(void) //both wheels forward
    {
        motion_set(0x06);
     66a:	86 e0       	ldi	r24, 0x06	; 6
     66c:	0e 94 2f 03 	call	0x65e	; 0x65e <motion_set>
    }
     670:	08 95       	ret

00000672 <reverse>:

void reverse(void) //both wheels backward
    {
        motion_set(0x09);
     672:	89 e0       	ldi	r24, 0x09	; 9
     674:	0e 94 2f 03 	call	0x65e	; 0x65e <motion_set>
    }
     678:	08 95       	ret

0000067a <left>:

void left(void) //Left wheel backward, Right wheel forward
    {
        motion_set(0x05);
     67a:	85 e0       	ldi	r24, 0x05	; 5
     67c:	0e 94 2f 03 	call	0x65e	; 0x65e <motion_set>
    }
     680:	08 95       	ret

00000682 <right>:

void right(void) //Left wheel forward, Right wheel backward
    {
        motion_set(0x0A);
     682:	8a e0       	ldi	r24, 0x0A	; 10
     684:	0e 94 2f 03 	call	0x65e	; 0x65e <motion_set>
    }
     688:	08 95       	ret

0000068a <stop>:

void stop(void) //hard stop if PORTL 3 and PORTL 4 pins are at logic 1
    {
        motion_set(0x00);
     68a:	80 e0       	ldi	r24, 0x00	; 0
     68c:	0e 94 2f 03 	call	0x65e	; 0x65e <motion_set>
    }
     690:	08 95       	ret

00000692 <__vector_6>:

ISR(INT5_vect) {
     692:	1f 92       	push	r1
     694:	0f 92       	push	r0
     696:	0f b6       	in	r0, 0x3f	; 63
     698:	0f 92       	push	r0
     69a:	11 24       	eor	r1, r1
     69c:	8f 93       	push	r24
     69e:	9f 93       	push	r25
     6a0:	af 93       	push	r26
     6a2:	bf 93       	push	r27
    ShaftCountRight++; //increment right shaft position count
     6a4:	80 91 37 03 	lds	r24, 0x0337
     6a8:	90 91 38 03 	lds	r25, 0x0338
     6ac:	a0 91 39 03 	lds	r26, 0x0339
     6b0:	b0 91 3a 03 	lds	r27, 0x033A
     6b4:	01 96       	adiw	r24, 0x01	; 1
     6b6:	a1 1d       	adc	r26, r1
     6b8:	b1 1d       	adc	r27, r1
     6ba:	80 93 37 03 	sts	0x0337, r24
     6be:	90 93 38 03 	sts	0x0338, r25
     6c2:	a0 93 39 03 	sts	0x0339, r26
     6c6:	b0 93 3a 03 	sts	0x033A, r27
}
     6ca:	bf 91       	pop	r27
     6cc:	af 91       	pop	r26
     6ce:	9f 91       	pop	r25
     6d0:	8f 91       	pop	r24
     6d2:	0f 90       	pop	r0
     6d4:	0f be       	out	0x3f, r0	; 63
     6d6:	0f 90       	pop	r0
     6d8:	1f 90       	pop	r1
     6da:	18 95       	reti

000006dc <__vector_5>:

ISR(INT4_vect) {
     6dc:	1f 92       	push	r1
     6de:	0f 92       	push	r0
     6e0:	0f b6       	in	r0, 0x3f	; 63
     6e2:	0f 92       	push	r0
     6e4:	11 24       	eor	r1, r1
     6e6:	8f 93       	push	r24
     6e8:	9f 93       	push	r25
     6ea:	af 93       	push	r26
     6ec:	bf 93       	push	r27
    ShaftCountLeft++; //increment left shaft position count
     6ee:	80 91 3b 03 	lds	r24, 0x033B
     6f2:	90 91 3c 03 	lds	r25, 0x033C
     6f6:	a0 91 3d 03 	lds	r26, 0x033D
     6fa:	b0 91 3e 03 	lds	r27, 0x033E
     6fe:	01 96       	adiw	r24, 0x01	; 1
     700:	a1 1d       	adc	r26, r1
     702:	b1 1d       	adc	r27, r1
     704:	80 93 3b 03 	sts	0x033B, r24
     708:	90 93 3c 03 	sts	0x033C, r25
     70c:	a0 93 3d 03 	sts	0x033D, r26
     710:	b0 93 3e 03 	sts	0x033E, r27
}
     714:	bf 91       	pop	r27
     716:	af 91       	pop	r26
     718:	9f 91       	pop	r25
     71a:	8f 91       	pop	r24
     71c:	0f 90       	pop	r0
     71e:	0f be       	out	0x3f, r0	; 63
     720:	0f 90       	pop	r0
     722:	1f 90       	pop	r1
     724:	18 95       	reti

00000726 <angle_rotate>:

void angle_rotate(unsigned int Degrees) {
     726:	0f 93       	push	r16
     728:	1f 93       	push	r17
     72a:	cf 93       	push	r28
    float ReqdShaftCount = 0;
    unsigned long int ReqdShaftCountInt = 0;
    ReqdShaftCount = (float) Degrees / 4.090; // division by resolution to get shaft count
     72c:	bc 01       	movw	r22, r24
     72e:	80 e0       	ldi	r24, 0x00	; 0
     730:	90 e0       	ldi	r25, 0x00	; 0
     732:	0e 94 06 19 	call	0x320c	; 0x320c <__floatunsisf>
     736:	28 e4       	ldi	r18, 0x48	; 72
     738:	31 ee       	ldi	r19, 0xE1	; 225
     73a:	42 e8       	ldi	r20, 0x82	; 130
     73c:	50 e4       	ldi	r21, 0x40	; 64
     73e:	0e 94 6d 18 	call	0x30da	; 0x30da <__divsf3>
    ReqdShaftCountInt = (unsigned int) ReqdShaftCount;
     742:	0e 94 da 18 	call	0x31b4	; 0x31b4 <__fixunssfsi>
     746:	dc 01       	movw	r26, r24
     748:	cb 01       	movw	r24, r22
     74a:	a0 e0       	ldi	r26, 0x00	; 0
     74c:	b0 e0       	ldi	r27, 0x00	; 0
    ShaftCountRight = 0;
     74e:	10 92 37 03 	sts	0x0337, r1
     752:	10 92 38 03 	sts	0x0338, r1
     756:	10 92 39 03 	sts	0x0339, r1
     75a:	10 92 3a 03 	sts	0x033A, r1
    ShaftCountLeft = 0;
     75e:	10 92 3b 03 	sts	0x033B, r1
     762:	10 92 3c 03 	sts	0x033C, r1
     766:	10 92 3d 03 	sts	0x033D, r1
     76a:	10 92 3e 03 	sts	0x033E, r1
    while (1) {
        if ((ShaftCountRight >= ReqdShaftCountInt) | (ShaftCountLeft >= ReqdShaftCountInt))
     76e:	f1 e0       	ldi	r31, 0x01	; 1
     770:	c0 e0       	ldi	r28, 0x00	; 0
     772:	40 91 37 03 	lds	r20, 0x0337
     776:	50 91 38 03 	lds	r21, 0x0338
     77a:	60 91 39 03 	lds	r22, 0x0339
     77e:	70 91 3a 03 	lds	r23, 0x033A
     782:	00 91 3b 03 	lds	r16, 0x033B
     786:	10 91 3c 03 	lds	r17, 0x033C
     78a:	20 91 3d 03 	lds	r18, 0x033D
     78e:	30 91 3e 03 	lds	r19, 0x033E
     792:	ef 2f       	mov	r30, r31
     794:	48 17       	cp	r20, r24
     796:	59 07       	cpc	r21, r25
     798:	6a 07       	cpc	r22, r26
     79a:	7b 07       	cpc	r23, r27
     79c:	08 f4       	brcc	.+2      	; 0x7a0 <angle_rotate+0x7a>
     79e:	ec 2f       	mov	r30, r28
     7a0:	ee 23       	and	r30, r30
     7a2:	49 f4       	brne	.+18     	; 0x7b6 <angle_rotate+0x90>
     7a4:	4f 2f       	mov	r20, r31
     7a6:	08 17       	cp	r16, r24
     7a8:	19 07       	cpc	r17, r25
     7aa:	2a 07       	cpc	r18, r26
     7ac:	3b 07       	cpc	r19, r27
     7ae:	08 f4       	brcc	.+2      	; 0x7b2 <angle_rotate+0x8c>
     7b0:	4c 2f       	mov	r20, r28
     7b2:	44 23       	and	r20, r20
     7b4:	f1 f2       	breq	.-68     	; 0x772 <angle_rotate+0x4c>
            break;
    }
    stop(); //Stop robot
     7b6:	0e 94 45 03 	call	0x68a	; 0x68a <stop>
}
     7ba:	cf 91       	pop	r28
     7bc:	1f 91       	pop	r17
     7be:	0f 91       	pop	r16
     7c0:	08 95       	ret

000007c2 <linear_distance_mm>:

void linear_distance_mm(unsigned int DistanceInMM) {
    float ReqdShaftCount = 0;
    unsigned long int ReqdShaftCountInt = 0;
    ReqdShaftCount = DistanceInMM / 5.338; // division by resolution to get shaft count
     7c2:	bc 01       	movw	r22, r24
     7c4:	80 e0       	ldi	r24, 0x00	; 0
     7c6:	90 e0       	ldi	r25, 0x00	; 0
     7c8:	0e 94 06 19 	call	0x320c	; 0x320c <__floatunsisf>
     7cc:	25 ee       	ldi	r18, 0xE5	; 229
     7ce:	30 ed       	ldi	r19, 0xD0	; 208
     7d0:	4a ea       	ldi	r20, 0xAA	; 170
     7d2:	50 e4       	ldi	r21, 0x40	; 64
     7d4:	0e 94 6d 18 	call	0x30da	; 0x30da <__divsf3>
    ReqdShaftCountInt = (unsigned long int) ReqdShaftCount;
     7d8:	0e 94 da 18 	call	0x31b4	; 0x31b4 <__fixunssfsi>
     7dc:	46 2f       	mov	r20, r22
     7de:	57 2f       	mov	r21, r23
     7e0:	68 2f       	mov	r22, r24
     7e2:	79 2f       	mov	r23, r25
    ShaftCountRight = 0;
     7e4:	10 92 37 03 	sts	0x0337, r1
     7e8:	10 92 38 03 	sts	0x0338, r1
     7ec:	10 92 39 03 	sts	0x0339, r1
     7f0:	10 92 3a 03 	sts	0x033A, r1
    while (1) {
        if (ShaftCountRight > ReqdShaftCountInt) {
     7f4:	80 91 37 03 	lds	r24, 0x0337
     7f8:	90 91 38 03 	lds	r25, 0x0338
     7fc:	a0 91 39 03 	lds	r26, 0x0339
     800:	b0 91 3a 03 	lds	r27, 0x033A
     804:	48 17       	cp	r20, r24
     806:	59 07       	cpc	r21, r25
     808:	6a 07       	cpc	r22, r26
     80a:	7b 07       	cpc	r23, r27
     80c:	98 f7       	brcc	.-26     	; 0x7f4 <linear_distance_mm+0x32>
            break;
        }
    }
    stop(); //Stop robot
     80e:	0e 94 45 03 	call	0x68a	; 0x68a <stop>
}
     812:	08 95       	ret

00000814 <forward_mm>:

void forward_mm(unsigned int DistanceInMM) {
     814:	cf 93       	push	r28
     816:	df 93       	push	r29
     818:	ec 01       	movw	r28, r24
    forward();
     81a:	0e 94 35 03 	call	0x66a	; 0x66a <forward>
    linear_distance_mm(DistanceInMM);
     81e:	ce 01       	movw	r24, r28
     820:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <linear_distance_mm>
}
     824:	df 91       	pop	r29
     826:	cf 91       	pop	r28
     828:	08 95       	ret

0000082a <back_mm>:

void back_mm(unsigned int DistanceInMM) {
     82a:	cf 93       	push	r28
     82c:	df 93       	push	r29
     82e:	ec 01       	movw	r28, r24
    reverse();
     830:	0e 94 39 03 	call	0x672	; 0x672 <reverse>
    linear_distance_mm(DistanceInMM);
     834:	ce 01       	movw	r24, r28
     836:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <linear_distance_mm>
}
     83a:	df 91       	pop	r29
     83c:	cf 91       	pop	r28
     83e:	08 95       	ret

00000840 <left_degrees>:

void left_degrees(unsigned int Degrees) {
     840:	cf 93       	push	r28
     842:	df 93       	push	r29
     844:	ec 01       	movw	r28, r24
    // 88 pulses for 360 degrees rotation 4.090 degrees per count
    left(); //Turn left
     846:	0e 94 3d 03 	call	0x67a	; 0x67a <left>
    angle_rotate(Degrees);
     84a:	ce 01       	movw	r24, r28
     84c:	0e 94 93 03 	call	0x726	; 0x726 <angle_rotate>
}
     850:	df 91       	pop	r29
     852:	cf 91       	pop	r28
     854:	08 95       	ret

00000856 <right_degrees>:

void right_degrees(unsigned int Degrees) {
     856:	cf 93       	push	r28
     858:	df 93       	push	r29
     85a:	ec 01       	movw	r28, r24
    // 88 pulses for 360 degrees rotation 4.090 degrees per count
    right(); //Turn right
     85c:	0e 94 41 03 	call	0x682	; 0x682 <right>
    angle_rotate(Degrees);
     860:	ce 01       	movw	r24, r28
     862:	0e 94 93 03 	call	0x726	; 0x726 <angle_rotate>
}
     866:	df 91       	pop	r29
     868:	cf 91       	pop	r28
     86a:	08 95       	ret

0000086c <ADC_Conversion>:

unsigned char ADC_Conversion(unsigned char Ch) {
    unsigned char a;
    if (Ch > 7) {
     86c:	88 30       	cpi	r24, 0x08	; 8
     86e:	18 f0       	brcs	.+6      	; 0x876 <ADC_Conversion+0xa>
        ADCSRB = 0x08;
     870:	98 e0       	ldi	r25, 0x08	; 8
     872:	90 93 7b 00 	sts	0x007B, r25
    }
    Ch = Ch & 0x07;
     876:	87 70       	andi	r24, 0x07	; 7
    ADMUX = 0x20 | Ch;
     878:	80 62       	ori	r24, 0x20	; 32
     87a:	80 93 7c 00 	sts	0x007C, r24
    ADCSRA = ADCSRA | 0x40; //Set start conversion bit
     87e:	ea e7       	ldi	r30, 0x7A	; 122
     880:	f0 e0       	ldi	r31, 0x00	; 0
     882:	80 81       	ld	r24, Z
     884:	80 64       	ori	r24, 0x40	; 64
     886:	80 83       	st	Z, r24
    while ((ADCSRA & 0x10) == 0); //Wait for ADC conversion to complete
     888:	80 81       	ld	r24, Z
     88a:	84 ff       	sbrs	r24, 4
     88c:	fd cf       	rjmp	.-6      	; 0x888 <ADC_Conversion+0x1c>
    a = ADCH;
     88e:	80 91 79 00 	lds	r24, 0x0079
    ADCSRA = ADCSRA | 0x10; //clear ADIF (ADC Interrupt Flag) by writing 1 to it
     892:	ea e7       	ldi	r30, 0x7A	; 122
     894:	f0 e0       	ldi	r31, 0x00	; 0
     896:	90 81       	ld	r25, Z
     898:	90 61       	ori	r25, 0x10	; 16
     89a:	90 83       	st	Z, r25
    ADCSRB = 0x00;
     89c:	10 92 7b 00 	sts	0x007B, r1
    return a;
}
     8a0:	08 95       	ret

000008a2 <turn_on_ir_proxi_sensors>:

void turn_on_ir_proxi_sensors(void) //turn on IR Proximity sensors
    {
        PORTH = PORTH & 0xF7;
     8a2:	e2 e0       	ldi	r30, 0x02	; 2
     8a4:	f1 e0       	ldi	r31, 0x01	; 1
     8a6:	80 81       	ld	r24, Z
     8a8:	87 7f       	andi	r24, 0xF7	; 247
     8aa:	80 83       	st	Z, r24
    }
     8ac:	08 95       	ret

000008ae <turn_off_ir_proxi_sensors>:

void turn_off_ir_proxi_sensors(void) //turn off IR Proximity sensors
    {
        PORTH = PORTH | 0x08;
     8ae:	e2 e0       	ldi	r30, 0x02	; 2
     8b0:	f1 e0       	ldi	r31, 0x01	; 1
     8b2:	80 81       	ld	r24, Z
     8b4:	88 60       	ori	r24, 0x08	; 8
     8b6:	80 83       	st	Z, r24
    }
     8b8:	08 95       	ret

000008ba <adc_init>:

void adc_init() {
    ADCSRA = 0x00;
     8ba:	ea e7       	ldi	r30, 0x7A	; 122
     8bc:	f0 e0       	ldi	r31, 0x00	; 0
     8be:	10 82       	st	Z, r1
    ADCSRB = 0x00; //MUX5 = 0
     8c0:	10 92 7b 00 	sts	0x007B, r1
    ADMUX = 0x20; //Vref=5V external --- ADLAR=1 --- MUX4:0 = 0000
     8c4:	80 e2       	ldi	r24, 0x20	; 32
     8c6:	80 93 7c 00 	sts	0x007C, r24
    ACSR = 0x80;
     8ca:	80 e8       	ldi	r24, 0x80	; 128
     8cc:	80 bf       	out	0x30, r24	; 48
    ADCSRA = 0x86; //ADEN=1 --- ADIE=1 --- ADPS2:0 = 1 1 0
     8ce:	86 e8       	ldi	r24, 0x86	; 134
     8d0:	80 83       	st	Z, r24
}
     8d2:	08 95       	ret

000008d4 <lcd_init>:
     8d4:	86 e6       	ldi	r24, 0x66	; 102
     8d6:	9e e0       	ldi	r25, 0x0E	; 14
     8d8:	01 97       	sbiw	r24, 0x01	; 1
     8da:	f1 f7       	brne	.-4      	; 0x8d8 <lcd_init+0x4>
     8dc:	00 00       	nop

void lcd_init() {
    _delay_ms(1);
    lcd_wr_command(0x28); //4-bit mode and 5x8 dot character font
     8de:	88 e2       	ldi	r24, 0x28	; 40
     8e0:	0e 94 19 01 	call	0x232	; 0x232 <lcd_wr_command>
    lcd_wr_command(0x01); //Clear LCD display
     8e4:	81 e0       	ldi	r24, 0x01	; 1
     8e6:	0e 94 19 01 	call	0x232	; 0x232 <lcd_wr_command>
    lcd_wr_command(0x06); //Auto increment cursor position
     8ea:	86 e0       	ldi	r24, 0x06	; 6
     8ec:	0e 94 19 01 	call	0x232	; 0x232 <lcd_wr_command>
    lcd_wr_command(0x0E); //Turn on LCD and cursor
     8f0:	8e e0       	ldi	r24, 0x0E	; 14
     8f2:	0e 94 19 01 	call	0x232	; 0x232 <lcd_wr_command>
    lcd_wr_command(0x80); //Set cursor position
     8f6:	80 e8       	ldi	r24, 0x80	; 128
     8f8:	0e 94 19 01 	call	0x232	; 0x232 <lcd_wr_command>
}
     8fc:	08 95       	ret

000008fe <left_position_encoder_interrupt_init>:

void left_position_encoder_interrupt_init(void) //Interrupt 4 enable
    {
        cli(); //Clears the global interrupt
     8fe:	f8 94       	cli
        EICRB = EICRB | 0x02; // INT4 is set to trigger with falling edge
     900:	ea e6       	ldi	r30, 0x6A	; 106
     902:	f0 e0       	ldi	r31, 0x00	; 0
     904:	80 81       	ld	r24, Z
     906:	82 60       	ori	r24, 0x02	; 2
     908:	80 83       	st	Z, r24
        EIMSK = EIMSK | 0x10; // Enable Interrupt INT4 for left position encoder
     90a:	ec 9a       	sbi	0x1d, 4	; 29
        sei(); // Enables the global interrupt
     90c:	78 94       	sei
    }
     90e:	08 95       	ret

00000910 <right_position_encoder_interrupt_init>:

void right_position_encoder_interrupt_init(void) //Interrupt 5 enable
    {
        cli(); //Clears the global interrupt
     910:	f8 94       	cli
        EICRB = EICRB | 0x08; // INT5 is set to trigger with falling edge
     912:	ea e6       	ldi	r30, 0x6A	; 106
     914:	f0 e0       	ldi	r31, 0x00	; 0
     916:	80 81       	ld	r24, Z
     918:	88 60       	ori	r24, 0x08	; 8
     91a:	80 83       	st	Z, r24
        EIMSK = EIMSK | 0x20; // Enable Interrupt INT5 for right position encoder
     91c:	ed 9a       	sbi	0x1d, 5	; 29
        sei(); // Enables the global interrupt
     91e:	78 94       	sei
    }
     920:	08 95       	ret

00000922 <init_devices>:

void init_devices(void) {
    cli(); //Clears the global interrupts
     922:	f8 94       	cli
    port_init();
     924:	0e 94 8d 02 	call	0x51a	; 0x51a <port_init>
    adc_init();
     928:	0e 94 5d 04 	call	0x8ba	; 0x8ba <adc_init>
    timer1_init();
     92c:	0e 94 e4 02 	call	0x5c8	; 0x5c8 <timer1_init>
    timer5_init();
     930:	0e 94 07 03 	call	0x60e	; 0x60e <timer5_init>
    left_position_encoder_interrupt_init();
     934:	0e 94 7f 04 	call	0x8fe	; 0x8fe <left_position_encoder_interrupt_init>
    right_position_encoder_interrupt_init();
     938:	0e 94 88 04 	call	0x910	; 0x910 <right_position_encoder_interrupt_init>
    color_sensor_pin_interrupt_init();
     93c:	0e 94 2b 02 	call	0x456	; 0x456 <color_sensor_pin_interrupt_init>
    sei(); //Enables the global interrupts
     940:	78 94       	sei
}
     942:	08 95       	ret

00000944 <servo_1>:

void servo_1(unsigned char degrees) {
    float PositionPanServo = 0;
    PositionPanServo = ((float) degrees / 1.86) + 35.0;
    OCR1AH = 0x00;
     944:	10 92 89 00 	sts	0x0089, r1
    sei(); //Enables the global interrupts
}

void servo_1(unsigned char degrees) {
    float PositionPanServo = 0;
    PositionPanServo = ((float) degrees / 1.86) + 35.0;
     948:	68 2f       	mov	r22, r24
     94a:	70 e0       	ldi	r23, 0x00	; 0
     94c:	80 e0       	ldi	r24, 0x00	; 0
     94e:	90 e0       	ldi	r25, 0x00	; 0
     950:	0e 94 06 19 	call	0x320c	; 0x320c <__floatunsisf>
     954:	2b e7       	ldi	r18, 0x7B	; 123
     956:	34 e1       	ldi	r19, 0x14	; 20
     958:	4e ee       	ldi	r20, 0xEE	; 238
     95a:	5f e3       	ldi	r21, 0x3F	; 63
     95c:	0e 94 6d 18 	call	0x30da	; 0x30da <__divsf3>
     960:	20 e0       	ldi	r18, 0x00	; 0
     962:	30 e0       	ldi	r19, 0x00	; 0
     964:	4c e0       	ldi	r20, 0x0C	; 12
     966:	52 e4       	ldi	r21, 0x42	; 66
     968:	0e 94 09 18 	call	0x3012	; 0x3012 <__addsf3>
    OCR1AH = 0x00;
    OCR1AL = (unsigned char) PositionPanServo;
     96c:	0e 94 da 18 	call	0x31b4	; 0x31b4 <__fixunssfsi>
     970:	60 93 88 00 	sts	0x0088, r22
}
     974:	08 95       	ret

00000976 <servo_2>:

//Function to rotate Servo 2 by a specified angle in the multiples of 1.86 degrees
void servo_2(unsigned char degrees) {
    float PositionTiltServo = 0;
    PositionTiltServo = ((float) degrees / 1.86) + 35.0;
    OCR1BH = 0x00;
     976:	10 92 8b 00 	sts	0x008B, r1


//Function to rotate Servo 2 by a specified angle in the multiples of 1.86 degrees
void servo_2(unsigned char degrees) {
    float PositionTiltServo = 0;
    PositionTiltServo = ((float) degrees / 1.86) + 35.0;
     97a:	68 2f       	mov	r22, r24
     97c:	70 e0       	ldi	r23, 0x00	; 0
     97e:	80 e0       	ldi	r24, 0x00	; 0
     980:	90 e0       	ldi	r25, 0x00	; 0
     982:	0e 94 06 19 	call	0x320c	; 0x320c <__floatunsisf>
     986:	2b e7       	ldi	r18, 0x7B	; 123
     988:	34 e1       	ldi	r19, 0x14	; 20
     98a:	4e ee       	ldi	r20, 0xEE	; 238
     98c:	5f e3       	ldi	r21, 0x3F	; 63
     98e:	0e 94 6d 18 	call	0x30da	; 0x30da <__divsf3>
     992:	20 e0       	ldi	r18, 0x00	; 0
     994:	30 e0       	ldi	r19, 0x00	; 0
     996:	4c e0       	ldi	r20, 0x0C	; 12
     998:	52 e4       	ldi	r21, 0x42	; 66
     99a:	0e 94 09 18 	call	0x3012	; 0x3012 <__addsf3>
    OCR1BH = 0x00;
    OCR1BL = (unsigned char) PositionTiltServo;
     99e:	0e 94 da 18 	call	0x31b4	; 0x31b4 <__fixunssfsi>
     9a2:	60 93 8a 00 	sts	0x008A, r22
}
     9a6:	08 95       	ret

000009a8 <servo_3>:

//Function to rotate Servo 3 by a specified angle in the multiples of 1.86 degrees
void servo_3(unsigned char degrees) {
    float PositionServo = 0;
    PositionServo = ((float) degrees / 1.86) + 35.0;
    OCR1CH = 0x00;
     9a8:	10 92 8d 00 	sts	0x008D, r1
}

//Function to rotate Servo 3 by a specified angle in the multiples of 1.86 degrees
void servo_3(unsigned char degrees) {
    float PositionServo = 0;
    PositionServo = ((float) degrees / 1.86) + 35.0;
     9ac:	68 2f       	mov	r22, r24
     9ae:	70 e0       	ldi	r23, 0x00	; 0
     9b0:	80 e0       	ldi	r24, 0x00	; 0
     9b2:	90 e0       	ldi	r25, 0x00	; 0
     9b4:	0e 94 06 19 	call	0x320c	; 0x320c <__floatunsisf>
     9b8:	2b e7       	ldi	r18, 0x7B	; 123
     9ba:	34 e1       	ldi	r19, 0x14	; 20
     9bc:	4e ee       	ldi	r20, 0xEE	; 238
     9be:	5f e3       	ldi	r21, 0x3F	; 63
     9c0:	0e 94 6d 18 	call	0x30da	; 0x30da <__divsf3>
     9c4:	20 e0       	ldi	r18, 0x00	; 0
     9c6:	30 e0       	ldi	r19, 0x00	; 0
     9c8:	4c e0       	ldi	r20, 0x0C	; 12
     9ca:	52 e4       	ldi	r21, 0x42	; 66
     9cc:	0e 94 09 18 	call	0x3012	; 0x3012 <__addsf3>
    OCR1CH = 0x00;
    OCR1CL = (unsigned char) PositionServo;
     9d0:	0e 94 da 18 	call	0x31b4	; 0x31b4 <__fixunssfsi>
     9d4:	60 93 8c 00 	sts	0x008C, r22
}
     9d8:	08 95       	ret

000009da <drop>:
 * Output: void
 * Logic: Drop the package if it is the first package to be deposited in the zone
 *		  If it is the second package then move forward to avoid collisions with the previously placed block. 
 * Example Call: drop();
 */
void drop(int block_count) {
     9da:	0f 93       	push	r16
     9dc:	1f 93       	push	r17
     9de:	cf 93       	push	r28
     9e0:	df 93       	push	r29
     9e2:	8c 01       	movw	r16, r24
     9e4:	8f ef       	ldi	r24, 0xFF	; 255
     9e6:	9f e7       	ldi	r25, 0x7F	; 127
     9e8:	a6 e1       	ldi	r26, 0x16	; 22
     9ea:	81 50       	subi	r24, 0x01	; 1
     9ec:	90 40       	sbci	r25, 0x00	; 0
     9ee:	a0 40       	sbci	r26, 0x00	; 0
     9f0:	e1 f7       	brne	.-8      	; 0x9ea <drop+0x10>
     9f2:	00 c0       	rjmp	.+0      	; 0x9f4 <drop+0x1a>
     9f4:	00 00       	nop
    _delay_ms(500);
    int i;
    if ((current_position / 10 == 2) || (current_position / 10 == 3)) {
     9f6:	80 91 5c 03 	lds	r24, 0x035C
     9fa:	90 91 5d 03 	lds	r25, 0x035D
     9fe:	9c 01       	movw	r18, r24
     a00:	24 51       	subi	r18, 0x14	; 20
     a02:	30 40       	sbci	r19, 0x00	; 0
     a04:	24 31       	cpi	r18, 0x14	; 20
     a06:	31 05       	cpc	r19, r1
     a08:	20 f4       	brcc	.+8      	; 0xa12 <drop+0x38>
        servo_3(90);
     a0a:	8a e5       	ldi	r24, 0x5A	; 90
     a0c:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <servo_3>
     a10:	93 c0       	rjmp	.+294    	; 0xb38 <drop+0x15e>
    } else if (current_position >= 12 && current_position <= 18) {
     a12:	9c 01       	movw	r18, r24
     a14:	2c 50       	subi	r18, 0x0C	; 12
     a16:	30 40       	sbci	r19, 0x00	; 0
     a18:	27 30       	cpi	r18, 0x07	; 7
     a1a:	31 05       	cpc	r19, r1
     a1c:	08 f0       	brcs	.+2      	; 0xa20 <drop+0x46>
     a1e:	45 c0       	rjmp	.+138    	; 0xaaa <drop+0xd0>
        if ((arm_position == arm_left) && (orie == pointingwest)) {
     a20:	40 91 96 02 	lds	r20, 0x0296
     a24:	50 91 97 02 	lds	r21, 0x0297
     a28:	80 91 65 02 	lds	r24, 0x0265
     a2c:	90 91 66 02 	lds	r25, 0x0266
     a30:	48 17       	cp	r20, r24
     a32:	59 07       	cpc	r21, r25
     a34:	c1 f4       	brne	.+48     	; 0xa66 <drop+0x8c>
     a36:	20 91 48 03 	lds	r18, 0x0348
     a3a:	30 91 49 03 	lds	r19, 0x0349
     a3e:	80 91 8d 02 	lds	r24, 0x028D
     a42:	90 91 8e 02 	lds	r25, 0x028E
     a46:	28 17       	cp	r18, r24
     a48:	39 07       	cpc	r19, r25
     a4a:	69 f4       	brne	.+26     	; 0xa66 <drop+0x8c>
     a4c:	c4 eb       	ldi	r28, 0xB4	; 180

            for (i = 180; i >= 0; i--) {
                servo_3(i);
     a4e:	8c 2f       	mov	r24, r28
     a50:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <servo_3>
     a54:	af ef       	ldi	r26, 0xFF	; 255
     a56:	bf e8       	ldi	r27, 0x8F	; 143
     a58:	11 97       	sbiw	r26, 0x01	; 1
     a5a:	f1 f7       	brne	.-4      	; 0xa58 <drop+0x7e>
     a5c:	00 c0       	rjmp	.+0      	; 0xa5e <drop+0x84>
     a5e:	00 00       	nop
     a60:	c1 50       	subi	r28, 0x01	; 1
     a62:	a8 f7       	brcc	.-22     	; 0xa4e <drop+0x74>
     a64:	69 c0       	rjmp	.+210    	; 0xb38 <drop+0x15e>
                _delay_ms(10);
            }
        } else if ((arm_position == arm_right) && (orie == pointingeast)) {
     a66:	80 91 67 02 	lds	r24, 0x0267
     a6a:	90 91 68 02 	lds	r25, 0x0268
     a6e:	48 17       	cp	r20, r24
     a70:	59 07       	cpc	r21, r25
     a72:	09 f0       	breq	.+2      	; 0xa76 <drop+0x9c>
     a74:	61 c0       	rjmp	.+194    	; 0xb38 <drop+0x15e>
     a76:	20 91 48 03 	lds	r18, 0x0348
     a7a:	30 91 49 03 	lds	r19, 0x0349
     a7e:	80 91 91 02 	lds	r24, 0x0291
     a82:	90 91 92 02 	lds	r25, 0x0292
     a86:	28 17       	cp	r18, r24
     a88:	39 07       	cpc	r19, r25
     a8a:	09 f0       	breq	.+2      	; 0xa8e <drop+0xb4>
     a8c:	55 c0       	rjmp	.+170    	; 0xb38 <drop+0x15e>
     a8e:	c0 e0       	ldi	r28, 0x00	; 0
            for (i = 0; i <= 180; i++) {
                servo_3(i);
     a90:	8c 2f       	mov	r24, r28
     a92:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <servo_3>
     a96:	8f ef       	ldi	r24, 0xFF	; 255
     a98:	9f e8       	ldi	r25, 0x8F	; 143
     a9a:	01 97       	sbiw	r24, 0x01	; 1
     a9c:	f1 f7       	brne	.-4      	; 0xa9a <drop+0xc0>
     a9e:	00 c0       	rjmp	.+0      	; 0xaa0 <drop+0xc6>
     aa0:	00 00       	nop
     aa2:	cf 5f       	subi	r28, 0xFF	; 255
            for (i = 180; i >= 0; i--) {
                servo_3(i);
                _delay_ms(10);
            }
        } else if ((arm_position == arm_right) && (orie == pointingeast)) {
            for (i = 0; i <= 180; i++) {
     aa4:	c5 3b       	cpi	r28, 0xB5	; 181
     aa6:	a1 f7       	brne	.-24     	; 0xa90 <drop+0xb6>
     aa8:	47 c0       	rjmp	.+142    	; 0xb38 <drop+0x15e>
                servo_3(i);
                _delay_ms(10);
            }

        }
    } else if (current_position >= 42 && current_position <= 48) {
     aaa:	8a 97       	sbiw	r24, 0x2a	; 42
     aac:	87 30       	cpi	r24, 0x07	; 7
     aae:	91 05       	cpc	r25, r1
     ab0:	08 f0       	brcs	.+2      	; 0xab4 <drop+0xda>
     ab2:	42 c0       	rjmp	.+132    	; 0xb38 <drop+0x15e>
        if ((arm_position == arm_left) && (orie == pointingeast)) {
     ab4:	40 91 96 02 	lds	r20, 0x0296
     ab8:	50 91 97 02 	lds	r21, 0x0297
     abc:	80 91 65 02 	lds	r24, 0x0265
     ac0:	90 91 66 02 	lds	r25, 0x0266
     ac4:	48 17       	cp	r20, r24
     ac6:	59 07       	cpc	r21, r25
     ac8:	c1 f4       	brne	.+48     	; 0xafa <drop+0x120>
     aca:	20 91 48 03 	lds	r18, 0x0348
     ace:	30 91 49 03 	lds	r19, 0x0349
     ad2:	80 91 91 02 	lds	r24, 0x0291
     ad6:	90 91 92 02 	lds	r25, 0x0292
     ada:	28 17       	cp	r18, r24
     adc:	39 07       	cpc	r19, r25
     ade:	69 f4       	brne	.+26     	; 0xafa <drop+0x120>
     ae0:	c4 eb       	ldi	r28, 0xB4	; 180

            for (i = 180; i >= 0; i--) {
                servo_3(i);
     ae2:	8c 2f       	mov	r24, r28
     ae4:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <servo_3>
     ae8:	af ef       	ldi	r26, 0xFF	; 255
     aea:	bf e8       	ldi	r27, 0x8F	; 143
     aec:	11 97       	sbiw	r26, 0x01	; 1
     aee:	f1 f7       	brne	.-4      	; 0xaec <drop+0x112>
     af0:	00 c0       	rjmp	.+0      	; 0xaf2 <drop+0x118>
     af2:	00 00       	nop
     af4:	c1 50       	subi	r28, 0x01	; 1
     af6:	a8 f7       	brcc	.-22     	; 0xae2 <drop+0x108>
     af8:	1f c0       	rjmp	.+62     	; 0xb38 <drop+0x15e>
                _delay_ms(10);
            }
        } else if ((arm_position == arm_right) && (orie == pointingwest)) {
     afa:	80 91 67 02 	lds	r24, 0x0267
     afe:	90 91 68 02 	lds	r25, 0x0268
     b02:	48 17       	cp	r20, r24
     b04:	59 07       	cpc	r21, r25
     b06:	c1 f4       	brne	.+48     	; 0xb38 <drop+0x15e>
     b08:	20 91 48 03 	lds	r18, 0x0348
     b0c:	30 91 49 03 	lds	r19, 0x0349
     b10:	80 91 8d 02 	lds	r24, 0x028D
     b14:	90 91 8e 02 	lds	r25, 0x028E
     b18:	28 17       	cp	r18, r24
     b1a:	39 07       	cpc	r19, r25
     b1c:	69 f4       	brne	.+26     	; 0xb38 <drop+0x15e>
     b1e:	c5 eb       	ldi	r28, 0xB5	; 181
     b20:	d0 e0       	ldi	r29, 0x00	; 0
            for (i = 0; i <= 180; i++) {
                servo_3(180);
     b22:	84 eb       	ldi	r24, 0xB4	; 180
     b24:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <servo_3>
     b28:	8f ef       	ldi	r24, 0xFF	; 255
     b2a:	9f e8       	ldi	r25, 0x8F	; 143
     b2c:	01 97       	sbiw	r24, 0x01	; 1
     b2e:	f1 f7       	brne	.-4      	; 0xb2c <drop+0x152>
     b30:	00 c0       	rjmp	.+0      	; 0xb32 <drop+0x158>
     b32:	00 00       	nop
     b34:	21 97       	sbiw	r28, 0x01	; 1
            for (i = 180; i >= 0; i--) {
                servo_3(i);
                _delay_ms(10);
            }
        } else if ((arm_position == arm_right) && (orie == pointingwest)) {
            for (i = 0; i <= 180; i++) {
     b36:	a9 f7       	brne	.-22     	; 0xb22 <drop+0x148>
                _delay_ms(10);
            }

        }
    }
	if(block_count == 2)
     b38:	02 30       	cpi	r16, 0x02	; 2
     b3a:	11 05       	cpc	r17, r1
     b3c:	89 f4       	brne	.+34     	; 0xb60 <drop+0x186>
     b3e:	c8 e7       	ldi	r28, 0x78	; 120
    for (i = 120; i <= 180; i++) {
        servo_2(i);
     b40:	8c 2f       	mov	r24, r28
     b42:	0e 94 bb 04 	call	0x976	; 0x976 <servo_2>
     b46:	8f ef       	ldi	r24, 0xFF	; 255
     b48:	9f e1       	ldi	r25, 0x1F	; 31
     b4a:	a1 e0       	ldi	r26, 0x01	; 1
     b4c:	81 50       	subi	r24, 0x01	; 1
     b4e:	90 40       	sbci	r25, 0x00	; 0
     b50:	a0 40       	sbci	r26, 0x00	; 0
     b52:	e1 f7       	brne	.-8      	; 0xb4c <drop+0x172>
     b54:	00 c0       	rjmp	.+0      	; 0xb56 <drop+0x17c>
     b56:	00 00       	nop
     b58:	cf 5f       	subi	r28, 0xFF	; 255
            }

        }
    }
	if(block_count == 2)
    for (i = 120; i <= 180; i++) {
     b5a:	c5 3b       	cpi	r28, 0xB5	; 181
     b5c:	89 f7       	brne	.-30     	; 0xb40 <drop+0x166>
     b5e:	13 c0       	rjmp	.+38     	; 0xb86 <drop+0x1ac>
        servo_2(i);
        _delay_ms(25);
    }
	else if (block_count == 1){
     b60:	01 30       	cpi	r16, 0x01	; 1
     b62:	11 05       	cpc	r17, r1
     b64:	81 f4       	brne	.+32     	; 0xb86 <drop+0x1ac>
     b66:	c8 e7       	ldi	r28, 0x78	; 120
		for (i = 120; i <= 150; i++) {
			servo_2(i);
     b68:	8c 2f       	mov	r24, r28
     b6a:	0e 94 bb 04 	call	0x976	; 0x976 <servo_2>
     b6e:	8f ef       	ldi	r24, 0xFF	; 255
     b70:	9f e1       	ldi	r25, 0x1F	; 31
     b72:	a1 e0       	ldi	r26, 0x01	; 1
     b74:	81 50       	subi	r24, 0x01	; 1
     b76:	90 40       	sbci	r25, 0x00	; 0
     b78:	a0 40       	sbci	r26, 0x00	; 0
     b7a:	e1 f7       	brne	.-8      	; 0xb74 <drop+0x19a>
     b7c:	00 c0       	rjmp	.+0      	; 0xb7e <drop+0x1a4>
     b7e:	00 00       	nop
     b80:	cf 5f       	subi	r28, 0xFF	; 255
    for (i = 120; i <= 180; i++) {
        servo_2(i);
        _delay_ms(25);
    }
	else if (block_count == 1){
		for (i = 120; i <= 150; i++) {
     b82:	c7 39       	cpi	r28, 0x97	; 151
     b84:	89 f7       	brne	.-30     	; 0xb68 <drop+0x18e>
     b86:	8f ef       	ldi	r24, 0xFF	; 255
     b88:	9f e7       	ldi	r25, 0x7F	; 127
     b8a:	a6 e1       	ldi	r26, 0x16	; 22
     b8c:	81 50       	subi	r24, 0x01	; 1
     b8e:	90 40       	sbci	r25, 0x00	; 0
     b90:	a0 40       	sbci	r26, 0x00	; 0
     b92:	e1 f7       	brne	.-8      	; 0xb8c <drop+0x1b2>
     b94:	00 c0       	rjmp	.+0      	; 0xb96 <drop+0x1bc>
     b96:	00 00       	nop
     b98:	c2 e8       	ldi	r28, 0x82	; 130
     b9a:	8f ef       	ldi	r24, 0xFF	; 255
     b9c:	9f e1       	ldi	r25, 0x1F	; 31
     b9e:	a1 e0       	ldi	r26, 0x01	; 1
     ba0:	81 50       	subi	r24, 0x01	; 1
     ba2:	90 40       	sbci	r25, 0x00	; 0
     ba4:	a0 40       	sbci	r26, 0x00	; 0
     ba6:	e1 f7       	brne	.-8      	; 0xba0 <drop+0x1c6>
     ba8:	00 c0       	rjmp	.+0      	; 0xbaa <drop+0x1d0>
     baa:	00 00       	nop
	}

    _delay_ms(500);
    for (i = 130; i >= 77; i--) {
        _delay_ms(25);
        servo_1(i);
     bac:	8c 2f       	mov	r24, r28
     bae:	0e 94 a2 04 	call	0x944	; 0x944 <servo_1>
     bb2:	c1 50       	subi	r28, 0x01	; 1
			_delay_ms(25);
		}		
	}

    _delay_ms(500);
    for (i = 130; i >= 77; i--) {
     bb4:	cc 34       	cpi	r28, 0x4C	; 76
     bb6:	89 f7       	brne	.-30     	; 0xb9a <drop+0x1c0>
     bb8:	8f ef       	ldi	r24, 0xFF	; 255
     bba:	9f e7       	ldi	r25, 0x7F	; 127
     bbc:	a6 e1       	ldi	r26, 0x16	; 22
     bbe:	81 50       	subi	r24, 0x01	; 1
     bc0:	90 40       	sbci	r25, 0x00	; 0
     bc2:	a0 40       	sbci	r26, 0x00	; 0
     bc4:	e1 f7       	brne	.-8      	; 0xbbe <drop+0x1e4>
     bc6:	00 c0       	rjmp	.+0      	; 0xbc8 <drop+0x1ee>
     bc8:	00 00       	nop



    }
    _delay_ms(500);
	if(block_count == 2)
     bca:	02 30       	cpi	r16, 0x02	; 2
     bcc:	11 05       	cpc	r17, r1
     bce:	89 f4       	brne	.+34     	; 0xbf2 <drop+0x218>
     bd0:	c4 eb       	ldi	r28, 0xB4	; 180
     bd2:	8f ef       	ldi	r24, 0xFF	; 255
     bd4:	9f e1       	ldi	r25, 0x1F	; 31
     bd6:	a1 e0       	ldi	r26, 0x01	; 1
     bd8:	81 50       	subi	r24, 0x01	; 1
     bda:	90 40       	sbci	r25, 0x00	; 0
     bdc:	a0 40       	sbci	r26, 0x00	; 0
     bde:	e1 f7       	brne	.-8      	; 0xbd8 <drop+0x1fe>
     be0:	00 c0       	rjmp	.+0      	; 0xbe2 <drop+0x208>
     be2:	00 00       	nop
    for (i = 180; i >= 120; i--) {
        _delay_ms(25);
        servo_2(i);
     be4:	8c 2f       	mov	r24, r28
     be6:	0e 94 bb 04 	call	0x976	; 0x976 <servo_2>
     bea:	c1 50       	subi	r28, 0x01	; 1


    }
    _delay_ms(500);
	if(block_count == 2)
    for (i = 180; i >= 120; i--) {
     bec:	c7 37       	cpi	r28, 0x77	; 119
     bee:	89 f7       	brne	.-30     	; 0xbd2 <drop+0x1f8>
     bf0:	13 c0       	rjmp	.+38     	; 0xc18 <drop+0x23e>
        _delay_ms(25);
        servo_2(i);
    }
	else if (block_count == 1)
     bf2:	01 30       	cpi	r16, 0x01	; 1
     bf4:	11 05       	cpc	r17, r1
     bf6:	81 f4       	brne	.+32     	; 0xc18 <drop+0x23e>
     bf8:	c6 e9       	ldi	r28, 0x96	; 150
     bfa:	8f ef       	ldi	r24, 0xFF	; 255
     bfc:	9f e1       	ldi	r25, 0x1F	; 31
     bfe:	a1 e0       	ldi	r26, 0x01	; 1
     c00:	81 50       	subi	r24, 0x01	; 1
     c02:	90 40       	sbci	r25, 0x00	; 0
     c04:	a0 40       	sbci	r26, 0x00	; 0
     c06:	e1 f7       	brne	.-8      	; 0xc00 <drop+0x226>
     c08:	00 c0       	rjmp	.+0      	; 0xc0a <drop+0x230>
     c0a:	00 00       	nop
	for (i = 150; i >= 120; i--) {
		_delay_ms(25);
		servo_2(i);
     c0c:	8c 2f       	mov	r24, r28
     c0e:	0e 94 bb 04 	call	0x976	; 0x976 <servo_2>
     c12:	c1 50       	subi	r28, 0x01	; 1
    for (i = 180; i >= 120; i--) {
        _delay_ms(25);
        servo_2(i);
    }
	else if (block_count == 1)
	for (i = 150; i >= 120; i--) {
     c14:	c7 37       	cpi	r28, 0x77	; 119
     c16:	89 f7       	brne	.-30     	; 0xbfa <drop+0x220>
		_delay_ms(25);
		servo_2(i);
	}
}
     c18:	df 91       	pop	r29
     c1a:	cf 91       	pop	r28
     c1c:	1f 91       	pop	r17
     c1e:	0f 91       	pop	r16
     c20:	08 95       	ret

00000c22 <pick>:
 * Output: void
 * Logic: Adjust arm position according to co-ordinate and orientation of the bot
 *		  Pick up the package.
 * Example Call: pick();
 */
void pick() {
     c22:	cf 93       	push	r28
    int i;
    if ((current_position >= 12) && (current_position <= 18)) {
     c24:	80 91 5c 03 	lds	r24, 0x035C
     c28:	90 91 5d 03 	lds	r25, 0x035D
     c2c:	9c 01       	movw	r18, r24
     c2e:	2c 50       	subi	r18, 0x0C	; 12
     c30:	30 40       	sbci	r19, 0x00	; 0
     c32:	27 30       	cpi	r18, 0x07	; 7
     c34:	31 05       	cpc	r19, r1
     c36:	58 f5       	brcc	.+86     	; 0xc8e <pick+0x6c>
        if (orie == pointingeast) {
     c38:	80 91 48 03 	lds	r24, 0x0348
     c3c:	90 91 49 03 	lds	r25, 0x0349
     c40:	20 91 91 02 	lds	r18, 0x0291
     c44:	30 91 92 02 	lds	r19, 0x0292
     c48:	82 17       	cp	r24, r18
     c4a:	93 07       	cpc	r25, r19
     c4c:	61 f4       	brne	.+24     	; 0xc66 <pick+0x44>
            servo_3(0);
     c4e:	80 e0       	ldi	r24, 0x00	; 0
     c50:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <servo_3>
            arm_position = arm_right;
     c54:	80 91 67 02 	lds	r24, 0x0267
     c58:	90 91 68 02 	lds	r25, 0x0268
     c5c:	90 93 97 02 	sts	0x0297, r25
     c60:	80 93 96 02 	sts	0x0296, r24
     c64:	12 c0       	rjmp	.+36     	; 0xc8a <pick+0x68>
        } else if (orie == pointingwest) {
     c66:	20 91 8d 02 	lds	r18, 0x028D
     c6a:	30 91 8e 02 	lds	r19, 0x028E
     c6e:	82 17       	cp	r24, r18
     c70:	93 07       	cpc	r25, r19
     c72:	59 f4       	brne	.+22     	; 0xc8a <pick+0x68>
            servo_3(180);
     c74:	84 eb       	ldi	r24, 0xB4	; 180
     c76:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <servo_3>
            arm_position = arm_left;
     c7a:	80 91 65 02 	lds	r24, 0x0265
     c7e:	90 91 66 02 	lds	r25, 0x0266
     c82:	90 93 97 02 	sts	0x0297, r25
     c86:	80 93 96 02 	sts	0x0296, r24
 * Output: void
 * Logic: Adjust arm position according to co-ordinate and orientation of the bot
 *		  Pick up the package.
 * Example Call: pick();
 */
void pick() {
     c8a:	c8 e7       	ldi	r28, 0x78	; 120
     c8c:	2e c0       	rjmp	.+92     	; 0xcea <pick+0xc8>
            arm_position = arm_right;
        } else if (orie == pointingwest) {
            servo_3(180);
            arm_position = arm_left;
        }
    } else if ((current_position >= 42) && (current_position <= 48)) {
     c8e:	8a 97       	sbiw	r24, 0x2a	; 42
     c90:	87 30       	cpi	r24, 0x07	; 7
     c92:	91 05       	cpc	r25, r1
     c94:	d0 f7       	brcc	.-12     	; 0xc8a <pick+0x68>
        if (orie == pointingeast) {
     c96:	80 91 48 03 	lds	r24, 0x0348
     c9a:	90 91 49 03 	lds	r25, 0x0349
     c9e:	20 91 91 02 	lds	r18, 0x0291
     ca2:	30 91 92 02 	lds	r19, 0x0292
     ca6:	82 17       	cp	r24, r18
     ca8:	93 07       	cpc	r25, r19
     caa:	61 f4       	brne	.+24     	; 0xcc4 <pick+0xa2>
            servo_3(180);
     cac:	84 eb       	ldi	r24, 0xB4	; 180
     cae:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <servo_3>
            arm_position = arm_left;
     cb2:	80 91 65 02 	lds	r24, 0x0265
     cb6:	90 91 66 02 	lds	r25, 0x0266
     cba:	90 93 97 02 	sts	0x0297, r25
     cbe:	80 93 96 02 	sts	0x0296, r24
     cc2:	e3 cf       	rjmp	.-58     	; 0xc8a <pick+0x68>
        } else if (orie == pointingwest) {
     cc4:	20 91 8d 02 	lds	r18, 0x028D
     cc8:	30 91 8e 02 	lds	r19, 0x028E
     ccc:	82 17       	cp	r24, r18
     cce:	93 07       	cpc	r25, r19
     cd0:	e1 f6       	brne	.-72     	; 0xc8a <pick+0x68>
            servo_3(0);
     cd2:	80 e0       	ldi	r24, 0x00	; 0
     cd4:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <servo_3>
            arm_position = arm_right;
     cd8:	80 91 67 02 	lds	r24, 0x0267
     cdc:	90 91 68 02 	lds	r25, 0x0268
     ce0:	90 93 97 02 	sts	0x0297, r25
     ce4:	80 93 96 02 	sts	0x0296, r24
     ce8:	d0 cf       	rjmp	.-96     	; 0xc8a <pick+0x68>
        }
    }

    for (i = 120; i <= 180; i++) {
        servo_2(i);
     cea:	8c 2f       	mov	r24, r28
     cec:	0e 94 bb 04 	call	0x976	; 0x976 <servo_2>
     cf0:	8f ef       	ldi	r24, 0xFF	; 255
     cf2:	9f e1       	ldi	r25, 0x1F	; 31
     cf4:	a1 e0       	ldi	r26, 0x01	; 1
     cf6:	81 50       	subi	r24, 0x01	; 1
     cf8:	90 40       	sbci	r25, 0x00	; 0
     cfa:	a0 40       	sbci	r26, 0x00	; 0
     cfc:	e1 f7       	brne	.-8      	; 0xcf6 <pick+0xd4>
     cfe:	00 c0       	rjmp	.+0      	; 0xd00 <pick+0xde>
     d00:	00 00       	nop
     d02:	cf 5f       	subi	r28, 0xFF	; 255
            servo_3(0);
            arm_position = arm_right;
        }
    }

    for (i = 120; i <= 180; i++) {
     d04:	c5 3b       	cpi	r28, 0xB5	; 181
     d06:	89 f7       	brne	.-30     	; 0xcea <pick+0xc8>
     d08:	8f ef       	ldi	r24, 0xFF	; 255
     d0a:	9f e7       	ldi	r25, 0x7F	; 127
     d0c:	a6 e1       	ldi	r26, 0x16	; 22
     d0e:	81 50       	subi	r24, 0x01	; 1
     d10:	90 40       	sbci	r25, 0x00	; 0
     d12:	a0 40       	sbci	r26, 0x00	; 0
     d14:	e1 f7       	brne	.-8      	; 0xd0e <pick+0xec>
     d16:	00 c0       	rjmp	.+0      	; 0xd18 <pick+0xf6>
     d18:	00 00       	nop
     d1a:	cd e4       	ldi	r28, 0x4D	; 77
     d1c:	8f ef       	ldi	r24, 0xFF	; 255
     d1e:	9f e1       	ldi	r25, 0x1F	; 31
     d20:	a1 e0       	ldi	r26, 0x01	; 1
     d22:	81 50       	subi	r24, 0x01	; 1
     d24:	90 40       	sbci	r25, 0x00	; 0
     d26:	a0 40       	sbci	r26, 0x00	; 0
     d28:	e1 f7       	brne	.-8      	; 0xd22 <pick+0x100>
     d2a:	00 c0       	rjmp	.+0      	; 0xd2c <pick+0x10a>
     d2c:	00 00       	nop
        _delay_ms(25);
    }
    _delay_ms(500);
    for (i = 77; i <= 130; i++) {
        _delay_ms(25);
        servo_1(i);
     d2e:	8c 2f       	mov	r24, r28
     d30:	0e 94 a2 04 	call	0x944	; 0x944 <servo_1>
     d34:	cf 5f       	subi	r28, 0xFF	; 255
    for (i = 120; i <= 180; i++) {
        servo_2(i);
        _delay_ms(25);
    }
    _delay_ms(500);
    for (i = 77; i <= 130; i++) {
     d36:	c3 38       	cpi	r28, 0x83	; 131
     d38:	89 f7       	brne	.-30     	; 0xd1c <pick+0xfa>
     d3a:	8f ef       	ldi	r24, 0xFF	; 255
     d3c:	9f e7       	ldi	r25, 0x7F	; 127
     d3e:	a6 e1       	ldi	r26, 0x16	; 22
     d40:	81 50       	subi	r24, 0x01	; 1
     d42:	90 40       	sbci	r25, 0x00	; 0
     d44:	a0 40       	sbci	r26, 0x00	; 0
     d46:	e1 f7       	brne	.-8      	; 0xd40 <pick+0x11e>
     d48:	00 c0       	rjmp	.+0      	; 0xd4a <pick+0x128>
     d4a:	00 00       	nop
     d4c:	c4 eb       	ldi	r28, 0xB4	; 180
     d4e:	8f ef       	ldi	r24, 0xFF	; 255
     d50:	9f e1       	ldi	r25, 0x1F	; 31
     d52:	a1 e0       	ldi	r26, 0x01	; 1
     d54:	81 50       	subi	r24, 0x01	; 1
     d56:	90 40       	sbci	r25, 0x00	; 0
     d58:	a0 40       	sbci	r26, 0x00	; 0
     d5a:	e1 f7       	brne	.-8      	; 0xd54 <pick+0x132>
     d5c:	00 c0       	rjmp	.+0      	; 0xd5e <pick+0x13c>
     d5e:	00 00       	nop

    }
    _delay_ms(500);
    for (i = 180; i >= 120; i--) {
        _delay_ms(25);
        servo_2(i);
     d60:	8c 2f       	mov	r24, r28
     d62:	0e 94 bb 04 	call	0x976	; 0x976 <servo_2>
     d66:	c1 50       	subi	r28, 0x01	; 1
        _delay_ms(25);
        servo_1(i);

    }
    _delay_ms(500);
    for (i = 180; i >= 120; i--) {
     d68:	c7 37       	cpi	r28, 0x77	; 119
     d6a:	89 f7       	brne	.-30     	; 0xd4e <pick+0x12c>
        _delay_ms(25);
        servo_2(i);

    }
}
     d6c:	cf 91       	pop	r28
     d6e:	08 95       	ret

00000d70 <servo_1_free>:
//and make them free by giving 100% duty cycle at the PWM. This function can be used to
//reduce the power consumption of the motor if it is holding load against the gravity.

void servo_1_free(void) //makes servo 1 free rotating
    {
        OCR1AH = 0x03;
     d70:	83 e0       	ldi	r24, 0x03	; 3
     d72:	80 93 89 00 	sts	0x0089, r24
        OCR1AL = 0xFF; //Servo 1 off
     d76:	8f ef       	ldi	r24, 0xFF	; 255
     d78:	80 93 88 00 	sts	0x0088, r24
    }
     d7c:	08 95       	ret

00000d7e <servo_2_free>:

void servo_2_free(void) //makes servo 2 free rotating
    {
        OCR1BH = 0x03;
     d7e:	83 e0       	ldi	r24, 0x03	; 3
     d80:	80 93 8b 00 	sts	0x008B, r24
        OCR1BL = 0xFF; //Servo 2 off
     d84:	8f ef       	ldi	r24, 0xFF	; 255
     d86:	80 93 8a 00 	sts	0x008A, r24
    }
     d8a:	08 95       	ret

00000d8c <servo_3_free>:

void servo_3_free(void) //makes servo 3 free rotating
    {
        OCR1CH = 0x03;
     d8c:	83 e0       	ldi	r24, 0x03	; 3
     d8e:	80 93 8d 00 	sts	0x008D, r24
        OCR1CL = 0xFF; //Servo 3 off
     d92:	8f ef       	ldi	r24, 0xFF	; 255
     d94:	80 93 8c 00 	sts	0x008C, r24
    }
     d98:	08 95       	ret

00000d9a <filter_red>:
void filter_red(void) //Used to select red filter
    {
        //Filter Select - red filter
        PORTD = PORTD & 0xBF; //set S2 low
     d9a:	5e 98       	cbi	0x0b, 6	; 11
        PORTD = PORTD & 0x7F; //set S3 low
     d9c:	5f 98       	cbi	0x0b, 7	; 11
    }
     d9e:	08 95       	ret

00000da0 <filter_green>:

void filter_green(void) //Used to select green filter
    {
        //Filter Select - green filter
        PORTD = PORTD | 0x40; //set S2 High
     da0:	5e 9a       	sbi	0x0b, 6	; 11
        PORTD = PORTD | 0x80; //set S3 High
     da2:	5f 9a       	sbi	0x0b, 7	; 11
    }
     da4:	08 95       	ret

00000da6 <filter_blue>:

void filter_blue(void) //Used to select blue filter
    {
        //Filter Select - blue filter
        PORTD = PORTD & 0xBF; //set S2 low
     da6:	5e 98       	cbi	0x0b, 6	; 11
        PORTD = PORTD | 0x80; //set S3 High
     da8:	5f 9a       	sbi	0x0b, 7	; 11
    }
     daa:	08 95       	ret

00000dac <filter_clear>:

void filter_clear(void) //select no filter
    {
        //Filter Select - no filter
        PORTD = PORTD | 0x40; //set S2 High
     dac:	5e 9a       	sbi	0x0b, 6	; 11
        PORTD = PORTD & 0x7F; //set S3 Low
     dae:	5f 98       	cbi	0x0b, 7	; 11
    }
     db0:	08 95       	ret

00000db2 <color_sensor_scaling>:
//Color Sensing Scaling
void color_sensor_scaling() //This function is used to select the scaled down version of the original frequency of the output generated by the color sensor, generally 20% scaling is preferable, though you can change the values as per your application by referring datasheet
    {
        //Output Scaling 20% from datasheet
        //PORTD = PORTD & 0xEF;
        PORTD = PORTD | 0x10; //set S0 high
     db2:	5c 9a       	sbi	0x0b, 4	; 11
        //PORTD = PORTD & 0xDF; //set S1 low
        PORTD = PORTD | 0x20; //set S1 high
     db4:	5d 9a       	sbi	0x0b, 5	; 11
    }
     db6:	08 95       	ret

00000db8 <red_read>:

void red_read(void) // function to select red filter and display the count generated by the sensor on LCD. The count will be more if the color is red. The count will be very less if its blue or green.
    {
        //Red
        filter_red(); //select red filter
     db8:	0e 94 cd 06 	call	0xd9a	; 0xd9a <filter_red>
        pulse = 0; //reset the count to 0
     dbc:	10 92 33 03 	sts	0x0333, r1
     dc0:	10 92 34 03 	sts	0x0334, r1
     dc4:	10 92 35 03 	sts	0x0335, r1
     dc8:	10 92 36 03 	sts	0x0336, r1
     dcc:	8f ef       	ldi	r24, 0xFF	; 255
     dce:	9f e7       	ldi	r25, 0x7F	; 127
     dd0:	a4 e0       	ldi	r26, 0x04	; 4
     dd2:	81 50       	subi	r24, 0x01	; 1
     dd4:	90 40       	sbci	r25, 0x00	; 0
     dd6:	a0 40       	sbci	r26, 0x00	; 0
     dd8:	e1 f7       	brne	.-8      	; 0xdd2 <red_read+0x1a>
     dda:	00 c0       	rjmp	.+0      	; 0xddc <red_read+0x24>
     ddc:	00 00       	nop
        _delay_ms(100); //capture the pulses for 100 ms or 0.1 second
        red = pulse; //store the count in variable called red
     dde:	80 91 33 03 	lds	r24, 0x0333
     de2:	90 91 34 03 	lds	r25, 0x0334
     de6:	a0 91 35 03 	lds	r26, 0x0335
     dea:	b0 91 36 03 	lds	r27, 0x0336
     dee:	80 93 55 03 	sts	0x0355, r24
     df2:	90 93 56 03 	sts	0x0356, r25
     df6:	a0 93 57 03 	sts	0x0357, r26
     dfa:	b0 93 58 03 	sts	0x0358, r27
    }
     dfe:	08 95       	ret

00000e00 <green_read>:

void green_read(void) // function to select green filter and display the count generated by the sensor on LCD. The count will be more if the color is green. The count will be very less if its blue or red.
    {
        //Green
        filter_green(); //select green filter
     e00:	0e 94 d0 06 	call	0xda0	; 0xda0 <filter_green>
        pulse = 0; //reset the count to 0
     e04:	10 92 33 03 	sts	0x0333, r1
     e08:	10 92 34 03 	sts	0x0334, r1
     e0c:	10 92 35 03 	sts	0x0335, r1
     e10:	10 92 36 03 	sts	0x0336, r1
     e14:	8f ef       	ldi	r24, 0xFF	; 255
     e16:	9f e7       	ldi	r25, 0x7F	; 127
     e18:	a4 e0       	ldi	r26, 0x04	; 4
     e1a:	81 50       	subi	r24, 0x01	; 1
     e1c:	90 40       	sbci	r25, 0x00	; 0
     e1e:	a0 40       	sbci	r26, 0x00	; 0
     e20:	e1 f7       	brne	.-8      	; 0xe1a <green_read+0x1a>
     e22:	00 c0       	rjmp	.+0      	; 0xe24 <green_read+0x24>
     e24:	00 00       	nop
        _delay_ms(100); //capture the pulses for 100 ms or 0.1 second
        green = pulse; //store the count in variable called green
     e26:	80 91 33 03 	lds	r24, 0x0333
     e2a:	90 91 34 03 	lds	r25, 0x0334
     e2e:	a0 91 35 03 	lds	r26, 0x0335
     e32:	b0 91 36 03 	lds	r27, 0x0336
     e36:	80 93 4d 03 	sts	0x034D, r24
     e3a:	90 93 4e 03 	sts	0x034E, r25
     e3e:	a0 93 4f 03 	sts	0x034F, r26
     e42:	b0 93 50 03 	sts	0x0350, r27
    }
     e46:	08 95       	ret

00000e48 <blue_read>:

void blue_read(void) // function to select blue filter and display the count generated by the sensor on LCD. The count will be more if the color is blue. The count will be very less if its red or green.
    {
        //Blue
        filter_blue(); //select blue filter
     e48:	0e 94 d3 06 	call	0xda6	; 0xda6 <filter_blue>
        pulse = 0; //reset the count to 0
     e4c:	10 92 33 03 	sts	0x0333, r1
     e50:	10 92 34 03 	sts	0x0334, r1
     e54:	10 92 35 03 	sts	0x0335, r1
     e58:	10 92 36 03 	sts	0x0336, r1
     e5c:	8f ef       	ldi	r24, 0xFF	; 255
     e5e:	9f e7       	ldi	r25, 0x7F	; 127
     e60:	a4 e0       	ldi	r26, 0x04	; 4
     e62:	81 50       	subi	r24, 0x01	; 1
     e64:	90 40       	sbci	r25, 0x00	; 0
     e66:	a0 40       	sbci	r26, 0x00	; 0
     e68:	e1 f7       	brne	.-8      	; 0xe62 <blue_read+0x1a>
     e6a:	00 c0       	rjmp	.+0      	; 0xe6c <blue_read+0x24>
     e6c:	00 00       	nop
        _delay_ms(100); //capture the pulses for 100 ms or 0.1 second
        blue = pulse; //store the count in variable called blue
     e6e:	80 91 33 03 	lds	r24, 0x0333
     e72:	90 91 34 03 	lds	r25, 0x0334
     e76:	a0 91 35 03 	lds	r26, 0x0335
     e7a:	b0 91 36 03 	lds	r27, 0x0336
     e7e:	80 93 3f 03 	sts	0x033F, r24
     e82:	90 93 40 03 	sts	0x0340, r25
     e86:	a0 93 41 03 	sts	0x0341, r26
     e8a:	b0 93 42 03 	sts	0x0342, r27
    }
     e8e:	08 95       	ret

00000e90 <color_sense>:
 *		  Compare red,blue and green pulses to get find the color of the block i.e if less than black threshold then the package is invalid
 *		  else the greatest among the red, green or blue pulse is the color of the block.  
 * Example Call: int color_of_box = color_sense();
 *
*/
int color_sense(void) {
     e90:	cf 92       	push	r12
     e92:	df 92       	push	r13
     e94:	ef 92       	push	r14
     e96:	ff 92       	push	r15
     e98:	0f 93       	push	r16
     e9a:	1f 93       	push	r17
     e9c:	cf 93       	push	r28
     e9e:	df 93       	push	r29
     ea0:	00 d0       	rcall	.+0      	; 0xea2 <color_sense+0x12>
     ea2:	0f 92       	push	r0
     ea4:	cd b7       	in	r28, 0x3d	; 61
     ea6:	de b7       	in	r29, 0x3e	; 62
    color_sensor_scaling();
     ea8:	0e 94 d9 06 	call	0xdb2	; 0xdb2 <color_sensor_scaling>
    while (1) {
        sharp = ADC_Conversion(11); //Stores the Analog value of front sharp connected to ADC channel 11 into variable "sharp"
     eac:	8b e0       	ldi	r24, 0x0B	; 11
     eae:	0e 94 36 04 	call	0x86c	; 0x86c <ADC_Conversion>
     eb2:	80 93 62 03 	sts	0x0362, r24
        value = Sharp_GP2D12_estimation(sharp); //Stores Distance calculated in a variable "value".
     eb6:	0e 94 a4 02 	call	0x548	; 0x548 <Sharp_GP2D12_estimation>
     eba:	90 93 6a 03 	sts	0x036A, r25
     ebe:	80 93 69 03 	sts	0x0369, r24
        volatile unsigned long int pulse_value = 0;
     ec2:	19 82       	std	Y+1, r1	; 0x01
     ec4:	1a 82       	std	Y+2, r1	; 0x02
     ec6:	1b 82       	std	Y+3, r1	; 0x03
     ec8:	1c 82       	std	Y+4, r1	; 0x04
        red_read();
     eca:	0e 94 dc 06 	call	0xdb8	; 0xdb8 <red_read>
     ece:	8f ef       	ldi	r24, 0xFF	; 255
     ed0:	9f e7       	ldi	r25, 0x7F	; 127
     ed2:	a6 e1       	ldi	r26, 0x16	; 22
     ed4:	81 50       	subi	r24, 0x01	; 1
     ed6:	90 40       	sbci	r25, 0x00	; 0
     ed8:	a0 40       	sbci	r26, 0x00	; 0
     eda:	e1 f7       	brne	.-8      	; 0xed4 <color_sense+0x44>
     edc:	00 c0       	rjmp	.+0      	; 0xede <color_sense+0x4e>
     ede:	00 00       	nop
        _delay_ms(500);
        blue_read();
     ee0:	0e 94 24 07 	call	0xe48	; 0xe48 <blue_read>
     ee4:	8f ef       	ldi	r24, 0xFF	; 255
     ee6:	9f e7       	ldi	r25, 0x7F	; 127
     ee8:	a6 e1       	ldi	r26, 0x16	; 22
     eea:	81 50       	subi	r24, 0x01	; 1
     eec:	90 40       	sbci	r25, 0x00	; 0
     eee:	a0 40       	sbci	r26, 0x00	; 0
     ef0:	e1 f7       	brne	.-8      	; 0xeea <color_sense+0x5a>
     ef2:	00 c0       	rjmp	.+0      	; 0xef4 <color_sense+0x64>
     ef4:	00 00       	nop
        _delay_ms(500);
        green_read();
     ef6:	0e 94 00 07 	call	0xe00	; 0xe00 <green_read>
     efa:	8f ef       	ldi	r24, 0xFF	; 255
     efc:	9f e7       	ldi	r25, 0x7F	; 127
     efe:	a6 e1       	ldi	r26, 0x16	; 22
     f00:	81 50       	subi	r24, 0x01	; 1
     f02:	90 40       	sbci	r25, 0x00	; 0
     f04:	a0 40       	sbci	r26, 0x00	; 0
     f06:	e1 f7       	brne	.-8      	; 0xf00 <color_sense+0x70>
     f08:	00 c0       	rjmp	.+0      	; 0xf0a <color_sense+0x7a>
     f0a:	00 00       	nop
        _delay_ms(500);
 
        lcd_init();
     f0c:	0e 94 6a 04 	call	0x8d4	; 0x8d4 <lcd_init>
        lcd_print(2, 1, value, 5); //Print the count on second row
     f10:	40 91 69 03 	lds	r20, 0x0369
     f14:	50 91 6a 03 	lds	r21, 0x036A
     f18:	82 e0       	ldi	r24, 0x02	; 2
     f1a:	61 e0       	ldi	r22, 0x01	; 1
     f1c:	25 e0       	ldi	r18, 0x05	; 5
     f1e:	30 e0       	ldi	r19, 0x00	; 0
     f20:	0e 94 96 01 	call	0x32c	; 0x32c <lcd_print>
        if ((red <= 1700) && (blue <= 1700) && (green <= 1700) && (value > 0 && value <= 350)) {
     f24:	80 91 55 03 	lds	r24, 0x0355
     f28:	90 91 56 03 	lds	r25, 0x0356
     f2c:	a0 91 57 03 	lds	r26, 0x0357
     f30:	b0 91 58 03 	lds	r27, 0x0358
     f34:	85 3a       	cpi	r24, 0xA5	; 165
     f36:	e6 e0       	ldi	r30, 0x06	; 6
     f38:	9e 07       	cpc	r25, r30
     f3a:	e0 e0       	ldi	r30, 0x00	; 0
     f3c:	ae 07       	cpc	r26, r30
     f3e:	e0 e0       	ldi	r30, 0x00	; 0
     f40:	be 07       	cpc	r27, r30
     f42:	08 f0       	brcs	.+2      	; 0xf46 <color_sense+0xb6>
     f44:	4c c0       	rjmp	.+152    	; 0xfde <color_sense+0x14e>
     f46:	80 91 3f 03 	lds	r24, 0x033F
     f4a:	90 91 40 03 	lds	r25, 0x0340
     f4e:	a0 91 41 03 	lds	r26, 0x0341
     f52:	b0 91 42 03 	lds	r27, 0x0342
     f56:	85 3a       	cpi	r24, 0xA5	; 165
     f58:	f6 e0       	ldi	r31, 0x06	; 6
     f5a:	9f 07       	cpc	r25, r31
     f5c:	f0 e0       	ldi	r31, 0x00	; 0
     f5e:	af 07       	cpc	r26, r31
     f60:	f0 e0       	ldi	r31, 0x00	; 0
     f62:	bf 07       	cpc	r27, r31
     f64:	e0 f5       	brcc	.+120    	; 0xfde <color_sense+0x14e>
     f66:	80 91 4d 03 	lds	r24, 0x034D
     f6a:	90 91 4e 03 	lds	r25, 0x034E
     f6e:	a0 91 4f 03 	lds	r26, 0x034F
     f72:	b0 91 50 03 	lds	r27, 0x0350
     f76:	85 3a       	cpi	r24, 0xA5	; 165
     f78:	26 e0       	ldi	r18, 0x06	; 6
     f7a:	92 07       	cpc	r25, r18
     f7c:	20 e0       	ldi	r18, 0x00	; 0
     f7e:	a2 07       	cpc	r26, r18
     f80:	20 e0       	ldi	r18, 0x00	; 0
     f82:	b2 07       	cpc	r27, r18
     f84:	60 f5       	brcc	.+88     	; 0xfde <color_sense+0x14e>
     f86:	80 91 69 03 	lds	r24, 0x0369
     f8a:	90 91 6a 03 	lds	r25, 0x036A
     f8e:	01 97       	sbiw	r24, 0x01	; 1
     f90:	a1 e0       	ldi	r26, 0x01	; 1
     f92:	8e 35       	cpi	r24, 0x5E	; 94
     f94:	9a 07       	cpc	r25, r26
     f96:	18 f5       	brcc	.+70     	; 0xfde <color_sense+0x14e>
            lcd_cursor(1, 1); //set the cursor on row 1, column 1
     f98:	81 e0       	ldi	r24, 0x01	; 1
     f9a:	61 e0       	ldi	r22, 0x01	; 1
     f9c:	0e 94 76 01 	call	0x2ec	; 0x2ec <lcd_cursor>
            lcd_string("Black Pulses"); // Display "Black Pulses" on LCD
     fa0:	80 e0       	ldi	r24, 0x00	; 0
     fa2:	92 e0       	ldi	r25, 0x02	; 2
     fa4:	0e 94 67 01 	call	0x2ce	; 0x2ce <lcd_string>
            lcd_print(2, 1, value, 5); //Print the count on second row
     fa8:	40 91 69 03 	lds	r20, 0x0369
     fac:	50 91 6a 03 	lds	r21, 0x036A
     fb0:	82 e0       	ldi	r24, 0x02	; 2
     fb2:	61 e0       	ldi	r22, 0x01	; 1
     fb4:	25 e0       	ldi	r18, 0x05	; 5
     fb6:	30 e0       	ldi	r19, 0x00	; 0
     fb8:	0e 94 96 01 	call	0x32c	; 0x32c <lcd_print>
            buzzer_on();
     fbc:	0e 94 22 03 	call	0x644	; 0x644 <buzzer_on>
     fc0:	8f ef       	ldi	r24, 0xFF	; 255
     fc2:	9f ef       	ldi	r25, 0xFF	; 255
     fc4:	ac e2       	ldi	r26, 0x2C	; 44
     fc6:	81 50       	subi	r24, 0x01	; 1
     fc8:	90 40       	sbci	r25, 0x00	; 0
     fca:	a0 40       	sbci	r26, 0x00	; 0
     fcc:	e1 f7       	brne	.-8      	; 0xfc6 <color_sense+0x136>
     fce:	00 c0       	rjmp	.+0      	; 0xfd0 <color_sense+0x140>
     fd0:	00 00       	nop
            _delay_ms(1000); // Display for 1000ms or 1 second
            buzzer_off();
     fd2:	0e 94 26 03 	call	0x64c	; 0x64c <buzzer_off>
            lcd_wr_command(0x01);
     fd6:	81 e0       	ldi	r24, 0x01	; 1
     fd8:	0e 94 19 01 	call	0x232	; 0x232 <lcd_wr_command>
            return;
     fdc:	73 c1       	rjmp	.+742    	; 0x12c4 <color_sense+0x434>
            break;
        } else if ((red > blue) && (red > green) && (value > 0 && value <= 350)) {
     fde:	40 91 55 03 	lds	r20, 0x0355
     fe2:	50 91 56 03 	lds	r21, 0x0356
     fe6:	60 91 57 03 	lds	r22, 0x0357
     fea:	70 91 58 03 	lds	r23, 0x0358
     fee:	80 91 3f 03 	lds	r24, 0x033F
     ff2:	90 91 40 03 	lds	r25, 0x0340
     ff6:	a0 91 41 03 	lds	r26, 0x0341
     ffa:	b0 91 42 03 	lds	r27, 0x0342
     ffe:	84 17       	cp	r24, r20
    1000:	95 07       	cpc	r25, r21
    1002:	a6 07       	cpc	r26, r22
    1004:	b7 07       	cpc	r27, r23
    1006:	08 f0       	brcs	.+2      	; 0x100a <color_sense+0x17a>
    1008:	66 c0       	rjmp	.+204    	; 0x10d6 <color_sense+0x246>
    100a:	40 91 55 03 	lds	r20, 0x0355
    100e:	50 91 56 03 	lds	r21, 0x0356
    1012:	60 91 57 03 	lds	r22, 0x0357
    1016:	70 91 58 03 	lds	r23, 0x0358
    101a:	80 91 4d 03 	lds	r24, 0x034D
    101e:	90 91 4e 03 	lds	r25, 0x034E
    1022:	a0 91 4f 03 	lds	r26, 0x034F
    1026:	b0 91 50 03 	lds	r27, 0x0350
    102a:	84 17       	cp	r24, r20
    102c:	95 07       	cpc	r25, r21
    102e:	a6 07       	cpc	r26, r22
    1030:	b7 07       	cpc	r27, r23
    1032:	08 f0       	brcs	.+2      	; 0x1036 <color_sense+0x1a6>
    1034:	50 c0       	rjmp	.+160    	; 0x10d6 <color_sense+0x246>
    1036:	80 91 69 03 	lds	r24, 0x0369
    103a:	90 91 6a 03 	lds	r25, 0x036A
    103e:	01 97       	sbiw	r24, 0x01	; 1
    1040:	a1 e0       	ldi	r26, 0x01	; 1
    1042:	8e 35       	cpi	r24, 0x5E	; 94
    1044:	9a 07       	cpc	r25, r26
    1046:	08 f0       	brcs	.+2      	; 0x104a <color_sense+0x1ba>
    1048:	46 c0       	rjmp	.+140    	; 0x10d6 <color_sense+0x246>
            pulse_value = red;
    104a:	80 91 55 03 	lds	r24, 0x0355
    104e:	90 91 56 03 	lds	r25, 0x0356
    1052:	a0 91 57 03 	lds	r26, 0x0357
    1056:	b0 91 58 03 	lds	r27, 0x0358
    105a:	89 83       	std	Y+1, r24	; 0x01
    105c:	9a 83       	std	Y+2, r25	; 0x02
    105e:	ab 83       	std	Y+3, r26	; 0x03
    1060:	bc 83       	std	Y+4, r27	; 0x04
            PORTJ = 0xFB; //need to replace by led
    1062:	05 e0       	ldi	r16, 0x05	; 5
    1064:	11 e0       	ldi	r17, 0x01	; 1
    1066:	8b ef       	ldi	r24, 0xFB	; 251
    1068:	f8 01       	movw	r30, r16
    106a:	80 83       	st	Z, r24
            lcd_cursor(1, 1); //set the cursor on row 1, column 1
    106c:	81 e0       	ldi	r24, 0x01	; 1
    106e:	61 e0       	ldi	r22, 0x01	; 1
    1070:	0e 94 76 01 	call	0x2ec	; 0x2ec <lcd_cursor>
            lcd_string("Red Pulses"); // Display "Red Pulses" on LCD
    1074:	8d e0       	ldi	r24, 0x0D	; 13
    1076:	92 e0       	ldi	r25, 0x02	; 2
    1078:	0e 94 67 01 	call	0x2ce	; 0x2ce <lcd_string>
            lcd_print(2, 1, pulse_value, 5); //Print the count on second row111111
    107c:	c9 80       	ldd	r12, Y+1	; 0x01
    107e:	da 80       	ldd	r13, Y+2	; 0x02
    1080:	eb 80       	ldd	r14, Y+3	; 0x03
    1082:	fc 80       	ldd	r15, Y+4	; 0x04
    1084:	82 e0       	ldi	r24, 0x02	; 2
    1086:	61 e0       	ldi	r22, 0x01	; 1
    1088:	a6 01       	movw	r20, r12
    108a:	25 e0       	ldi	r18, 0x05	; 5
    108c:	30 e0       	ldi	r19, 0x00	; 0
    108e:	0e 94 96 01 	call	0x32c	; 0x32c <lcd_print>
    1092:	8f ef       	ldi	r24, 0xFF	; 255
    1094:	9f e7       	ldi	r25, 0x7F	; 127
    1096:	a6 e1       	ldi	r26, 0x16	; 22
    1098:	81 50       	subi	r24, 0x01	; 1
    109a:	90 40       	sbci	r25, 0x00	; 0
    109c:	a0 40       	sbci	r26, 0x00	; 0
    109e:	e1 f7       	brne	.-8      	; 0x1098 <color_sense+0x208>
    10a0:	00 c0       	rjmp	.+0      	; 0x10a2 <color_sense+0x212>
    10a2:	00 00       	nop
            _delay_ms(500); // Display for 1000ms or 1 second
            lcd_wr_command(0x01); //Clear the LCD	
    10a4:	81 e0       	ldi	r24, 0x01	; 1
    10a6:	0e 94 19 01 	call	0x232	; 0x232 <lcd_wr_command>
            PORTJ = 0x00;
    10aa:	d8 01       	movw	r26, r16
    10ac:	1c 92       	st	X, r1
            if (count_red_zone-- > 0)
    10ae:	80 91 31 03 	lds	r24, 0x0331
    10b2:	90 91 32 03 	lds	r25, 0x0332
    10b6:	9c 01       	movw	r18, r24
    10b8:	21 50       	subi	r18, 0x01	; 1
    10ba:	30 40       	sbci	r19, 0x00	; 0
    10bc:	30 93 32 03 	sts	0x0332, r19
    10c0:	20 93 31 03 	sts	0x0331, r18
    10c4:	18 16       	cp	r1, r24
    10c6:	19 06       	cpc	r1, r25
    10c8:	0c f0       	brlt	.+2      	; 0x10cc <color_sense+0x23c>
    10ca:	fc c0       	rjmp	.+504    	; 0x12c4 <color_sense+0x434>
                return red_color;
    10cc:	80 91 87 02 	lds	r24, 0x0287
    10d0:	90 91 88 02 	lds	r25, 0x0288
    10d4:	f7 c0       	rjmp	.+494    	; 0x12c4 <color_sense+0x434>
            else return;
            break;

        } else if ((blue > green) && (blue > red) && (value > 0 && value <= 350)) {
    10d6:	40 91 3f 03 	lds	r20, 0x033F
    10da:	50 91 40 03 	lds	r21, 0x0340
    10de:	60 91 41 03 	lds	r22, 0x0341
    10e2:	70 91 42 03 	lds	r23, 0x0342
    10e6:	80 91 4d 03 	lds	r24, 0x034D
    10ea:	90 91 4e 03 	lds	r25, 0x034E
    10ee:	a0 91 4f 03 	lds	r26, 0x034F
    10f2:	b0 91 50 03 	lds	r27, 0x0350
    10f6:	84 17       	cp	r24, r20
    10f8:	95 07       	cpc	r25, r21
    10fa:	a6 07       	cpc	r26, r22
    10fc:	b7 07       	cpc	r27, r23
    10fe:	08 f0       	brcs	.+2      	; 0x1102 <color_sense+0x272>
    1100:	66 c0       	rjmp	.+204    	; 0x11ce <color_sense+0x33e>
    1102:	40 91 3f 03 	lds	r20, 0x033F
    1106:	50 91 40 03 	lds	r21, 0x0340
    110a:	60 91 41 03 	lds	r22, 0x0341
    110e:	70 91 42 03 	lds	r23, 0x0342
    1112:	80 91 55 03 	lds	r24, 0x0355
    1116:	90 91 56 03 	lds	r25, 0x0356
    111a:	a0 91 57 03 	lds	r26, 0x0357
    111e:	b0 91 58 03 	lds	r27, 0x0358
    1122:	84 17       	cp	r24, r20
    1124:	95 07       	cpc	r25, r21
    1126:	a6 07       	cpc	r26, r22
    1128:	b7 07       	cpc	r27, r23
    112a:	08 f0       	brcs	.+2      	; 0x112e <color_sense+0x29e>
    112c:	50 c0       	rjmp	.+160    	; 0x11ce <color_sense+0x33e>
    112e:	80 91 69 03 	lds	r24, 0x0369
    1132:	90 91 6a 03 	lds	r25, 0x036A
    1136:	01 97       	sbiw	r24, 0x01	; 1
    1138:	b1 e0       	ldi	r27, 0x01	; 1
    113a:	8e 35       	cpi	r24, 0x5E	; 94
    113c:	9b 07       	cpc	r25, r27
    113e:	08 f0       	brcs	.+2      	; 0x1142 <color_sense+0x2b2>
    1140:	46 c0       	rjmp	.+140    	; 0x11ce <color_sense+0x33e>
            pulse_value = blue;
    1142:	80 91 3f 03 	lds	r24, 0x033F
    1146:	90 91 40 03 	lds	r25, 0x0340
    114a:	a0 91 41 03 	lds	r26, 0x0341
    114e:	b0 91 42 03 	lds	r27, 0x0342
    1152:	89 83       	std	Y+1, r24	; 0x01
    1154:	9a 83       	std	Y+2, r25	; 0x02
    1156:	ab 83       	std	Y+3, r26	; 0x03
    1158:	bc 83       	std	Y+4, r27	; 0x04
            PORTJ = 0xFE; //need to replace by led
    115a:	05 e0       	ldi	r16, 0x05	; 5
    115c:	11 e0       	ldi	r17, 0x01	; 1
    115e:	8e ef       	ldi	r24, 0xFE	; 254
    1160:	f8 01       	movw	r30, r16
    1162:	80 83       	st	Z, r24
            lcd_cursor(1, 1); //set the cursor on row 1, column 1
    1164:	81 e0       	ldi	r24, 0x01	; 1
    1166:	61 e0       	ldi	r22, 0x01	; 1
    1168:	0e 94 76 01 	call	0x2ec	; 0x2ec <lcd_cursor>
            lcd_string("Blue Pulses"); // Display "Blue Pulses" on LCD
    116c:	88 e1       	ldi	r24, 0x18	; 24
    116e:	92 e0       	ldi	r25, 0x02	; 2
    1170:	0e 94 67 01 	call	0x2ce	; 0x2ce <lcd_string>
            lcd_print(2, 1, pulse_value, 5); //Print the count on second row111111
    1174:	c9 80       	ldd	r12, Y+1	; 0x01
    1176:	da 80       	ldd	r13, Y+2	; 0x02
    1178:	eb 80       	ldd	r14, Y+3	; 0x03
    117a:	fc 80       	ldd	r15, Y+4	; 0x04
    117c:	82 e0       	ldi	r24, 0x02	; 2
    117e:	61 e0       	ldi	r22, 0x01	; 1
    1180:	a6 01       	movw	r20, r12
    1182:	25 e0       	ldi	r18, 0x05	; 5
    1184:	30 e0       	ldi	r19, 0x00	; 0
    1186:	0e 94 96 01 	call	0x32c	; 0x32c <lcd_print>
    118a:	8f ef       	ldi	r24, 0xFF	; 255
    118c:	9f e7       	ldi	r25, 0x7F	; 127
    118e:	a6 e1       	ldi	r26, 0x16	; 22
    1190:	81 50       	subi	r24, 0x01	; 1
    1192:	90 40       	sbci	r25, 0x00	; 0
    1194:	a0 40       	sbci	r26, 0x00	; 0
    1196:	e1 f7       	brne	.-8      	; 0x1190 <color_sense+0x300>
    1198:	00 c0       	rjmp	.+0      	; 0x119a <color_sense+0x30a>
    119a:	00 00       	nop
            _delay_ms(500); // Display for 1000ms or 1 second
            lcd_wr_command(0x01); //Clear the LCD
    119c:	81 e0       	ldi	r24, 0x01	; 1
    119e:	0e 94 19 01 	call	0x232	; 0x232 <lcd_wr_command>
            PORTJ = 0x00;
    11a2:	d8 01       	movw	r26, r16
    11a4:	1c 92       	st	X, r1
            if (count_blue_zone-- > 0)
    11a6:	80 91 2d 03 	lds	r24, 0x032D
    11aa:	90 91 2e 03 	lds	r25, 0x032E
    11ae:	9c 01       	movw	r18, r24
    11b0:	21 50       	subi	r18, 0x01	; 1
    11b2:	30 40       	sbci	r19, 0x00	; 0
    11b4:	30 93 2e 03 	sts	0x032E, r19
    11b8:	20 93 2d 03 	sts	0x032D, r18
    11bc:	18 16       	cp	r1, r24
    11be:	19 06       	cpc	r1, r25
    11c0:	0c f0       	brlt	.+2      	; 0x11c4 <color_sense+0x334>
    11c2:	80 c0       	rjmp	.+256    	; 0x12c4 <color_sense+0x434>
                return blue_color;
    11c4:	80 91 83 02 	lds	r24, 0x0283
    11c8:	90 91 84 02 	lds	r25, 0x0284
    11cc:	7b c0       	rjmp	.+246    	; 0x12c4 <color_sense+0x434>
            else return;
            break;

        } else if ((green > red) && (green > blue) && (value > 0 && value <= 350)) {
    11ce:	40 91 4d 03 	lds	r20, 0x034D
    11d2:	50 91 4e 03 	lds	r21, 0x034E
    11d6:	60 91 4f 03 	lds	r22, 0x034F
    11da:	70 91 50 03 	lds	r23, 0x0350
    11de:	80 91 55 03 	lds	r24, 0x0355
    11e2:	90 91 56 03 	lds	r25, 0x0356
    11e6:	a0 91 57 03 	lds	r26, 0x0357
    11ea:	b0 91 58 03 	lds	r27, 0x0358
    11ee:	84 17       	cp	r24, r20
    11f0:	95 07       	cpc	r25, r21
    11f2:	a6 07       	cpc	r26, r22
    11f4:	b7 07       	cpc	r27, r23
    11f6:	08 f0       	brcs	.+2      	; 0x11fa <color_sense+0x36a>
    11f8:	65 c0       	rjmp	.+202    	; 0x12c4 <color_sense+0x434>
    11fa:	40 91 4d 03 	lds	r20, 0x034D
    11fe:	50 91 4e 03 	lds	r21, 0x034E
    1202:	60 91 4f 03 	lds	r22, 0x034F
    1206:	70 91 50 03 	lds	r23, 0x0350
    120a:	80 91 3f 03 	lds	r24, 0x033F
    120e:	90 91 40 03 	lds	r25, 0x0340
    1212:	a0 91 41 03 	lds	r26, 0x0341
    1216:	b0 91 42 03 	lds	r27, 0x0342
    121a:	84 17       	cp	r24, r20
    121c:	95 07       	cpc	r25, r21
    121e:	a6 07       	cpc	r26, r22
    1220:	b7 07       	cpc	r27, r23
    1222:	08 f0       	brcs	.+2      	; 0x1226 <color_sense+0x396>
    1224:	4f c0       	rjmp	.+158    	; 0x12c4 <color_sense+0x434>
    1226:	80 91 69 03 	lds	r24, 0x0369
    122a:	90 91 6a 03 	lds	r25, 0x036A
    122e:	01 97       	sbiw	r24, 0x01	; 1
    1230:	b1 e0       	ldi	r27, 0x01	; 1
    1232:	8e 35       	cpi	r24, 0x5E	; 94
    1234:	9b 07       	cpc	r25, r27
    1236:	08 f0       	brcs	.+2      	; 0x123a <color_sense+0x3aa>
    1238:	45 c0       	rjmp	.+138    	; 0x12c4 <color_sense+0x434>
            pulse_value = green;
    123a:	80 91 4d 03 	lds	r24, 0x034D
    123e:	90 91 4e 03 	lds	r25, 0x034E
    1242:	a0 91 4f 03 	lds	r26, 0x034F
    1246:	b0 91 50 03 	lds	r27, 0x0350
    124a:	89 83       	std	Y+1, r24	; 0x01
    124c:	9a 83       	std	Y+2, r25	; 0x02
    124e:	ab 83       	std	Y+3, r26	; 0x03
    1250:	bc 83       	std	Y+4, r27	; 0x04
            PORTJ = 0xEF; //need to replace by led
    1252:	05 e0       	ldi	r16, 0x05	; 5
    1254:	11 e0       	ldi	r17, 0x01	; 1
    1256:	8f ee       	ldi	r24, 0xEF	; 239
    1258:	f8 01       	movw	r30, r16
    125a:	80 83       	st	Z, r24
            lcd_cursor(1, 1); //set the cursor on row 1, column 1
    125c:	81 e0       	ldi	r24, 0x01	; 1
    125e:	61 e0       	ldi	r22, 0x01	; 1
    1260:	0e 94 76 01 	call	0x2ec	; 0x2ec <lcd_cursor>
            lcd_string("Green Pulses"); // Display "Green Pulses" on LCD
    1264:	84 e2       	ldi	r24, 0x24	; 36
    1266:	92 e0       	ldi	r25, 0x02	; 2
    1268:	0e 94 67 01 	call	0x2ce	; 0x2ce <lcd_string>
            lcd_print(2, 1, pulse_value, 5); //Print the count on second row111111
    126c:	c9 80       	ldd	r12, Y+1	; 0x01
    126e:	da 80       	ldd	r13, Y+2	; 0x02
    1270:	eb 80       	ldd	r14, Y+3	; 0x03
    1272:	fc 80       	ldd	r15, Y+4	; 0x04
    1274:	82 e0       	ldi	r24, 0x02	; 2
    1276:	61 e0       	ldi	r22, 0x01	; 1
    1278:	a6 01       	movw	r20, r12
    127a:	25 e0       	ldi	r18, 0x05	; 5
    127c:	30 e0       	ldi	r19, 0x00	; 0
    127e:	0e 94 96 01 	call	0x32c	; 0x32c <lcd_print>
    1282:	8f ef       	ldi	r24, 0xFF	; 255
    1284:	9f e7       	ldi	r25, 0x7F	; 127
    1286:	a6 e1       	ldi	r26, 0x16	; 22
    1288:	81 50       	subi	r24, 0x01	; 1
    128a:	90 40       	sbci	r25, 0x00	; 0
    128c:	a0 40       	sbci	r26, 0x00	; 0
    128e:	e1 f7       	brne	.-8      	; 0x1288 <color_sense+0x3f8>
    1290:	00 c0       	rjmp	.+0      	; 0x1292 <color_sense+0x402>
    1292:	00 00       	nop
            _delay_ms(500); // Display for 1000ms or 1 second
            lcd_wr_command(0x01); //Clear the LCD
    1294:	81 e0       	ldi	r24, 0x01	; 1
    1296:	0e 94 19 01 	call	0x232	; 0x232 <lcd_wr_command>
            PORTJ = 0x00;
    129a:	d8 01       	movw	r26, r16
    129c:	1c 92       	st	X, r1
            if (count_green_zone-- > 0)
    129e:	80 91 2f 03 	lds	r24, 0x032F
    12a2:	90 91 30 03 	lds	r25, 0x0330
    12a6:	9c 01       	movw	r18, r24
    12a8:	21 50       	subi	r18, 0x01	; 1
    12aa:	30 40       	sbci	r19, 0x00	; 0
    12ac:	30 93 30 03 	sts	0x0330, r19
    12b0:	20 93 2f 03 	sts	0x032F, r18
    12b4:	18 16       	cp	r1, r24
    12b6:	19 06       	cpc	r1, r25
    12b8:	2c f4       	brge	.+10     	; 0x12c4 <color_sense+0x434>
                return green_color;
    12ba:	80 91 85 02 	lds	r24, 0x0285
    12be:	90 91 86 02 	lds	r25, 0x0286
    12c2:	00 c0       	rjmp	.+0      	; 0x12c4 <color_sense+0x434>
            else return;
            break;
        } else return;
    }
}
    12c4:	0f 90       	pop	r0
    12c6:	0f 90       	pop	r0
    12c8:	0f 90       	pop	r0
    12ca:	0f 90       	pop	r0
    12cc:	df 91       	pop	r29
    12ce:	cf 91       	pop	r28
    12d0:	1f 91       	pop	r17
    12d2:	0f 91       	pop	r16
    12d4:	ff 90       	pop	r15
    12d6:	ef 90       	pop	r14
    12d8:	df 90       	pop	r13
    12da:	cf 90       	pop	r12
    12dc:	08 95       	ret

000012de <follow>:
 * Example Call: follow();
 *
*/


void follow() {
    12de:	4f 92       	push	r4
    12e0:	5f 92       	push	r5
    12e2:	6f 92       	push	r6
    12e4:	7f 92       	push	r7
    12e6:	8f 92       	push	r8
    12e8:	9f 92       	push	r9
    12ea:	af 92       	push	r10
    12ec:	bf 92       	push	r11
    12ee:	cf 92       	push	r12
    12f0:	df 92       	push	r13
    12f2:	ef 92       	push	r14
    12f4:	ff 92       	push	r15
    12f6:	0f 93       	push	r16
    12f8:	1f 93       	push	r17
    12fa:	cf 93       	push	r28
    12fc:	df 93       	push	r29

    unsigned char black_threshold = 80;
    int lastproportional = 0, integral = 0;
    12fe:	aa 24       	eor	r10, r10
    1300:	bb 24       	eor	r11, r11
    1302:	c0 e0       	ldi	r28, 0x00	; 0
    1304:	d0 e0       	ldi	r29, 0x00	; 0
                forward_mm(10);
            stop();
            break;
        } else {
            has_turned = 0;
            int position = (((right_sensor * 2) + center_sensor) * 250) / sum;
    1306:	0f 2e       	mov	r0, r31
    1308:	fa ef       	ldi	r31, 0xFA	; 250
    130a:	6f 2e       	mov	r6, r31
    130c:	77 24       	eor	r7, r7
    130e:	f0 2d       	mov	r31, r0
            int set_point = 250;
            int proportional = position - set_point;
            integral += proportional;
            int derivative = proportional - lastproportional;
            lastproportional = proportional;
            error = (proportional * kp + integral * ki + derivative * kd);
    1310:	0f 2e       	mov	r0, r31
    1312:	f1 e0       	ldi	r31, 0x01	; 1
    1314:	4f 2e       	mov	r4, r31
    1316:	ff ef       	ldi	r31, 0xFF	; 255
    1318:	5f 2e       	mov	r5, r31
    131a:	f0 2d       	mov	r31, r0
    131c:	0f 2e       	mov	r0, r31
    131e:	ff ef       	ldi	r31, 0xFF	; 255
    1320:	8f 2e       	mov	r8, r31
    1322:	99 24       	eor	r9, r9
    1324:	f0 2d       	mov	r31, r0
    unsigned char black_threshold = 80;
    int lastproportional = 0, integral = 0;
    int error = 0;
    float kp = 1.8, ki = 0, kd = 4.75;
    while (1) {
        center_sensor = ADC_Conversion(2);
    1326:	82 e0       	ldi	r24, 0x02	; 2
    1328:	0e 94 36 04 	call	0x86c	; 0x86c <ADC_Conversion>
    132c:	80 93 2c 03 	sts	0x032C, r24
        left_sensor = ADC_Conversion(3);
    1330:	83 e0       	ldi	r24, 0x03	; 3
    1332:	0e 94 36 04 	call	0x86c	; 0x86c <ADC_Conversion>
    1336:	80 93 2b 03 	sts	0x032B, r24
        right_sensor = ADC_Conversion(1);
    133a:	81 e0       	ldi	r24, 0x01	; 1
    133c:	0e 94 36 04 	call	0x86c	; 0x86c <ADC_Conversion>
    1340:	80 93 2a 03 	sts	0x032A, r24
        lcd_print(1, 1, left_sensor, 3);
    1344:	40 91 2b 03 	lds	r20, 0x032B
    1348:	81 e0       	ldi	r24, 0x01	; 1
    134a:	61 e0       	ldi	r22, 0x01	; 1
    134c:	50 e0       	ldi	r21, 0x00	; 0
    134e:	23 e0       	ldi	r18, 0x03	; 3
    1350:	30 e0       	ldi	r19, 0x00	; 0
    1352:	0e 94 96 01 	call	0x32c	; 0x32c <lcd_print>
        lcd_print(1, 5, center_sensor, 3);
    1356:	40 91 2c 03 	lds	r20, 0x032C
    135a:	81 e0       	ldi	r24, 0x01	; 1
    135c:	65 e0       	ldi	r22, 0x05	; 5
    135e:	50 e0       	ldi	r21, 0x00	; 0
    1360:	23 e0       	ldi	r18, 0x03	; 3
    1362:	30 e0       	ldi	r19, 0x00	; 0
    1364:	0e 94 96 01 	call	0x32c	; 0x32c <lcd_print>
        lcd_print(1, 9, right_sensor, 3);
    1368:	40 91 2a 03 	lds	r20, 0x032A
    136c:	81 e0       	ldi	r24, 0x01	; 1
    136e:	69 e0       	ldi	r22, 0x09	; 9
    1370:	50 e0       	ldi	r21, 0x00	; 0
    1372:	23 e0       	ldi	r18, 0x03	; 3
    1374:	30 e0       	ldi	r19, 0x00	; 0
    1376:	0e 94 96 01 	call	0x32c	; 0x32c <lcd_print>
        int sum = (center_sensor + left_sensor + right_sensor);
    137a:	40 91 2c 03 	lds	r20, 0x032C
    137e:	50 e0       	ldi	r21, 0x00	; 0
    1380:	20 91 2a 03 	lds	r18, 0x032A
    1384:	30 e0       	ldi	r19, 0x00	; 0
    1386:	80 91 2b 03 	lds	r24, 0x032B
    138a:	ba 01       	movw	r22, r20
    138c:	68 0f       	add	r22, r24
    138e:	71 1d       	adc	r23, r1
    1390:	62 0f       	add	r22, r18
    1392:	73 1f       	adc	r23, r19
        if (sum >= black_threshold) {
    1394:	60 35       	cpi	r22, 0x50	; 80
    1396:	71 05       	cpc	r23, r1
    1398:	dc f1       	brlt	.+118    	; 0x1410 <follow+0x132>
            stop();
    139a:	0e 94 45 03 	call	0x68a	; 0x68a <stop>
            buzzer_on();
    139e:	0e 94 22 03 	call	0x644	; 0x644 <buzzer_on>
    13a2:	8f ef       	ldi	r24, 0xFF	; 255
    13a4:	9f e8       	ldi	r25, 0x8F	; 143
    13a6:	01 97       	sbiw	r24, 0x01	; 1
    13a8:	f1 f7       	brne	.-4      	; 0x13a6 <follow+0xc8>
    13aa:	00 c0       	rjmp	.+0      	; 0x13ac <follow+0xce>
    13ac:	00 00       	nop
            _delay_ms(10);
            buzzer_off();
    13ae:	0e 94 26 03 	call	0x64c	; 0x64c <buzzer_off>
            has_turned = 0;
    13b2:	10 92 29 03 	sts	0x0329, r1
    13b6:	10 92 28 03 	sts	0x0328, r1
            forward();
    13ba:	0e 94 35 03 	call	0x66a	; 0x66a <forward>
            velocity(252, 255);
    13be:	8c ef       	ldi	r24, 0xFC	; 252
    13c0:	6f ef       	ldi	r22, 0xFF	; 255
    13c2:	0e 94 2a 03 	call	0x654	; 0x654 <velocity>
            if (flag == 1)
    13c6:	80 91 69 02 	lds	r24, 0x0269
    13ca:	90 91 6a 02 	lds	r25, 0x026A
    13ce:	81 30       	cpi	r24, 0x01	; 1
    13d0:	91 05       	cpc	r25, r1
    13d2:	29 f4       	brne	.+10     	; 0x13de <follow+0x100>
                forward_mm(35);
    13d4:	83 e2       	ldi	r24, 0x23	; 35
    13d6:	90 e0       	ldi	r25, 0x00	; 0
    13d8:	0e 94 0a 04 	call	0x814	; 0x814 <forward_mm>
    13dc:	06 c0       	rjmp	.+12     	; 0x13ea <follow+0x10c>
            else if (flag == 0)
    13de:	00 97       	sbiw	r24, 0x00	; 0
    13e0:	21 f4       	brne	.+8      	; 0x13ea <follow+0x10c>
                forward_mm(10);
    13e2:	8a e0       	ldi	r24, 0x0A	; 10
    13e4:	90 e0       	ldi	r25, 0x00	; 0
    13e6:	0e 94 0a 04 	call	0x814	; 0x814 <forward_mm>
            stop();
    13ea:	0e 94 45 03 	call	0x68a	; 0x68a <stop>
            }
            forward();
            velocity(right_speed, left_speed);
        }
    }
}
    13ee:	df 91       	pop	r29
    13f0:	cf 91       	pop	r28
    13f2:	1f 91       	pop	r17
    13f4:	0f 91       	pop	r16
    13f6:	ff 90       	pop	r15
    13f8:	ef 90       	pop	r14
    13fa:	df 90       	pop	r13
    13fc:	cf 90       	pop	r12
    13fe:	bf 90       	pop	r11
    1400:	af 90       	pop	r10
    1402:	9f 90       	pop	r9
    1404:	8f 90       	pop	r8
    1406:	7f 90       	pop	r7
    1408:	6f 90       	pop	r6
    140a:	5f 90       	pop	r5
    140c:	4f 90       	pop	r4
    140e:	08 95       	ret
            else if (flag == 0)
                forward_mm(10);
            stop();
            break;
        } else {
            has_turned = 0;
    1410:	10 92 29 03 	sts	0x0329, r1
    1414:	10 92 28 03 	sts	0x0328, r1
            int position = (((right_sensor * 2) + center_sensor) * 250) / sum;
    1418:	c9 01       	movw	r24, r18
    141a:	88 0f       	add	r24, r24
    141c:	99 1f       	adc	r25, r25
    141e:	9a 01       	movw	r18, r20
    1420:	28 0f       	add	r18, r24
    1422:	39 1f       	adc	r19, r25
    1424:	26 9d       	mul	r18, r6
    1426:	c0 01       	movw	r24, r0
    1428:	27 9d       	mul	r18, r7
    142a:	90 0d       	add	r25, r0
    142c:	36 9d       	mul	r19, r6
    142e:	90 0d       	add	r25, r0
    1430:	11 24       	eor	r1, r1
    1432:	0e 94 70 1b 	call	0x36e0	; 0x36e0 <__divmodhi4>
            int set_point = 250;
            int proportional = position - set_point;
    1436:	8b 01       	movw	r16, r22
    1438:	0a 5f       	subi	r16, 0xFA	; 250
    143a:	10 40       	sbci	r17, 0x00	; 0
            integral += proportional;
    143c:	a0 0e       	add	r10, r16
    143e:	b1 1e       	adc	r11, r17
            int derivative = proportional - lastproportional;
            lastproportional = proportional;
            error = (proportional * kp + integral * ki + derivative * kd);
    1440:	b8 01       	movw	r22, r16
    1442:	88 27       	eor	r24, r24
    1444:	77 fd       	sbrc	r23, 7
    1446:	80 95       	com	r24
    1448:	98 2f       	mov	r25, r24
    144a:	0e 94 08 19 	call	0x3210	; 0x3210 <__floatsisf>
    144e:	26 e6       	ldi	r18, 0x66	; 102
    1450:	36 e6       	ldi	r19, 0x66	; 102
    1452:	46 ee       	ldi	r20, 0xE6	; 230
    1454:	5f e3       	ldi	r21, 0x3F	; 63
    1456:	0e 94 94 19 	call	0x3328	; 0x3328 <__mulsf3>
    145a:	6b 01       	movw	r12, r22
    145c:	7c 01       	movw	r14, r24
    145e:	b5 01       	movw	r22, r10
    1460:	88 27       	eor	r24, r24
    1462:	77 fd       	sbrc	r23, 7
    1464:	80 95       	com	r24
    1466:	98 2f       	mov	r25, r24
    1468:	0e 94 08 19 	call	0x3210	; 0x3210 <__floatsisf>
    146c:	20 e0       	ldi	r18, 0x00	; 0
    146e:	30 e0       	ldi	r19, 0x00	; 0
    1470:	a9 01       	movw	r20, r18
    1472:	0e 94 94 19 	call	0x3328	; 0x3328 <__mulsf3>
    1476:	9b 01       	movw	r18, r22
    1478:	ac 01       	movw	r20, r24
    147a:	c7 01       	movw	r24, r14
    147c:	b6 01       	movw	r22, r12
    147e:	0e 94 09 18 	call	0x3012	; 0x3012 <__addsf3>
    1482:	6b 01       	movw	r12, r22
    1484:	7c 01       	movw	r14, r24
            has_turned = 0;
            int position = (((right_sensor * 2) + center_sensor) * 250) / sum;
            int set_point = 250;
            int proportional = position - set_point;
            integral += proportional;
            int derivative = proportional - lastproportional;
    1486:	b8 01       	movw	r22, r16
    1488:	6c 1b       	sub	r22, r28
    148a:	7d 0b       	sbc	r23, r29
            lastproportional = proportional;
            error = (proportional * kp + integral * ki + derivative * kd);
    148c:	88 27       	eor	r24, r24
    148e:	77 fd       	sbrc	r23, 7
    1490:	80 95       	com	r24
    1492:	98 2f       	mov	r25, r24
    1494:	0e 94 08 19 	call	0x3210	; 0x3210 <__floatsisf>
    1498:	20 e0       	ldi	r18, 0x00	; 0
    149a:	30 e0       	ldi	r19, 0x00	; 0
    149c:	48 e9       	ldi	r20, 0x98	; 152
    149e:	50 e4       	ldi	r21, 0x40	; 64
    14a0:	0e 94 94 19 	call	0x3328	; 0x3328 <__mulsf3>
    14a4:	9b 01       	movw	r18, r22
    14a6:	ac 01       	movw	r20, r24
    14a8:	c7 01       	movw	r24, r14
    14aa:	b6 01       	movw	r22, r12
    14ac:	0e 94 09 18 	call	0x3012	; 0x3012 <__addsf3>
    14b0:	0e 94 d5 18 	call	0x31aa	; 0x31aa <__fixsfsi>
    14b4:	86 2f       	mov	r24, r22
    14b6:	97 2f       	mov	r25, r23
    14b8:	2f ef       	ldi	r18, 0xFF	; 255
    14ba:	81 30       	cpi	r24, 0x01	; 1
    14bc:	92 07       	cpc	r25, r18
    14be:	0c f4       	brge	.+2      	; 0x14c2 <follow+0x1e4>
    14c0:	c2 01       	movw	r24, r4
    14c2:	8f 3f       	cpi	r24, 0xFF	; 255
    14c4:	91 05       	cpc	r25, r1
    14c6:	11 f0       	breq	.+4      	; 0x14cc <follow+0x1ee>
    14c8:	0c f0       	brlt	.+2      	; 0x14cc <follow+0x1ee>
    14ca:	c4 01       	movw	r24, r8
            if (error < -255)
                error = -255;

            if (error > 255)
                error = 255;
            if (error < 0) {
    14cc:	99 23       	and	r25, r25
    14ce:	2c f4       	brge	.+10     	; 0x14da <follow+0x1fc>
                right_speed = 255 + error;
    14d0:	ec 01       	movw	r28, r24
    14d2:	c1 50       	subi	r28, 0x01	; 1
    14d4:	df 4f       	sbci	r29, 0xFF	; 255
                left_speed = 255;
    14d6:	64 01       	movw	r12, r8
    14d8:	04 c0       	rjmp	.+8      	; 0x14e2 <follow+0x204>
                //last_turned=3;
            }
            // If error_value is greater than zero calculate left turn values
            else {
                right_speed = 255;
                left_speed = 255 - error;
    14da:	64 01       	movw	r12, r8
    14dc:	c8 1a       	sub	r12, r24
    14de:	d9 0a       	sbc	r13, r25
                left_speed = 255;
                //last_turned=3;
            }
            // If error_value is greater than zero calculate left turn values
            else {
                right_speed = 255;
    14e0:	e4 01       	movw	r28, r8
                left_speed = 255 - error;
                //last_turned=-3;
            }
            forward();
    14e2:	0e 94 35 03 	call	0x66a	; 0x66a <forward>
            velocity(right_speed, left_speed);
    14e6:	8c 2f       	mov	r24, r28
    14e8:	6c 2d       	mov	r22, r12
    14ea:	0e 94 2a 03 	call	0x654	; 0x654 <velocity>
            int position = (((right_sensor * 2) + center_sensor) * 250) / sum;
            int set_point = 250;
            int proportional = position - set_point;
            integral += proportional;
            int derivative = proportional - lastproportional;
            lastproportional = proportional;
    14ee:	e8 01       	movw	r28, r16
                //last_turned=-3;
            }
            forward();
            velocity(right_speed, left_speed);
        }
    }
    14f0:	1a cf       	rjmp	.-460    	; 0x1326 <follow+0x48>

000014f2 <north>:
 * Example Call: north(pointing_east);
 *
 */
void north(unsigned int current_orientation) {
	
    if (current_orientation == pointingnorth) { //go forward
    14f2:	20 91 93 02 	lds	r18, 0x0293
    14f6:	30 91 94 02 	lds	r19, 0x0294
    14fa:	28 17       	cp	r18, r24
    14fc:	39 07       	cpc	r19, r25
    14fe:	19 f4       	brne	.+6      	; 0x1506 <north+0x14>
        follow();
    1500:	0e 94 6f 09 	call	0x12de	; 0x12de <follow>
    1504:	2b c0       	rjmp	.+86     	; 0x155c <north+0x6a>
    } else if (current_orientation == pointingeast) { // go right
    1506:	20 91 91 02 	lds	r18, 0x0291
    150a:	30 91 92 02 	lds	r19, 0x0292
    150e:	28 17       	cp	r18, r24
    1510:	39 07       	cpc	r19, r25
    1512:	79 f4       	brne	.+30     	; 0x1532 <north+0x40>
        forward_mm(15);
    1514:	8f e0       	ldi	r24, 0x0F	; 15
    1516:	90 e0       	ldi	r25, 0x00	; 0
    1518:	0e 94 0a 04 	call	0x814	; 0x814 <forward_mm>
        velocity(220, 223);
    151c:	8c ed       	ldi	r24, 0xDC	; 220
    151e:	6f ed       	ldi	r22, 0xDF	; 223
    1520:	0e 94 2a 03 	call	0x654	; 0x654 <velocity>
        left_degrees(90);
    1524:	8a e5       	ldi	r24, 0x5A	; 90
    1526:	90 e0       	ldi	r25, 0x00	; 0
    1528:	0e 94 20 04 	call	0x840	; 0x840 <left_degrees>
        follow();
    152c:	0e 94 6f 09 	call	0x12de	; 0x12de <follow>
    1530:	15 c0       	rjmp	.+42     	; 0x155c <north+0x6a>
    } else if (current_orientation == pointingwest) { // go left
    1532:	20 91 8d 02 	lds	r18, 0x028D
    1536:	30 91 8e 02 	lds	r19, 0x028E
    153a:	28 17       	cp	r18, r24
    153c:	39 07       	cpc	r19, r25
    153e:	71 f4       	brne	.+28     	; 0x155c <north+0x6a>
        forward_mm(15);
    1540:	8f e0       	ldi	r24, 0x0F	; 15
    1542:	90 e0       	ldi	r25, 0x00	; 0
    1544:	0e 94 0a 04 	call	0x814	; 0x814 <forward_mm>
        velocity(220, 223);
    1548:	8c ed       	ldi	r24, 0xDC	; 220
    154a:	6f ed       	ldi	r22, 0xDF	; 223
    154c:	0e 94 2a 03 	call	0x654	; 0x654 <velocity>
        right_degrees(90);
    1550:	8a e5       	ldi	r24, 0x5A	; 90
    1552:	90 e0       	ldi	r25, 0x00	; 0
    1554:	0e 94 2b 04 	call	0x856	; 0x856 <right_degrees>
        follow();
    1558:	0e 94 6f 09 	call	0x12de	; 0x12de <follow>
    }
    orie = pointingnorth;
    155c:	80 91 93 02 	lds	r24, 0x0293
    1560:	90 91 94 02 	lds	r25, 0x0294
    1564:	90 93 49 03 	sts	0x0349, r25
    1568:	80 93 48 03 	sts	0x0348, r24
}
    156c:	08 95       	ret

0000156e <south>:
 * Example Call: south(pointing_east);
 *
 */
void south(unsigned int current_orientation) {

    if (current_orientation == pointingsouth) { //go forward
    156e:	20 91 8f 02 	lds	r18, 0x028F
    1572:	30 91 90 02 	lds	r19, 0x0290
    1576:	28 17       	cp	r18, r24
    1578:	39 07       	cpc	r19, r25
    157a:	19 f4       	brne	.+6      	; 0x1582 <south+0x14>
        follow();
    157c:	0e 94 6f 09 	call	0x12de	; 0x12de <follow>
    1580:	2b c0       	rjmp	.+86     	; 0x15d8 <south+0x6a>
    } else if (current_orientation == pointingeast) { // go left
    1582:	20 91 91 02 	lds	r18, 0x0291
    1586:	30 91 92 02 	lds	r19, 0x0292
    158a:	28 17       	cp	r18, r24
    158c:	39 07       	cpc	r19, r25
    158e:	79 f4       	brne	.+30     	; 0x15ae <south+0x40>
        forward_mm(15);
    1590:	8f e0       	ldi	r24, 0x0F	; 15
    1592:	90 e0       	ldi	r25, 0x00	; 0
    1594:	0e 94 0a 04 	call	0x814	; 0x814 <forward_mm>
        velocity(220, 223);
    1598:	8c ed       	ldi	r24, 0xDC	; 220
    159a:	6f ed       	ldi	r22, 0xDF	; 223
    159c:	0e 94 2a 03 	call	0x654	; 0x654 <velocity>
        right_degrees(90);
    15a0:	8a e5       	ldi	r24, 0x5A	; 90
    15a2:	90 e0       	ldi	r25, 0x00	; 0
    15a4:	0e 94 2b 04 	call	0x856	; 0x856 <right_degrees>
        follow();
    15a8:	0e 94 6f 09 	call	0x12de	; 0x12de <follow>
    15ac:	15 c0       	rjmp	.+42     	; 0x15d8 <south+0x6a>
    } else if (current_orientation == pointingwest) { // go right
    15ae:	20 91 8d 02 	lds	r18, 0x028D
    15b2:	30 91 8e 02 	lds	r19, 0x028E
    15b6:	28 17       	cp	r18, r24
    15b8:	39 07       	cpc	r19, r25
    15ba:	71 f4       	brne	.+28     	; 0x15d8 <south+0x6a>
        forward_mm(15);
    15bc:	8f e0       	ldi	r24, 0x0F	; 15
    15be:	90 e0       	ldi	r25, 0x00	; 0
    15c0:	0e 94 0a 04 	call	0x814	; 0x814 <forward_mm>
        velocity(220, 223);
    15c4:	8c ed       	ldi	r24, 0xDC	; 220
    15c6:	6f ed       	ldi	r22, 0xDF	; 223
    15c8:	0e 94 2a 03 	call	0x654	; 0x654 <velocity>
        left_degrees(90);
    15cc:	8a e5       	ldi	r24, 0x5A	; 90
    15ce:	90 e0       	ldi	r25, 0x00	; 0
    15d0:	0e 94 20 04 	call	0x840	; 0x840 <left_degrees>
        follow();
    15d4:	0e 94 6f 09 	call	0x12de	; 0x12de <follow>
    }
    orie = pointingsouth;
    15d8:	80 91 8f 02 	lds	r24, 0x028F
    15dc:	90 91 90 02 	lds	r25, 0x0290
    15e0:	90 93 49 03 	sts	0x0349, r25
    15e4:	80 93 48 03 	sts	0x0348, r24
}
    15e8:	08 95       	ret

000015ea <west>:
 * Example Call: north(pointing_east);
 *
 */
void west(unsigned int current_orientation) { 

    if (current_orientation == pointingwest) { // go forward
    15ea:	20 91 8d 02 	lds	r18, 0x028D
    15ee:	30 91 8e 02 	lds	r19, 0x028E
    15f2:	28 17       	cp	r18, r24
    15f4:	39 07       	cpc	r19, r25
    15f6:	19 f4       	brne	.+6      	; 0x15fe <west+0x14>
        follow();
    15f8:	0e 94 6f 09 	call	0x12de	; 0x12de <follow>
    15fc:	2b c0       	rjmp	.+86     	; 0x1654 <west+0x6a>
    } else if (current_orientation == pointingnorth) { //go right
    15fe:	20 91 93 02 	lds	r18, 0x0293
    1602:	30 91 94 02 	lds	r19, 0x0294
    1606:	28 17       	cp	r18, r24
    1608:	39 07       	cpc	r19, r25
    160a:	79 f4       	brne	.+30     	; 0x162a <west+0x40>
        forward_mm(15);
    160c:	8f e0       	ldi	r24, 0x0F	; 15
    160e:	90 e0       	ldi	r25, 0x00	; 0
    1610:	0e 94 0a 04 	call	0x814	; 0x814 <forward_mm>
        velocity(220, 223);
    1614:	8c ed       	ldi	r24, 0xDC	; 220
    1616:	6f ed       	ldi	r22, 0xDF	; 223
    1618:	0e 94 2a 03 	call	0x654	; 0x654 <velocity>
        left_degrees(90);
    161c:	8a e5       	ldi	r24, 0x5A	; 90
    161e:	90 e0       	ldi	r25, 0x00	; 0
    1620:	0e 94 20 04 	call	0x840	; 0x840 <left_degrees>
        follow();
    1624:	0e 94 6f 09 	call	0x12de	; 0x12de <follow>
    1628:	15 c0       	rjmp	.+42     	; 0x1654 <west+0x6a>
    } else if (current_orientation == pointingsouth) { // go left
    162a:	20 91 8f 02 	lds	r18, 0x028F
    162e:	30 91 90 02 	lds	r19, 0x0290
    1632:	28 17       	cp	r18, r24
    1634:	39 07       	cpc	r19, r25
    1636:	71 f4       	brne	.+28     	; 0x1654 <west+0x6a>

        forward_mm(15);
    1638:	8f e0       	ldi	r24, 0x0F	; 15
    163a:	90 e0       	ldi	r25, 0x00	; 0
    163c:	0e 94 0a 04 	call	0x814	; 0x814 <forward_mm>
        velocity(220, 223);
    1640:	8c ed       	ldi	r24, 0xDC	; 220
    1642:	6f ed       	ldi	r22, 0xDF	; 223
    1644:	0e 94 2a 03 	call	0x654	; 0x654 <velocity>
        right_degrees(90);
    1648:	8a e5       	ldi	r24, 0x5A	; 90
    164a:	90 e0       	ldi	r25, 0x00	; 0
    164c:	0e 94 2b 04 	call	0x856	; 0x856 <right_degrees>
        follow();
    1650:	0e 94 6f 09 	call	0x12de	; 0x12de <follow>
    }
    orie = pointingwest;
    1654:	80 91 8d 02 	lds	r24, 0x028D
    1658:	90 91 8e 02 	lds	r25, 0x028E
    165c:	90 93 49 03 	sts	0x0349, r25
    1660:	80 93 48 03 	sts	0x0348, r24
}
    1664:	08 95       	ret

00001666 <east>:
 *		  3) If the bot faces in east and has to move south then it must go right		
 * Example Call: south(pointing_east);
 *
 */
void east(int current_orientation) {
    if (current_orientation == pointingeast) {	// go forward
    1666:	20 91 91 02 	lds	r18, 0x0291
    166a:	30 91 92 02 	lds	r19, 0x0292
    166e:	82 17       	cp	r24, r18
    1670:	93 07       	cpc	r25, r19
    1672:	19 f4       	brne	.+6      	; 0x167a <east+0x14>
        follow();
    1674:	0e 94 6f 09 	call	0x12de	; 0x12de <follow>
    1678:	2b c0       	rjmp	.+86     	; 0x16d0 <east+0x6a>
    } else if (current_orientation == pointingnorth) {	// go left
    167a:	20 91 93 02 	lds	r18, 0x0293
    167e:	30 91 94 02 	lds	r19, 0x0294
    1682:	82 17       	cp	r24, r18
    1684:	93 07       	cpc	r25, r19
    1686:	79 f4       	brne	.+30     	; 0x16a6 <east+0x40>
        forward_mm(15);
    1688:	8f e0       	ldi	r24, 0x0F	; 15
    168a:	90 e0       	ldi	r25, 0x00	; 0
    168c:	0e 94 0a 04 	call	0x814	; 0x814 <forward_mm>
        velocity(220, 223);
    1690:	8c ed       	ldi	r24, 0xDC	; 220
    1692:	6f ed       	ldi	r22, 0xDF	; 223
    1694:	0e 94 2a 03 	call	0x654	; 0x654 <velocity>
        right_degrees(90);
    1698:	8a e5       	ldi	r24, 0x5A	; 90
    169a:	90 e0       	ldi	r25, 0x00	; 0
    169c:	0e 94 2b 04 	call	0x856	; 0x856 <right_degrees>
        follow();
    16a0:	0e 94 6f 09 	call	0x12de	; 0x12de <follow>
    16a4:	15 c0       	rjmp	.+42     	; 0x16d0 <east+0x6a>
    } else if (current_orientation == pointingsouth) { // go right
    16a6:	20 91 8f 02 	lds	r18, 0x028F
    16aa:	30 91 90 02 	lds	r19, 0x0290
    16ae:	82 17       	cp	r24, r18
    16b0:	93 07       	cpc	r25, r19
    16b2:	71 f4       	brne	.+28     	; 0x16d0 <east+0x6a>
        forward_mm(15);
    16b4:	8f e0       	ldi	r24, 0x0F	; 15
    16b6:	90 e0       	ldi	r25, 0x00	; 0
    16b8:	0e 94 0a 04 	call	0x814	; 0x814 <forward_mm>
        velocity(220, 223);
    16bc:	8c ed       	ldi	r24, 0xDC	; 220
    16be:	6f ed       	ldi	r22, 0xDF	; 223
    16c0:	0e 94 2a 03 	call	0x654	; 0x654 <velocity>
        left_degrees(90);
    16c4:	8a e5       	ldi	r24, 0x5A	; 90
    16c6:	90 e0       	ldi	r25, 0x00	; 0
    16c8:	0e 94 20 04 	call	0x840	; 0x840 <left_degrees>
        follow();
    16cc:	0e 94 6f 09 	call	0x12de	; 0x12de <follow>
    }
    orie = pointingeast;
    16d0:	80 91 91 02 	lds	r24, 0x0291
    16d4:	90 91 92 02 	lds	r25, 0x0292
    16d8:	90 93 49 03 	sts	0x0349, r25
    16dc:	80 93 48 03 	sts	0x0348, r24
}
    16e0:	08 95       	ret

000016e2 <zone_availability>:
 * Example Call: order_picking(12);
 *					OR
 *				  order_picking(current_position)
 */

int zone_availability(int color, int border) {
    16e2:	0f 93       	push	r16
    16e4:	1f 93       	push	r17
    16e6:	cf 93       	push	r28
    16e8:	df 93       	push	r29
    16ea:	db 01       	movw	r26, r22
    int row;
    if (color == red_color)
    16ec:	20 91 87 02 	lds	r18, 0x0287
    16f0:	30 91 88 02 	lds	r19, 0x0288
    16f4:	82 17       	cp	r24, r18
    16f6:	93 07       	cpc	r25, r19
    16f8:	79 f0       	breq	.+30     	; 0x1718 <zone_availability+0x36>
        row = 0;
    else if (color == green_color)
    16fa:	20 91 85 02 	lds	r18, 0x0285
    16fe:	30 91 86 02 	lds	r19, 0x0286
    1702:	82 17       	cp	r24, r18
    1704:	93 07       	cpc	r25, r19
    1706:	59 f0       	breq	.+22     	; 0x171e <zone_availability+0x3c>
        row = 1;
    else if (color == blue_color)
    1708:	20 91 83 02 	lds	r18, 0x0283
    170c:	30 91 84 02 	lds	r19, 0x0284
    1710:	82 17       	cp	r24, r18
    1712:	93 07       	cpc	r25, r19
    1714:	49 f4       	brne	.+18     	; 0x1728 <zone_availability+0x46>
    1716:	06 c0       	rjmp	.+12     	; 0x1724 <zone_availability+0x42>
 */

int zone_availability(int color, int border) {
    int row;
    if (color == red_color)
        row = 0;
    1718:	e0 e0       	ldi	r30, 0x00	; 0
    171a:	f0 e0       	ldi	r31, 0x00	; 0
    171c:	05 c0       	rjmp	.+10     	; 0x1728 <zone_availability+0x46>
    else if (color == green_color)
        row = 1;
    171e:	e1 e0       	ldi	r30, 0x01	; 1
    1720:	f0 e0       	ldi	r31, 0x00	; 0
    1722:	02 c0       	rjmp	.+4      	; 0x1728 <zone_availability+0x46>
    else if (color == blue_color)
        row = 2;
    1724:	e2 e0       	ldi	r30, 0x02	; 2
    1726:	f0 e0       	ldi	r31, 0x00	; 0
 * Example Call: order_picking(12);
 *					OR
 *				  order_picking(current_position)
 */

int zone_availability(int color, int border) {
    1728:	ee 0f       	add	r30, r30
    172a:	ff 1f       	adc	r31, r31
    172c:	ee 0f       	add	r30, r30
    172e:	ff 1f       	adc	r31, r31
    1730:	ee 0f       	add	r30, r30
    1732:	ff 1f       	adc	r31, r31
    1734:	e3 59       	subi	r30, 0x93	; 147
    1736:	fd 4f       	sbci	r31, 0xFD	; 253
    1738:	42 e0       	ldi	r20, 0x02	; 2
    173a:	50 e0       	ldi	r21, 0x00	; 0
    173c:	21 e0       	ldi	r18, 0x01	; 1
    173e:	30 e0       	ldi	r19, 0x00	; 0
                if (blocks_in[zone] < 2) {
                    blocks_in[zone] ++;
                    return zone;
                }
            } else if ((border == 2) && (zone == 5 || zone == 3 || zone == 4 || zone == 1 || zone == 2)) {
                if (blocks_in[zone] < 2) {
    1740:	04 eb       	ldi	r16, 0xB4	; 180
    1742:	12 e0       	ldi	r17, 0x02	; 2
    1744:	04 c0       	rjmp	.+8      	; 0x174e <zone_availability+0x6c>
    int row;
    if (color == red_color)
        row = 0;
    else if (color == green_color)
        row = 1;
    else if (color == blue_color)
    1746:	2f 5f       	subi	r18, 0xFF	; 255
    1748:	3f 4f       	sbci	r19, 0xFF	; 255
    174a:	4f 5f       	subi	r20, 0xFF	; 255
    174c:	5f 4f       	sbci	r21, 0xFF	; 255
        row = 2;

    for (int j = 1; j <= 3; j++) {
        int zone = deposition_table[row][j];
    174e:	61 91       	ld	r22, Z+
    1750:	71 91       	ld	r23, Z+

        if (j == 1) {
    1752:	21 30       	cpi	r18, 0x01	; 1
    1754:	31 05       	cpc	r19, r1
    1756:	09 f0       	breq	.+2      	; 0x175a <zone_availability+0x78>
    1758:	3f c0       	rjmp	.+126    	; 0x17d8 <zone_availability+0xf6>
            if ((border == 1) && (zone == 1 || zone == 2 || zone == 5)) {
    175a:	a1 30       	cpi	r26, 0x01	; 1
    175c:	b1 05       	cpc	r27, r1
    175e:	e9 f4       	brne	.+58     	; 0x179a <zone_availability+0xb8>
    1760:	cb 01       	movw	r24, r22
    1762:	01 97       	sbiw	r24, 0x01	; 1
    1764:	82 30       	cpi	r24, 0x02	; 2
    1766:	91 05       	cpc	r25, r1
    1768:	20 f0       	brcs	.+8      	; 0x1772 <zone_availability+0x90>
    176a:	65 30       	cpi	r22, 0x05	; 5
    176c:	71 05       	cpc	r23, r1
    176e:	09 f0       	breq	.+2      	; 0x1772 <zone_availability+0x90>
    1770:	83 c0       	rjmp	.+262    	; 0x1878 <zone_availability+0x196>
                if (blocks_in[zone] < 2) {
    1772:	cb 01       	movw	r24, r22
    1774:	88 0f       	add	r24, r24
    1776:	99 1f       	adc	r25, r25
    1778:	80 0f       	add	r24, r16
    177a:	91 1f       	adc	r25, r17
    177c:	ec 01       	movw	r28, r24
    177e:	88 81       	ld	r24, Y
    1780:	99 81       	ldd	r25, Y+1	; 0x01
    1782:	82 30       	cpi	r24, 0x02	; 2
    1784:	91 05       	cpc	r25, r1
    1786:	fc f6       	brge	.-66     	; 0x1746 <zone_availability+0x64>
                    blocks_in[zone] ++;
    1788:	fb 01       	movw	r30, r22
    178a:	ee 0f       	add	r30, r30
    178c:	ff 1f       	adc	r31, r31
    178e:	ec 54       	subi	r30, 0x4C	; 76
    1790:	fd 4f       	sbci	r31, 0xFD	; 253
    1792:	01 96       	adiw	r24, 0x01	; 1
    1794:	91 83       	std	Z+1, r25	; 0x01
    1796:	80 83       	st	Z, r24
                    return zone;
    1798:	74 c0       	rjmp	.+232    	; 0x1882 <zone_availability+0x1a0>
                }
            } else if ((border == 2) && (zone == 3 || zone == 4 || zone == 5)) {
    179a:	a2 30       	cpi	r26, 0x02	; 2
    179c:	b1 05       	cpc	r27, r1
    179e:	09 f0       	breq	.+2      	; 0x17a2 <zone_availability+0xc0>
    17a0:	6b c0       	rjmp	.+214    	; 0x1878 <zone_availability+0x196>
    17a2:	cb 01       	movw	r24, r22
    17a4:	03 97       	sbiw	r24, 0x03	; 3
    17a6:	83 30       	cpi	r24, 0x03	; 3
    17a8:	91 05       	cpc	r25, r1
    17aa:	08 f0       	brcs	.+2      	; 0x17ae <zone_availability+0xcc>
    17ac:	65 c0       	rjmp	.+202    	; 0x1878 <zone_availability+0x196>
                if (blocks_in[zone] < 2) {
    17ae:	cb 01       	movw	r24, r22
    17b0:	88 0f       	add	r24, r24
    17b2:	99 1f       	adc	r25, r25
    17b4:	80 0f       	add	r24, r16
    17b6:	91 1f       	adc	r25, r17
    17b8:	ec 01       	movw	r28, r24
    17ba:	88 81       	ld	r24, Y
    17bc:	99 81       	ldd	r25, Y+1	; 0x01
    17be:	82 30       	cpi	r24, 0x02	; 2
    17c0:	91 05       	cpc	r25, r1
    17c2:	0c f0       	brlt	.+2      	; 0x17c6 <zone_availability+0xe4>
    17c4:	59 c0       	rjmp	.+178    	; 0x1878 <zone_availability+0x196>
                    blocks_in[zone] ++;
    17c6:	fb 01       	movw	r30, r22
    17c8:	ee 0f       	add	r30, r30
    17ca:	ff 1f       	adc	r31, r31
    17cc:	ec 54       	subi	r30, 0x4C	; 76
    17ce:	fd 4f       	sbci	r31, 0xFD	; 253
    17d0:	01 96       	adiw	r24, 0x01	; 1
    17d2:	91 83       	std	Z+1, r25	; 0x01
    17d4:	80 83       	st	Z, r24
                    return zone;
    17d6:	55 c0       	rjmp	.+170    	; 0x1882 <zone_availability+0x1a0>
                }
            }

        } else if (j >= 2) {
    17d8:	22 30       	cpi	r18, 0x02	; 2
    17da:	31 05       	cpc	r19, r1
    17dc:	0c f4       	brge	.+2      	; 0x17e0 <zone_availability+0xfe>
    17de:	4c c0       	rjmp	.+152    	; 0x1878 <zone_availability+0x196>
            if ((border == 1) && (zone == 5 || zone == 1 || zone == 2 || zone == 3 || zone == 4)) {
    17e0:	a1 30       	cpi	r26, 0x01	; 1
    17e2:	b1 05       	cpc	r27, r1
    17e4:	19 f5       	brne	.+70     	; 0x182c <zone_availability+0x14a>
    17e6:	65 30       	cpi	r22, 0x05	; 5
    17e8:	71 05       	cpc	r23, r1
    17ea:	61 f0       	breq	.+24     	; 0x1804 <zone_availability+0x122>
    17ec:	61 30       	cpi	r22, 0x01	; 1
    17ee:	71 05       	cpc	r23, r1
    17f0:	49 f0       	breq	.+18     	; 0x1804 <zone_availability+0x122>
    17f2:	62 30       	cpi	r22, 0x02	; 2
    17f4:	71 05       	cpc	r23, r1
    17f6:	31 f0       	breq	.+12     	; 0x1804 <zone_availability+0x122>
    17f8:	63 30       	cpi	r22, 0x03	; 3
    17fa:	71 05       	cpc	r23, r1
    17fc:	19 f0       	breq	.+6      	; 0x1804 <zone_availability+0x122>
    17fe:	64 30       	cpi	r22, 0x04	; 4
    1800:	71 05       	cpc	r23, r1
    1802:	d1 f5       	brne	.+116    	; 0x1878 <zone_availability+0x196>
                if (blocks_in[zone] < 2) {
    1804:	cb 01       	movw	r24, r22
    1806:	88 0f       	add	r24, r24
    1808:	99 1f       	adc	r25, r25
    180a:	80 0f       	add	r24, r16
    180c:	91 1f       	adc	r25, r17
    180e:	ec 01       	movw	r28, r24
    1810:	88 81       	ld	r24, Y
    1812:	99 81       	ldd	r25, Y+1	; 0x01
    1814:	82 30       	cpi	r24, 0x02	; 2
    1816:	91 05       	cpc	r25, r1
    1818:	7c f5       	brge	.+94     	; 0x1878 <zone_availability+0x196>
                    blocks_in[zone] ++;
    181a:	fb 01       	movw	r30, r22
    181c:	ee 0f       	add	r30, r30
    181e:	ff 1f       	adc	r31, r31
    1820:	ec 54       	subi	r30, 0x4C	; 76
    1822:	fd 4f       	sbci	r31, 0xFD	; 253
    1824:	01 96       	adiw	r24, 0x01	; 1
    1826:	91 83       	std	Z+1, r25	; 0x01
    1828:	80 83       	st	Z, r24
                    return zone;
    182a:	2b c0       	rjmp	.+86     	; 0x1882 <zone_availability+0x1a0>
                }
            } else if ((border == 2) && (zone == 5 || zone == 3 || zone == 4 || zone == 1 || zone == 2)) {
    182c:	a2 30       	cpi	r26, 0x02	; 2
    182e:	b1 05       	cpc	r27, r1
    1830:	19 f5       	brne	.+70     	; 0x1878 <zone_availability+0x196>
    1832:	65 30       	cpi	r22, 0x05	; 5
    1834:	71 05       	cpc	r23, r1
    1836:	61 f0       	breq	.+24     	; 0x1850 <zone_availability+0x16e>
    1838:	63 30       	cpi	r22, 0x03	; 3
    183a:	71 05       	cpc	r23, r1
    183c:	49 f0       	breq	.+18     	; 0x1850 <zone_availability+0x16e>
    183e:	64 30       	cpi	r22, 0x04	; 4
    1840:	71 05       	cpc	r23, r1
    1842:	31 f0       	breq	.+12     	; 0x1850 <zone_availability+0x16e>
    1844:	61 30       	cpi	r22, 0x01	; 1
    1846:	71 05       	cpc	r23, r1
    1848:	19 f0       	breq	.+6      	; 0x1850 <zone_availability+0x16e>
    184a:	62 30       	cpi	r22, 0x02	; 2
    184c:	71 05       	cpc	r23, r1
    184e:	a1 f4       	brne	.+40     	; 0x1878 <zone_availability+0x196>
                if (blocks_in[zone] < 2) {
    1850:	cb 01       	movw	r24, r22
    1852:	88 0f       	add	r24, r24
    1854:	99 1f       	adc	r25, r25
    1856:	80 0f       	add	r24, r16
    1858:	91 1f       	adc	r25, r17
    185a:	ec 01       	movw	r28, r24
    185c:	88 81       	ld	r24, Y
    185e:	99 81       	ldd	r25, Y+1	; 0x01
    1860:	82 30       	cpi	r24, 0x02	; 2
    1862:	91 05       	cpc	r25, r1
    1864:	4c f4       	brge	.+18     	; 0x1878 <zone_availability+0x196>
                    blocks_in[zone] ++;
    1866:	fb 01       	movw	r30, r22
    1868:	ee 0f       	add	r30, r30
    186a:	ff 1f       	adc	r31, r31
    186c:	ec 54       	subi	r30, 0x4C	; 76
    186e:	fd 4f       	sbci	r31, 0xFD	; 253
    1870:	01 96       	adiw	r24, 0x01	; 1
    1872:	91 83       	std	Z+1, r25	; 0x01
    1874:	80 83       	st	Z, r24
                    return zone;
    1876:	05 c0       	rjmp	.+10     	; 0x1882 <zone_availability+0x1a0>
    else if (color == green_color)
        row = 1;
    else if (color == blue_color)
        row = 2;

    for (int j = 1; j <= 3; j++) {
    1878:	44 30       	cpi	r20, 0x04	; 4
    187a:	51 05       	cpc	r21, r1
    187c:	0c f4       	brge	.+2      	; 0x1880 <zone_availability+0x19e>
    187e:	63 cf       	rjmp	.-314    	; 0x1746 <zone_availability+0x64>
    1880:	02 c0       	rjmp	.+4      	; 0x1886 <zone_availability+0x1a4>
                }
            }

        }
    }
}
    1882:	86 2f       	mov	r24, r22
    1884:	97 2f       	mov	r25, r23
    1886:	df 91       	pop	r29
    1888:	cf 91       	pop	r28
    188a:	1f 91       	pop	r17
    188c:	0f 91       	pop	r16
    188e:	08 95       	ret

00001890 <order_picking>:
 *		  Check for the available zone for that package in the given co-ordinate and store it in info_table[][]
 * Example Call: order_picking(12);
 *					OR
 *				  order_picking(current_position)
 */
void order_picking(int co_ordinate) {
    1890:	cf 93       	push	r28
    1892:	df 93       	push	r29
    1894:	9c 01       	movw	r18, r24
    for (int i = 0; i <= 11; i++) {
    1896:	e0 ec       	ldi	r30, 0xC0	; 192
    1898:	f2 e0       	ldi	r31, 0x02	; 2
    189a:	c0 e0       	ldi	r28, 0x00	; 0
    189c:	d0 e0       	ldi	r29, 0x00	; 0
        if (info_table[i][0] == co_ordinate && i <= 5) {
    189e:	80 81       	ld	r24, Z
    18a0:	91 81       	ldd	r25, Z+1	; 0x01
    18a2:	82 17       	cp	r24, r18
    18a4:	93 07       	cpc	r25, r19
    18a6:	09 f0       	breq	.+2      	; 0x18aa <order_picking+0x1a>
    18a8:	a8 c0       	rjmp	.+336    	; 0x19fa <order_picking+0x16a>
    18aa:	c6 30       	cpi	r28, 0x06	; 6
    18ac:	d1 05       	cpc	r29, r1
    18ae:	0c f0       	brlt	.+2      	; 0x18b2 <order_picking+0x22>
    18b0:	51 c0       	rjmp	.+162    	; 0x1954 <order_picking+0xc4>
            if (info_table[i][1] == red_color) {
    18b2:	fe 01       	movw	r30, r28
    18b4:	ee 0f       	add	r30, r30
    18b6:	ff 1f       	adc	r31, r31
    18b8:	ec 0f       	add	r30, r28
    18ba:	fd 1f       	adc	r31, r29
    18bc:	ee 0f       	add	r30, r30
    18be:	ff 1f       	adc	r31, r31
    18c0:	e0 54       	subi	r30, 0x40	; 64
    18c2:	fd 4f       	sbci	r31, 0xFD	; 253
    18c4:	82 81       	ldd	r24, Z+2	; 0x02
    18c6:	93 81       	ldd	r25, Z+3	; 0x03
    18c8:	20 91 87 02 	lds	r18, 0x0287
    18cc:	30 91 88 02 	lds	r19, 0x0288
    18d0:	82 17       	cp	r24, r18
    18d2:	93 07       	cpc	r25, r19
    18d4:	81 f4       	brne	.+32     	; 0x18f6 <order_picking+0x66>
                info_table[i][2] = zone_availability(red_color, 1);	// 1 signifies lower boundary of the arena i.e co-ordinate 11-19.
    18d6:	61 e0       	ldi	r22, 0x01	; 1
    18d8:	70 e0       	ldi	r23, 0x00	; 0
    18da:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <zone_availability>
    18de:	9e 01       	movw	r18, r28
    18e0:	22 0f       	add	r18, r18
    18e2:	33 1f       	adc	r19, r19
    18e4:	c2 0f       	add	r28, r18
    18e6:	d3 1f       	adc	r29, r19
    18e8:	cc 0f       	add	r28, r28
    18ea:	dd 1f       	adc	r29, r29
    18ec:	c0 54       	subi	r28, 0x40	; 64
    18ee:	dd 4f       	sbci	r29, 0xFD	; 253
    18f0:	9d 83       	std	Y+5, r25	; 0x05
    18f2:	8c 83       	std	Y+4, r24	; 0x04
                break;
    18f4:	88 c0       	rjmp	.+272    	; 0x1a06 <order_picking+0x176>
            } else if (info_table[i][1] == blue_color) {
    18f6:	20 91 83 02 	lds	r18, 0x0283
    18fa:	30 91 84 02 	lds	r19, 0x0284
    18fe:	82 17       	cp	r24, r18
    1900:	93 07       	cpc	r25, r19
    1902:	81 f4       	brne	.+32     	; 0x1924 <order_picking+0x94>
                info_table[i][2] = zone_availability(blue_color, 1); // 1 signifies lower boundary of the arena i.e co-ordinate 11-19.
    1904:	61 e0       	ldi	r22, 0x01	; 1
    1906:	70 e0       	ldi	r23, 0x00	; 0
    1908:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <zone_availability>
    190c:	9e 01       	movw	r18, r28
    190e:	22 0f       	add	r18, r18
    1910:	33 1f       	adc	r19, r19
    1912:	c2 0f       	add	r28, r18
    1914:	d3 1f       	adc	r29, r19
    1916:	cc 0f       	add	r28, r28
    1918:	dd 1f       	adc	r29, r29
    191a:	c0 54       	subi	r28, 0x40	; 64
    191c:	dd 4f       	sbci	r29, 0xFD	; 253
    191e:	9d 83       	std	Y+5, r25	; 0x05
    1920:	8c 83       	std	Y+4, r24	; 0x04
                break;
    1922:	71 c0       	rjmp	.+226    	; 0x1a06 <order_picking+0x176>
            } else if (info_table[i][1] == green_color) {
    1924:	20 91 85 02 	lds	r18, 0x0285
    1928:	30 91 86 02 	lds	r19, 0x0286
    192c:	82 17       	cp	r24, r18
    192e:	93 07       	cpc	r25, r19
    1930:	09 f0       	breq	.+2      	; 0x1934 <order_picking+0xa4>
    1932:	69 c0       	rjmp	.+210    	; 0x1a06 <order_picking+0x176>
                info_table[i][2] = zone_availability(green_color, 1); // 1 signifies lower boundary of the arena i.e co-ordinate 11-19.
    1934:	61 e0       	ldi	r22, 0x01	; 1
    1936:	70 e0       	ldi	r23, 0x00	; 0
    1938:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <zone_availability>
    193c:	9e 01       	movw	r18, r28
    193e:	22 0f       	add	r18, r18
    1940:	33 1f       	adc	r19, r19
    1942:	c2 0f       	add	r28, r18
    1944:	d3 1f       	adc	r29, r19
    1946:	cc 0f       	add	r28, r28
    1948:	dd 1f       	adc	r29, r29
    194a:	c0 54       	subi	r28, 0x40	; 64
    194c:	dd 4f       	sbci	r29, 0xFD	; 253
    194e:	9d 83       	std	Y+5, r25	; 0x05
    1950:	8c 83       	std	Y+4, r24	; 0x04
                break;
    1952:	59 c0       	rjmp	.+178    	; 0x1a06 <order_picking+0x176>
            } else break;
        } else if (info_table[i][0] == co_ordinate && i > 5) {
            if (info_table[i][1] == red_color) {
    1954:	fe 01       	movw	r30, r28
    1956:	ee 0f       	add	r30, r30
    1958:	ff 1f       	adc	r31, r31
    195a:	ec 0f       	add	r30, r28
    195c:	fd 1f       	adc	r31, r29
    195e:	ee 0f       	add	r30, r30
    1960:	ff 1f       	adc	r31, r31
    1962:	e0 54       	subi	r30, 0x40	; 64
    1964:	fd 4f       	sbci	r31, 0xFD	; 253
    1966:	82 81       	ldd	r24, Z+2	; 0x02
    1968:	93 81       	ldd	r25, Z+3	; 0x03
    196a:	20 91 87 02 	lds	r18, 0x0287
    196e:	30 91 88 02 	lds	r19, 0x0288
    1972:	82 17       	cp	r24, r18
    1974:	93 07       	cpc	r25, r19
    1976:	89 f4       	brne	.+34     	; 0x199a <order_picking+0x10a>
                info_table[i][2] = zone_availability(red_color, 2); // 2 signifies upper boundary of the arena i.e co-ordinate 41-49.
    1978:	62 e0       	ldi	r22, 0x02	; 2
    197a:	70 e0       	ldi	r23, 0x00	; 0
    197c:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <zone_availability>
    1980:	fe 01       	movw	r30, r28
    1982:	ee 0f       	add	r30, r30
    1984:	ff 1f       	adc	r31, r31
    1986:	ce 0f       	add	r28, r30
    1988:	df 1f       	adc	r29, r31
    198a:	fe 01       	movw	r30, r28
    198c:	ee 0f       	add	r30, r30
    198e:	ff 1f       	adc	r31, r31
    1990:	e0 54       	subi	r30, 0x40	; 64
    1992:	fd 4f       	sbci	r31, 0xFD	; 253
    1994:	95 83       	std	Z+5, r25	; 0x05
    1996:	84 83       	std	Z+4, r24	; 0x04
                break;
    1998:	36 c0       	rjmp	.+108    	; 0x1a06 <order_picking+0x176>
            } else if (info_table[i][1] == blue_color) {
    199a:	20 91 83 02 	lds	r18, 0x0283
    199e:	30 91 84 02 	lds	r19, 0x0284
    19a2:	82 17       	cp	r24, r18
    19a4:	93 07       	cpc	r25, r19
    19a6:	89 f4       	brne	.+34     	; 0x19ca <order_picking+0x13a>
                info_table[i][2] = zone_availability(blue_color, 2); // 2 signifies upper boundary of the arena i.e co-ordinate 41-49.
    19a8:	62 e0       	ldi	r22, 0x02	; 2
    19aa:	70 e0       	ldi	r23, 0x00	; 0
    19ac:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <zone_availability>
    19b0:	fe 01       	movw	r30, r28
    19b2:	ee 0f       	add	r30, r30
    19b4:	ff 1f       	adc	r31, r31
    19b6:	ce 0f       	add	r28, r30
    19b8:	df 1f       	adc	r29, r31
    19ba:	fe 01       	movw	r30, r28
    19bc:	ee 0f       	add	r30, r30
    19be:	ff 1f       	adc	r31, r31
    19c0:	e0 54       	subi	r30, 0x40	; 64
    19c2:	fd 4f       	sbci	r31, 0xFD	; 253
    19c4:	95 83       	std	Z+5, r25	; 0x05
    19c6:	84 83       	std	Z+4, r24	; 0x04
                break;
    19c8:	1e c0       	rjmp	.+60     	; 0x1a06 <order_picking+0x176>
            } else if (info_table[i][1] == green_color) {
    19ca:	20 91 85 02 	lds	r18, 0x0285
    19ce:	30 91 86 02 	lds	r19, 0x0286
    19d2:	82 17       	cp	r24, r18
    19d4:	93 07       	cpc	r25, r19
    19d6:	b9 f4       	brne	.+46     	; 0x1a06 <order_picking+0x176>
                info_table[i][2] = zone_availability(green_color, 2); // 2 signifies upper boundary of the arena i.e co-ordinate 41-49.
    19d8:	62 e0       	ldi	r22, 0x02	; 2
    19da:	70 e0       	ldi	r23, 0x00	; 0
    19dc:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <zone_availability>
    19e0:	fe 01       	movw	r30, r28
    19e2:	ee 0f       	add	r30, r30
    19e4:	ff 1f       	adc	r31, r31
    19e6:	ce 0f       	add	r28, r30
    19e8:	df 1f       	adc	r29, r31
    19ea:	fe 01       	movw	r30, r28
    19ec:	ee 0f       	add	r30, r30
    19ee:	ff 1f       	adc	r31, r31
    19f0:	e0 54       	subi	r30, 0x40	; 64
    19f2:	fd 4f       	sbci	r31, 0xFD	; 253
    19f4:	95 83       	std	Z+5, r25	; 0x05
    19f6:	84 83       	std	Z+4, r24	; 0x04
                break;
    19f8:	06 c0       	rjmp	.+12     	; 0x1a06 <order_picking+0x176>
 * Example Call: order_picking(12);
 *					OR
 *				  order_picking(current_position)
 */
void order_picking(int co_ordinate) {
    for (int i = 0; i <= 11; i++) {
    19fa:	21 96       	adiw	r28, 0x01	; 1
    19fc:	36 96       	adiw	r30, 0x06	; 6
    19fe:	cc 30       	cpi	r28, 0x0C	; 12
    1a00:	d1 05       	cpc	r29, r1
    1a02:	09 f0       	breq	.+2      	; 0x1a06 <order_picking+0x176>
    1a04:	4c cf       	rjmp	.-360    	; 0x189e <order_picking+0xe>
                info_table[i][2] = zone_availability(green_color, 2); // 2 signifies upper boundary of the arena i.e co-ordinate 41-49.
                break;
            } else break;
        }
    }
}
    1a06:	df 91       	pop	r29
    1a08:	cf 91       	pop	r28
    1a0a:	08 95       	ret

00001a0c <travel>:
 *		  travel node to node until from(y co-ordinate) = to (y co-ordinate)	 	
 * Example Call: travel(12,13);
 *					OR
 *				  travel(current_position,next_position)
 */
void travel(int from, int to) {
    1a0c:	af 92       	push	r10
    1a0e:	bf 92       	push	r11
    1a10:	cf 92       	push	r12
    1a12:	df 92       	push	r13
    1a14:	ef 92       	push	r14
    1a16:	ff 92       	push	r15
    1a18:	0f 93       	push	r16
    1a1a:	1f 93       	push	r17
    1a1c:	cf 93       	push	r28
    1a1e:	df 93       	push	r29
    1a20:	9c 01       	movw	r18, r24
    1a22:	5b 01       	movw	r10, r22
        int x1 = from / 10;
    1a24:	ea e0       	ldi	r30, 0x0A	; 10
    1a26:	f0 e0       	ldi	r31, 0x00	; 0
        int y1 = from % 10;
    1a28:	bf 01       	movw	r22, r30
    1a2a:	0e 94 70 1b 	call	0x36e0	; 0x36e0 <__divmodhi4>
    1a2e:	8b 01       	movw	r16, r22
    1a30:	ec 01       	movw	r28, r24
        int x2 = to / 10;
        int y2 = to % 10;
    1a32:	c5 01       	movw	r24, r10
    1a34:	bf 01       	movw	r22, r30
    1a36:	0e 94 70 1b 	call	0x36e0	; 0x36e0 <__divmodhi4>
    1a3a:	6b 01       	movw	r12, r22
    1a3c:	7c 01       	movw	r14, r24
        if (from == 21 || from == 29 || from == 25 || from == 31 || from == 39 || from == 35) {
    1a3e:	25 31       	cpi	r18, 0x15	; 21
    1a40:	31 05       	cpc	r19, r1
    1a42:	81 f0       	breq	.+32     	; 0x1a64 <travel+0x58>
    1a44:	2d 31       	cpi	r18, 0x1D	; 29
    1a46:	31 05       	cpc	r19, r1
    1a48:	69 f0       	breq	.+26     	; 0x1a64 <travel+0x58>
    1a4a:	29 31       	cpi	r18, 0x19	; 25
    1a4c:	31 05       	cpc	r19, r1
    1a4e:	51 f0       	breq	.+20     	; 0x1a64 <travel+0x58>
    1a50:	2f 31       	cpi	r18, 0x1F	; 31
    1a52:	31 05       	cpc	r19, r1
    1a54:	39 f0       	breq	.+14     	; 0x1a64 <travel+0x58>
    1a56:	27 32       	cpi	r18, 0x27	; 39
    1a58:	31 05       	cpc	r19, r1
    1a5a:	21 f0       	breq	.+8      	; 0x1a64 <travel+0x58>
    1a5c:	23 32       	cpi	r18, 0x23	; 35
    1a5e:	31 05       	cpc	r19, r1
    1a60:	09 f0       	breq	.+2      	; 0x1a64 <travel+0x58>
    1a62:	45 c0       	rjmp	.+138    	; 0x1aee <travel+0xe2>
            if (from != to) {
    1a64:	2a 15       	cp	r18, r10
    1a66:	3b 05       	cpc	r19, r11
    1a68:	09 f4       	brne	.+2      	; 0x1a6c <travel+0x60>
    1a6a:	82 c0       	rjmp	.+260    	; 0x1b70 <travel+0x164>
                if (x1 != x2) { 
    1a6c:	0c 15       	cp	r16, r12
    1a6e:	1d 05       	cpc	r17, r13
    1a70:	e9 f0       	breq	.+58     	; 0x1aac <travel+0xa0>
                    if (x1 > x2) // e.g travel(21,11) in this case one has to travel south
    1a72:	c0 16       	cp	r12, r16
    1a74:	d1 06       	cpc	r13, r17
    1a76:	64 f4       	brge	.+24     	; 0x1a90 <travel+0x84>
                        while (x1 != x2) {
                            south(orie);
    1a78:	80 91 48 03 	lds	r24, 0x0348
    1a7c:	90 91 49 03 	lds	r25, 0x0349
    1a80:	0e 94 b7 0a 	call	0x156e	; 0x156e <south>
                            x1--;
    1a84:	01 50       	subi	r16, 0x01	; 1
    1a86:	10 40       	sbci	r17, 0x00	; 0
        int y2 = to % 10;
        if (from == 21 || from == 29 || from == 25 || from == 31 || from == 39 || from == 35) {
            if (from != to) {
                if (x1 != x2) { 
                    if (x1 > x2) // e.g travel(21,11) in this case one has to travel south
                        while (x1 != x2) {
    1a88:	c0 16       	cp	r12, r16
    1a8a:	d1 06       	cpc	r13, r17
    1a8c:	a9 f7       	brne	.-22     	; 0x1a78 <travel+0x6c>
    1a8e:	0e c0       	rjmp	.+28     	; 0x1aac <travel+0xa0>
                            south(orie);
                            x1--;
                        } else if (x2 > x1)// e.g travel(11,21) in this case one has to travel north
    1a90:	0c 15       	cp	r16, r12
    1a92:	1d 05       	cpc	r17, r13
    1a94:	5c f4       	brge	.+22     	; 0x1aac <travel+0xa0>
                        while (x2 != x1) {
                            north(orie);
    1a96:	80 91 48 03 	lds	r24, 0x0348
    1a9a:	90 91 49 03 	lds	r25, 0x0349
    1a9e:	0e 94 79 0a 	call	0x14f2	; 0x14f2 <north>
                            x1++;
    1aa2:	0f 5f       	subi	r16, 0xFF	; 255
    1aa4:	1f 4f       	sbci	r17, 0xFF	; 255
                    if (x1 > x2) // e.g travel(21,11) in this case one has to travel south
                        while (x1 != x2) {
                            south(orie);
                            x1--;
                        } else if (x2 > x1)// e.g travel(11,21) in this case one has to travel north
                        while (x2 != x1) {
    1aa6:	c0 16       	cp	r12, r16
    1aa8:	d1 06       	cpc	r13, r17
    1aaa:	a9 f7       	brne	.-22     	; 0x1a96 <travel+0x8a>
                            north(orie);
                            x1++;
                        }
                }
                if (y1 != y2) {
    1aac:	ce 15       	cp	r28, r14
    1aae:	df 05       	cpc	r29, r15
    1ab0:	09 f4       	brne	.+2      	; 0x1ab4 <travel+0xa8>
    1ab2:	5e c0       	rjmp	.+188    	; 0x1b70 <travel+0x164>
                    if (y1 > y2)// e.g travel(12,11) in this case one has to travel west
    1ab4:	ec 16       	cp	r14, r28
    1ab6:	fd 06       	cpc	r15, r29
    1ab8:	5c f4       	brge	.+22     	; 0x1ad0 <travel+0xc4>
                        while (y1 != y2) {
                            west(orie);
    1aba:	80 91 48 03 	lds	r24, 0x0348
    1abe:	90 91 49 03 	lds	r25, 0x0349
    1ac2:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <west>
                            y1--;
    1ac6:	21 97       	sbiw	r28, 0x01	; 1
                            x1++;
                        }
                }
                if (y1 != y2) {
                    if (y1 > y2)// e.g travel(12,11) in this case one has to travel west
                        while (y1 != y2) {
    1ac8:	ec 16       	cp	r14, r28
    1aca:	fd 06       	cpc	r15, r29
    1acc:	b1 f7       	brne	.-20     	; 0x1aba <travel+0xae>
    1ace:	50 c0       	rjmp	.+160    	; 0x1b70 <travel+0x164>
                            west(orie);
                            y1--;

                        } else if (y2 > y1)// e.g travel(11,12) in this case one has to travel east
    1ad0:	ce 15       	cp	r28, r14
    1ad2:	df 05       	cpc	r29, r15
    1ad4:	0c f0       	brlt	.+2      	; 0x1ad8 <travel+0xcc>
    1ad6:	4c c0       	rjmp	.+152    	; 0x1b70 <travel+0x164>
                        while (y1 != y2) {
                            east(orie);
    1ad8:	80 91 48 03 	lds	r24, 0x0348
    1adc:	90 91 49 03 	lds	r25, 0x0349
    1ae0:	0e 94 33 0b 	call	0x1666	; 0x1666 <east>
                            y1++;
    1ae4:	21 96       	adiw	r28, 0x01	; 1
                        while (y1 != y2) {
                            west(orie);
                            y1--;

                        } else if (y2 > y1)// e.g travel(11,12) in this case one has to travel east
                        while (y1 != y2) {
    1ae6:	ec 16       	cp	r14, r28
    1ae8:	fd 06       	cpc	r15, r29
    1aea:	b1 f7       	brne	.-20     	; 0x1ad8 <travel+0xcc>
    1aec:	41 c0       	rjmp	.+130    	; 0x1b70 <travel+0x164>

                        }
                }
            }
        } else {
            if (from != to) {
    1aee:	2a 15       	cp	r18, r10
    1af0:	3b 05       	cpc	r19, r11
    1af2:	f1 f1       	breq	.+124    	; 0x1b70 <travel+0x164>

                if (y1 != y2) {
    1af4:	c8 17       	cp	r28, r24
    1af6:	d9 07       	cpc	r29, r25
    1af8:	d9 f0       	breq	.+54     	; 0x1b30 <travel+0x124>
                    if (y1 > y2)// e.g travel(12,11) in this case one has to travel west
    1afa:	8c 17       	cp	r24, r28
    1afc:	9d 07       	cpc	r25, r29
    1afe:	5c f4       	brge	.+22     	; 0x1b16 <travel+0x10a>
                        while (y1 != y2) {
                            west(orie);
    1b00:	80 91 48 03 	lds	r24, 0x0348
    1b04:	90 91 49 03 	lds	r25, 0x0349
    1b08:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <west>
                            y1--;
    1b0c:	21 97       	sbiw	r28, 0x01	; 1
        } else {
            if (from != to) {

                if (y1 != y2) {
                    if (y1 > y2)// e.g travel(12,11) in this case one has to travel west
                        while (y1 != y2) {
    1b0e:	ec 16       	cp	r14, r28
    1b10:	fd 06       	cpc	r15, r29
    1b12:	b1 f7       	brne	.-20     	; 0x1b00 <travel+0xf4>
    1b14:	0d c0       	rjmp	.+26     	; 0x1b30 <travel+0x124>
                            west(orie);
                            y1--;

                        } else if (y2 > y1)// e.g travel(11,12) in this case one has to travel east
    1b16:	c8 17       	cp	r28, r24
    1b18:	d9 07       	cpc	r29, r25
    1b1a:	54 f4       	brge	.+20     	; 0x1b30 <travel+0x124>
                        while (y1 != y2) {
                            east(orie);
    1b1c:	80 91 48 03 	lds	r24, 0x0348
    1b20:	90 91 49 03 	lds	r25, 0x0349
    1b24:	0e 94 33 0b 	call	0x1666	; 0x1666 <east>
                            y1++;
    1b28:	21 96       	adiw	r28, 0x01	; 1
                        while (y1 != y2) {
                            west(orie);
                            y1--;

                        } else if (y2 > y1)// e.g travel(11,12) in this case one has to travel east
                        while (y1 != y2) {
    1b2a:	ec 16       	cp	r14, r28
    1b2c:	fd 06       	cpc	r15, r29
    1b2e:	b1 f7       	brne	.-20     	; 0x1b1c <travel+0x110>
                            east(orie);
                            y1++;

                        }
                }
                if (x1 != x2) {
    1b30:	0c 15       	cp	r16, r12
    1b32:	1d 05       	cpc	r17, r13
    1b34:	e9 f0       	breq	.+58     	; 0x1b70 <travel+0x164>
                    if (x1 > x2) // e.g travel(21,11) in this case one has to travel south
    1b36:	c0 16       	cp	r12, r16
    1b38:	d1 06       	cpc	r13, r17
    1b3a:	64 f4       	brge	.+24     	; 0x1b54 <travel+0x148>
                        while (x1 != x2) {
                            south(orie);
    1b3c:	80 91 48 03 	lds	r24, 0x0348
    1b40:	90 91 49 03 	lds	r25, 0x0349
    1b44:	0e 94 b7 0a 	call	0x156e	; 0x156e <south>
                            x1--;
    1b48:	01 50       	subi	r16, 0x01	; 1
    1b4a:	10 40       	sbci	r17, 0x00	; 0

                        }
                }
                if (x1 != x2) {
                    if (x1 > x2) // e.g travel(21,11) in this case one has to travel south
                        while (x1 != x2) {
    1b4c:	c0 16       	cp	r12, r16
    1b4e:	d1 06       	cpc	r13, r17
    1b50:	a9 f7       	brne	.-22     	; 0x1b3c <travel+0x130>
    1b52:	0e c0       	rjmp	.+28     	; 0x1b70 <travel+0x164>
                            south(orie);
                            x1--;
                        } else if (x2 > x1)// e.g travel(11,21) in this case one has to travel north
    1b54:	0c 15       	cp	r16, r12
    1b56:	1d 05       	cpc	r17, r13
    1b58:	5c f4       	brge	.+22     	; 0x1b70 <travel+0x164>
                        while (x2 != x1) {
                            north(orie);
    1b5a:	80 91 48 03 	lds	r24, 0x0348
    1b5e:	90 91 49 03 	lds	r25, 0x0349
    1b62:	0e 94 79 0a 	call	0x14f2	; 0x14f2 <north>
                            x1++;
    1b66:	0f 5f       	subi	r16, 0xFF	; 255
    1b68:	1f 4f       	sbci	r17, 0xFF	; 255
                    if (x1 > x2) // e.g travel(21,11) in this case one has to travel south
                        while (x1 != x2) {
                            south(orie);
                            x1--;
                        } else if (x2 > x1)// e.g travel(11,21) in this case one has to travel north
                        while (x2 != x1) {
    1b6a:	c0 16       	cp	r12, r16
    1b6c:	d1 06       	cpc	r13, r17
    1b6e:	a9 f7       	brne	.-22     	; 0x1b5a <travel+0x14e>
                            x1++;
                        }
                }
            }
        }
    }
    1b70:	df 91       	pop	r29
    1b72:	cf 91       	pop	r28
    1b74:	1f 91       	pop	r17
    1b76:	0f 91       	pop	r16
    1b78:	ff 90       	pop	r15
    1b7a:	ef 90       	pop	r14
    1b7c:	df 90       	pop	r13
    1b7e:	cf 90       	pop	r12
    1b80:	bf 90       	pop	r11
    1b82:	af 90       	pop	r10
    1b84:	08 95       	ret

00001b86 <path_planning>:
    0
};
int co_ordinate_queue[7] = { // stores co-ordinate for the given scanned zone
    0
};
int path_planning(int current_pos) {
    1b86:	2f 92       	push	r2
    1b88:	3f 92       	push	r3
    1b8a:	4f 92       	push	r4
    1b8c:	5f 92       	push	r5
    1b8e:	6f 92       	push	r6
    1b90:	7f 92       	push	r7
    1b92:	8f 92       	push	r8
    1b94:	9f 92       	push	r9
    1b96:	af 92       	push	r10
    1b98:	bf 92       	push	r11
    1b9a:	cf 92       	push	r12
    1b9c:	df 92       	push	r13
    1b9e:	ef 92       	push	r14
    1ba0:	ff 92       	push	r15
    1ba2:	0f 93       	push	r16
    1ba4:	1f 93       	push	r17
    1ba6:	cf 93       	push	r28
    1ba8:	df 93       	push	r29
    1baa:	cd b7       	in	r28, 0x3d	; 61
    1bac:	de b7       	in	r29, 0x3e	; 62
    1bae:	ac 97       	sbiw	r28, 0x2c	; 44
    1bb0:	0f b6       	in	r0, 0x3f	; 63
    1bb2:	f8 94       	cli
    1bb4:	de bf       	out	0x3e, r29	; 62
    1bb6:	0f be       	out	0x3f, r0	; 63
    1bb8:	cd bf       	out	0x3d, r28	; 61
    1bba:	ac 01       	movw	r20, r24

        int head = 0;
        int priority_1[] = { //priority for storing blocks in deposition zone if the bot is near deposition block 1
    1bbc:	de 01       	movw	r26, r28
    1bbe:	11 96       	adiw	r26, 0x01	; 1
    1bc0:	e1 e3       	ldi	r30, 0x31	; 49
    1bc2:	f2 e0       	ldi	r31, 0x02	; 2
    1bc4:	8a e0       	ldi	r24, 0x0A	; 10
    1bc6:	01 90       	ld	r0, Z+
    1bc8:	0d 92       	st	X+, r0
    1bca:	81 50       	subi	r24, 0x01	; 1
    1bcc:	e1 f7       	brne	.-8      	; 0x1bc6 <path_planning+0x40>
            1, 5, 2, 3, 4
        };
        int priority_2[] = { //priority for storing blocks in deposition zone if the bot is near deposition block 2
    1bce:	de 01       	movw	r26, r28
    1bd0:	1b 96       	adiw	r26, 0x0b	; 11
    1bd2:	eb e3       	ldi	r30, 0x3B	; 59
    1bd4:	f2 e0       	ldi	r31, 0x02	; 2
    1bd6:	8a e0       	ldi	r24, 0x0A	; 10
    1bd8:	01 90       	ld	r0, Z+
    1bda:	0d 92       	st	X+, r0
    1bdc:	81 50       	subi	r24, 0x01	; 1
    1bde:	e1 f7       	brne	.-8      	; 0x1bd8 <path_planning+0x52>
            2, 5, 1, 4, 3
        };
        int priority_3[] = { //priority for storing blocks in deposition zone if the bot is near deposition block 3
    1be0:	de 01       	movw	r26, r28
    1be2:	55 96       	adiw	r26, 0x15	; 21
    1be4:	e5 e4       	ldi	r30, 0x45	; 69
    1be6:	f2 e0       	ldi	r31, 0x02	; 2
    1be8:	8a e0       	ldi	r24, 0x0A	; 10
    1bea:	01 90       	ld	r0, Z+
    1bec:	0d 92       	st	X+, r0
    1bee:	81 50       	subi	r24, 0x01	; 1
    1bf0:	e1 f7       	brne	.-8      	; 0x1bea <path_planning+0x64>
            3, 5, 4, 1, 2
        };
        int priority_4[] = { //priority for storing blocks in deposition zone if the bot is near deposition block 4
    1bf2:	de 01       	movw	r26, r28
    1bf4:	5f 96       	adiw	r26, 0x1f	; 31
    1bf6:	ef e4       	ldi	r30, 0x4F	; 79
    1bf8:	f2 e0       	ldi	r31, 0x02	; 2
    1bfa:	8a e0       	ldi	r24, 0x0A	; 10
    1bfc:	01 90       	ld	r0, Z+
    1bfe:	0d 92       	st	X+, r0
    1c00:	81 50       	subi	r24, 0x01	; 1
    1c02:	e1 f7       	brne	.-8      	; 0x1bfc <path_planning+0x76>
                    if (priority_2[j] == info_table[i][2]) {
                        queue[head] = info_table[i][2];
                        co_ordinate_queue[head] = info_table[i][0];
                        head++;
                    }
                } else if (current_pos == 45 && orie == pointingwest) {
    1c04:	20 90 48 03 	lds	r2, 0x0348
    1c08:	30 90 49 03 	lds	r3, 0x0349
    1c0c:	80 91 8d 02 	lds	r24, 0x028D
    1c10:	90 91 8e 02 	lds	r25, 0x028E
    1c14:	9a a7       	lds	r25, 0x7a
    1c16:	89 a7       	lds	r24, 0x79
    1c18:	ee 24       	eor	r14, r14
    1c1a:	ff 24       	eor	r15, r15
int co_ordinate_queue[7] = { // stores co-ordinate for the given scanned zone
    0
};
int path_planning(int current_pos) {

        int head = 0;
    1c1c:	00 e0       	ldi	r16, 0x00	; 0
    1c1e:	10 e0       	ldi	r17, 0x00	; 0
    0
};
int co_ordinate_queue[7] = { // stores co-ordinate for the given scanned zone
    0
};
int path_planning(int current_pos) {
    1c20:	68 e0       	ldi	r22, 0x08	; 8
    1c22:	73 e0       	ldi	r23, 0x03	; 3
                        head++;
					}  
                } else
				{
                    if (priority_3[j] == info_table[i][2]) {
                        queue[head] = info_table[i][2];
    1c24:	0f 2e       	mov	r0, r31
    1c26:	f6 ea       	ldi	r31, 0xA6	; 166
    1c28:	6f 2e       	mov	r6, r31
    1c2a:	f2 e0       	ldi	r31, 0x02	; 2
    1c2c:	7f 2e       	mov	r7, r31
    1c2e:	f0 2d       	mov	r31, r0
                        co_ordinate_queue[head] = info_table[i][0];
    1c30:	0f 2e       	mov	r0, r31
    1c32:	f8 e9       	ldi	r31, 0x98	; 152
    1c34:	4f 2e       	mov	r4, r31
    1c36:	f2 e0       	ldi	r31, 0x02	; 2
    1c38:	5f 2e       	mov	r5, r31
    1c3a:	f0 2d       	mov	r31, r0
    1c3c:	91 c0       	rjmp	.+290    	; 0x1d60 <path_planning+0x1da>
            4, 5, 3, 2, 1
        };
		//store the recently added information from info_table[][] into queue[] and co_ordinate_queue[].
        for (int j = 0; j <= 4; j++) {
            for (int i = 0; i <= 11; i++) {
                if (current_pos == 12) {
    1c3e:	4c 30       	cpi	r20, 0x0C	; 12
    1c40:	51 05       	cpc	r21, r1
    1c42:	f1 f4       	brne	.+60     	; 0x1c80 <path_planning+0xfa>
                    if (priority_1[j] == info_table[i][2]) {
    1c44:	f5 01       	movw	r30, r10
    1c46:	20 81       	ld	r18, Z
    1c48:	31 81       	ldd	r19, Z+1	; 0x01
    1c4a:	14 96       	adiw	r26, 0x04	; 4
    1c4c:	8d 91       	ld	r24, X+
    1c4e:	9c 91       	ld	r25, X
    1c50:	15 97       	sbiw	r26, 0x05	; 5
    1c52:	28 17       	cp	r18, r24
    1c54:	39 07       	cpc	r19, r25
    1c56:	09 f0       	breq	.+2      	; 0x1c5a <path_planning+0xd4>
    1c58:	76 c0       	rjmp	.+236    	; 0x1d46 <path_planning+0x1c0>
                        queue[head] = info_table[i][2];
    1c5a:	c8 01       	movw	r24, r16
    1c5c:	88 0f       	add	r24, r24
    1c5e:	99 1f       	adc	r25, r25
    1c60:	f3 01       	movw	r30, r6
    1c62:	e8 0f       	add	r30, r24
    1c64:	f9 1f       	adc	r31, r25
    1c66:	31 83       	std	Z+1, r19	; 0x01
    1c68:	20 83       	st	Z, r18
                        co_ordinate_queue[head] = info_table[i][0];
    1c6a:	84 0d       	add	r24, r4
    1c6c:	95 1d       	adc	r25, r5
    1c6e:	2d 91       	ld	r18, X+
    1c70:	3c 91       	ld	r19, X
    1c72:	11 97       	sbiw	r26, 0x01	; 1
    1c74:	fc 01       	movw	r30, r24
    1c76:	31 83       	std	Z+1, r19	; 0x01
    1c78:	20 83       	st	Z, r18
                        head++;
    1c7a:	0f 5f       	subi	r16, 0xFF	; 255
    1c7c:	1f 4f       	sbci	r17, 0xFF	; 255
    1c7e:	63 c0       	rjmp	.+198    	; 0x1d46 <path_planning+0x1c0>
                    }
                } else if (current_pos == 18) {
    1c80:	42 31       	cpi	r20, 0x12	; 18
    1c82:	51 05       	cpc	r21, r1
    1c84:	f1 f4       	brne	.+60     	; 0x1cc2 <path_planning+0x13c>
                    if (priority_2[j] == info_table[i][2]) {
    1c86:	f4 01       	movw	r30, r8
    1c88:	20 81       	ld	r18, Z
    1c8a:	31 81       	ldd	r19, Z+1	; 0x01
    1c8c:	14 96       	adiw	r26, 0x04	; 4
    1c8e:	8d 91       	ld	r24, X+
    1c90:	9c 91       	ld	r25, X
    1c92:	15 97       	sbiw	r26, 0x05	; 5
    1c94:	28 17       	cp	r18, r24
    1c96:	39 07       	cpc	r19, r25
    1c98:	09 f0       	breq	.+2      	; 0x1c9c <path_planning+0x116>
    1c9a:	55 c0       	rjmp	.+170    	; 0x1d46 <path_planning+0x1c0>
                        queue[head] = info_table[i][2];
    1c9c:	c8 01       	movw	r24, r16
    1c9e:	88 0f       	add	r24, r24
    1ca0:	99 1f       	adc	r25, r25
    1ca2:	f3 01       	movw	r30, r6
    1ca4:	e8 0f       	add	r30, r24
    1ca6:	f9 1f       	adc	r31, r25
    1ca8:	31 83       	std	Z+1, r19	; 0x01
    1caa:	20 83       	st	Z, r18
                        co_ordinate_queue[head] = info_table[i][0];
    1cac:	84 0d       	add	r24, r4
    1cae:	95 1d       	adc	r25, r5
    1cb0:	2d 91       	ld	r18, X+
    1cb2:	3c 91       	ld	r19, X
    1cb4:	11 97       	sbiw	r26, 0x01	; 1
    1cb6:	fc 01       	movw	r30, r24
    1cb8:	31 83       	std	Z+1, r19	; 0x01
    1cba:	20 83       	st	Z, r18
                        head++;
    1cbc:	0f 5f       	subi	r16, 0xFF	; 255
    1cbe:	1f 4f       	sbci	r17, 0xFF	; 255
    1cc0:	42 c0       	rjmp	.+132    	; 0x1d46 <path_planning+0x1c0>
                    }
                } else if (current_pos == 45 && orie == pointingwest) {
    1cc2:	4d 32       	cpi	r20, 0x2D	; 45
    1cc4:	51 05       	cpc	r21, r1
    1cc6:	19 f5       	brne	.+70     	; 0x1d0e <path_planning+0x188>
    1cc8:	89 a5       	lds	r24, 0x69
    1cca:	9a a5       	lds	r25, 0x6a
    1ccc:	28 16       	cp	r2, r24
    1cce:	39 06       	cpc	r3, r25
    1cd0:	f1 f4       	brne	.+60     	; 0x1d0e <path_planning+0x188>
                    if (priority_4[j] == info_table[i][2]) {
    1cd2:	eb a5       	lds	r30, 0x6b
    1cd4:	fc a5       	lds	r31, 0x6c
    1cd6:	20 81       	ld	r18, Z
    1cd8:	31 81       	ldd	r19, Z+1	; 0x01
    1cda:	14 96       	adiw	r26, 0x04	; 4
    1cdc:	8d 91       	ld	r24, X+
    1cde:	9c 91       	ld	r25, X
    1ce0:	15 97       	sbiw	r26, 0x05	; 5
    1ce2:	28 17       	cp	r18, r24
    1ce4:	39 07       	cpc	r19, r25
    1ce6:	79 f5       	brne	.+94     	; 0x1d46 <path_planning+0x1c0>
                        queue[head] = info_table[i][2];
    1ce8:	c8 01       	movw	r24, r16
    1cea:	88 0f       	add	r24, r24
    1cec:	99 1f       	adc	r25, r25
    1cee:	f3 01       	movw	r30, r6
    1cf0:	e8 0f       	add	r30, r24
    1cf2:	f9 1f       	adc	r31, r25
    1cf4:	31 83       	std	Z+1, r19	; 0x01
    1cf6:	20 83       	st	Z, r18
                        co_ordinate_queue[head] = info_table[i][0];
    1cf8:	84 0d       	add	r24, r4
    1cfa:	95 1d       	adc	r25, r5
    1cfc:	2d 91       	ld	r18, X+
    1cfe:	3c 91       	ld	r19, X
    1d00:	11 97       	sbiw	r26, 0x01	; 1
    1d02:	fc 01       	movw	r30, r24
    1d04:	31 83       	std	Z+1, r19	; 0x01
    1d06:	20 83       	st	Z, r18
                        head++;
    1d08:	0f 5f       	subi	r16, 0xFF	; 255
    1d0a:	1f 4f       	sbci	r17, 0xFF	; 255
    1d0c:	1c c0       	rjmp	.+56     	; 0x1d46 <path_planning+0x1c0>
					}  
                } else
				{
                    if (priority_3[j] == info_table[i][2]) {
    1d0e:	f6 01       	movw	r30, r12
    1d10:	20 81       	ld	r18, Z
    1d12:	31 81       	ldd	r19, Z+1	; 0x01
    1d14:	14 96       	adiw	r26, 0x04	; 4
    1d16:	8d 91       	ld	r24, X+
    1d18:	9c 91       	ld	r25, X
    1d1a:	15 97       	sbiw	r26, 0x05	; 5
    1d1c:	28 17       	cp	r18, r24
    1d1e:	39 07       	cpc	r19, r25
    1d20:	91 f4       	brne	.+36     	; 0x1d46 <path_planning+0x1c0>
                        queue[head] = info_table[i][2];
    1d22:	c8 01       	movw	r24, r16
    1d24:	88 0f       	add	r24, r24
    1d26:	99 1f       	adc	r25, r25
    1d28:	f3 01       	movw	r30, r6
    1d2a:	e8 0f       	add	r30, r24
    1d2c:	f9 1f       	adc	r31, r25
    1d2e:	31 83       	std	Z+1, r19	; 0x01
    1d30:	20 83       	st	Z, r18
                        co_ordinate_queue[head] = info_table[i][0];
    1d32:	84 0d       	add	r24, r4
    1d34:	95 1d       	adc	r25, r5
    1d36:	2d 91       	ld	r18, X+
    1d38:	3c 91       	ld	r19, X
    1d3a:	11 97       	sbiw	r26, 0x01	; 1
    1d3c:	fc 01       	movw	r30, r24
    1d3e:	31 83       	std	Z+1, r19	; 0x01
    1d40:	20 83       	st	Z, r18
                        head++;
    1d42:	0f 5f       	subi	r16, 0xFF	; 255
    1d44:	1f 4f       	sbci	r17, 0xFF	; 255
    1d46:	16 96       	adiw	r26, 0x06	; 6
        int priority_4[] = { //priority for storing blocks in deposition zone if the bot is near deposition block 4
            4, 5, 3, 2, 1
        };
		//store the recently added information from info_table[][] into queue[] and co_ordinate_queue[].
        for (int j = 0; j <= 4; j++) {
            for (int i = 0; i <= 11; i++) {
    1d48:	a6 17       	cp	r26, r22
    1d4a:	b7 07       	cpc	r27, r23
    1d4c:	09 f0       	breq	.+2      	; 0x1d50 <path_planning+0x1ca>
    1d4e:	77 cf       	rjmp	.-274    	; 0x1c3e <path_planning+0xb8>
    1d50:	82 e0       	ldi	r24, 0x02	; 2
    1d52:	90 e0       	ldi	r25, 0x00	; 0
    1d54:	e8 0e       	add	r14, r24
    1d56:	f9 1e       	adc	r15, r25
        };
        int priority_4[] = { //priority for storing blocks in deposition zone if the bot is near deposition block 4
            4, 5, 3, 2, 1
        };
		//store the recently added information from info_table[][] into queue[] and co_ordinate_queue[].
        for (int j = 0; j <= 4; j++) {
    1d58:	9a e0       	ldi	r25, 0x0A	; 10
    1d5a:	e9 16       	cp	r14, r25
    1d5c:	f1 04       	cpc	r15, r1
    1d5e:	21 f1       	breq	.+72     	; 0x1da8 <path_planning+0x222>
    1d60:	a0 ec       	ldi	r26, 0xC0	; 192
    1d62:	b2 e0       	ldi	r27, 0x02	; 2
    0
};
int co_ordinate_queue[7] = { // stores co-ordinate for the given scanned zone
    0
};
int path_planning(int current_pos) {
    1d64:	0f 2e       	mov	r0, r31
    1d66:	f5 e1       	ldi	r31, 0x15	; 21
    1d68:	cf 2e       	mov	r12, r31
    1d6a:	dd 24       	eor	r13, r13
    1d6c:	f0 2d       	mov	r31, r0
    1d6e:	cc 0e       	add	r12, r28
    1d70:	dd 1e       	adc	r13, r29
    1d72:	ce 0c       	add	r12, r14
    1d74:	df 1c       	adc	r13, r15
    1d76:	ef e1       	ldi	r30, 0x1F	; 31
    1d78:	f0 e0       	ldi	r31, 0x00	; 0
    1d7a:	ec 0f       	add	r30, r28
    1d7c:	fd 1f       	adc	r31, r29
    1d7e:	ee 0d       	add	r30, r14
    1d80:	ff 1d       	adc	r31, r15
    1d82:	fc a7       	lds	r31, 0x7c
    1d84:	eb a7       	lds	r30, 0x7b
    1d86:	0f 2e       	mov	r0, r31
    1d88:	fb e0       	ldi	r31, 0x0B	; 11
    1d8a:	8f 2e       	mov	r8, r31
    1d8c:	99 24       	eor	r9, r9
    1d8e:	f0 2d       	mov	r31, r0
    1d90:	8c 0e       	add	r8, r28
    1d92:	9d 1e       	adc	r9, r29
    1d94:	8e 0c       	add	r8, r14
    1d96:	9f 1c       	adc	r9, r15
    1d98:	aa 24       	eor	r10, r10
    1d9a:	bb 24       	eor	r11, r11
    1d9c:	a3 94       	inc	r10
    1d9e:	ac 0e       	add	r10, r28
    1da0:	bd 1e       	adc	r11, r29
    1da2:	ae 0c       	add	r10, r14
    1da4:	bf 1c       	adc	r11, r15
    1da6:	4b cf       	rjmp	.-362    	; 0x1c3e <path_planning+0xb8>
    1da8:	e0 90 08 03 	lds	r14, 0x0308
    1dac:	f0 90 09 03 	lds	r15, 0x0309
    1db0:	a4 ec       	ldi	r26, 0xC4	; 196
    1db2:	b2 e0       	ldi	r27, 0x02	; 2
        };
        int priority_4[] = { //priority for storing blocks in deposition zone if the bot is near deposition block 4
            4, 5, 3, 2, 1
        };
		//store the recently added information from info_table[][] into queue[] and co_ordinate_queue[].
        for (int j = 0; j <= 4; j++) {
    1db4:	60 e0       	ldi	r22, 0x00	; 0
    1db6:	70 e0       	ldi	r23, 0x00	; 0
                        co_ordinate_queue[j] = 0;

                    }
                }

            } else if ((i > 5) && (current_pos / 10 == 4)) {
    1db8:	0f 2e       	mov	r0, r31
    1dba:	f8 ed       	ldi	r31, 0xD8	; 216
    1dbc:	6f 2e       	mov	r6, r31
    1dbe:	ff ef       	ldi	r31, 0xFF	; 255
    1dc0:	7f 2e       	mov	r7, r31
    1dc2:	f0 2d       	mov	r31, r0
    1dc4:	64 0e       	add	r6, r20
    1dc6:	75 1e       	adc	r7, r21
    1dc8:	0f 2e       	mov	r0, r31
    1dca:	f6 ea       	ldi	r31, 0xA6	; 166
    1dcc:	cf 2e       	mov	r12, r31
    1dce:	f2 e0       	ldi	r31, 0x02	; 2
    1dd0:	df 2e       	mov	r13, r31
    1dd2:	f0 2d       	mov	r31, r0
    1dd4:	0f 2e       	mov	r0, r31
    1dd6:	f8 e9       	ldi	r31, 0x98	; 152
    1dd8:	8f 2e       	mov	r8, r31
    1dda:	f2 e0       	ldi	r31, 0x02	; 2
    1ddc:	9f 2e       	mov	r9, r31
    1dde:	f0 2d       	mov	r31, r0
    0
};
int co_ordinate_queue[7] = { // stores co-ordinate for the given scanned zone
    0
};
int path_planning(int current_pos) {
    1de0:	86 01       	movw	r16, r12
    1de2:	0a 5f       	subi	r16, 0xFA	; 250
    1de4:	1f 4f       	sbci	r17, 0xFF	; 255
                    if (info_table[i][2] == 3 || info_table[i][2] == 4 || info_table[i][2] == 5) {
                        if (queue[j] == info_table[i][2]) {
							info_table[i][2] = 0;
                        }
                    } else if (queue[j] == 1 || queue[j] == 2) {
                        leftover_blocks[0][leftover_counter] = queue[j];
    1de6:	0f 2e       	mov	r0, r31
    1de8:	fa e0       	ldi	r31, 0x0A	; 10
    1dea:	4f 2e       	mov	r4, r31
    1dec:	f3 e0       	ldi	r31, 0x03	; 3
    1dee:	5f 2e       	mov	r5, r31
    1df0:	f0 2d       	mov	r31, r0
            }
        }
		
		//after storing it into queue[] and co_ordinate_queue[] erase it from info_table[][].
        for (int i = 0; i <= 11; i++) {
            if (i <= 5 && (current_pos / 10 == 1)) {
    1df2:	0f 2e       	mov	r0, r31
    1df4:	f6 ef       	ldi	r31, 0xF6	; 246
    1df6:	af 2e       	mov	r10, r31
    1df8:	ff ef       	ldi	r31, 0xFF	; 255
    1dfa:	bf 2e       	mov	r11, r31
    1dfc:	f0 2d       	mov	r31, r0
    1dfe:	a4 0e       	add	r10, r20
    1e00:	b5 1e       	adc	r11, r21
    1e02:	13 01       	movw	r2, r6
    1e04:	66 30       	cpi	r22, 0x06	; 6
    1e06:	71 05       	cpc	r23, r1
    1e08:	0c f0       	brlt	.+2      	; 0x1e0c <path_planning+0x286>
    1e0a:	52 c0       	rjmp	.+164    	; 0x1eb0 <path_planning+0x32a>
    1e0c:	fa e0       	ldi	r31, 0x0A	; 10
    1e0e:	af 16       	cp	r10, r31
    1e10:	b1 04       	cpc	r11, r1
    1e12:	08 f0       	brcs	.+2      	; 0x1e16 <path_planning+0x290>
    1e14:	93 c0       	rjmp	.+294    	; 0x1f3c <path_planning+0x3b6>
    1e16:	da a6       	lds	r29, 0xba
    1e18:	c9 a6       	lds	r28, 0xb9
    1e1a:	a4 01       	movw	r20, r8
    0
};
int co_ordinate_queue[7] = { // stores co-ordinate for the given scanned zone
    0
};
int path_planning(int current_pos) {
    1e1c:	3d 01       	movw	r6, r26
		//after storing it into queue[] and co_ordinate_queue[] erase it from info_table[][].
        for (int i = 0; i <= 11; i++) {
            if (i <= 5 && (current_pos / 10 == 1)) {
                for (int j = 0; j <= 2; j++) {

                    if (info_table[i][2] == 1 || info_table[i][2] == 2 || info_table[i][2] == 5) {
    1e1e:	2d 91       	ld	r18, X+
    1e20:	3c 91       	ld	r19, X
    1e22:	11 97       	sbiw	r26, 0x01	; 1
    1e24:	c9 01       	movw	r24, r18
    1e26:	01 97       	sbiw	r24, 0x01	; 1
    1e28:	82 30       	cpi	r24, 0x02	; 2
    1e2a:	91 05       	cpc	r25, r1
    1e2c:	18 f0       	brcs	.+6      	; 0x1e34 <path_planning+0x2ae>
    1e2e:	25 30       	cpi	r18, 0x05	; 5
    1e30:	31 05       	cpc	r19, r1
    1e32:	59 f4       	brne	.+22     	; 0x1e4a <path_planning+0x2c4>
                        if (queue[j] == info_table[i][2]) {
    1e34:	e9 a5       	lds	r30, 0x69
    1e36:	fa a5       	lds	r31, 0x6a
    1e38:	80 81       	ld	r24, Z
    1e3a:	91 81       	ldd	r25, Z+1	; 0x01
    1e3c:	28 17       	cp	r18, r24
    1e3e:	39 07       	cpc	r19, r25
    1e40:	59 f5       	brne	.+86     	; 0x1e98 <path_planning+0x312>
                            info_table[i][2] = 0;
    1e42:	f3 01       	movw	r30, r6
    1e44:	11 82       	std	Z+1, r1	; 0x01
    1e46:	10 82       	st	Z, r1
    1e48:	27 c0       	rjmp	.+78     	; 0x1e98 <path_planning+0x312>
                        }
                    } else if ((queue[j] == 3) || (queue[j] == 4)) {
    1e4a:	e9 a5       	lds	r30, 0x69
    1e4c:	fa a5       	lds	r31, 0x6a
    1e4e:	20 81       	ld	r18, Z
    1e50:	31 81       	ldd	r19, Z+1	; 0x01
    1e52:	c9 01       	movw	r24, r18
    1e54:	03 97       	sbiw	r24, 0x03	; 3
    1e56:	82 30       	cpi	r24, 0x02	; 2
    1e58:	91 05       	cpc	r25, r1
    1e5a:	f0 f4       	brcc	.+60     	; 0x1e98 <path_planning+0x312>
                        leftover_blocks[0][leftover_counter] = queue[j];
    1e5c:	c7 01       	movw	r24, r14
    1e5e:	88 0f       	add	r24, r24
    1e60:	99 1f       	adc	r25, r25
    1e62:	84 0d       	add	r24, r4
    1e64:	95 1d       	adc	r25, r5
    1e66:	fc 01       	movw	r30, r24
    1e68:	31 83       	std	Z+1, r19	; 0x01
    1e6a:	20 83       	st	Z, r18
                        leftover_blocks[1][leftover_counter] = co_ordinate_queue[j];
    1e6c:	c7 01       	movw	r24, r14
    1e6e:	07 96       	adiw	r24, 0x07	; 7
    1e70:	88 0f       	add	r24, r24
    1e72:	99 1f       	adc	r25, r25
    1e74:	84 0d       	add	r24, r4
    1e76:	95 1d       	adc	r25, r5
    1e78:	fa 01       	movw	r30, r20
    1e7a:	20 81       	ld	r18, Z
    1e7c:	31 81       	ldd	r19, Z+1	; 0x01
    1e7e:	fc 01       	movw	r30, r24
    1e80:	31 83       	std	Z+1, r19	; 0x01
    1e82:	20 83       	st	Z, r18
                        leftover_counter++;
    1e84:	08 94       	sec
    1e86:	e1 1c       	adc	r14, r1
    1e88:	f1 1c       	adc	r15, r1
                        queue[j] = 0;
    1e8a:	e9 a5       	lds	r30, 0x69
    1e8c:	fa a5       	lds	r31, 0x6a
    1e8e:	11 82       	std	Z+1, r1	; 0x01
    1e90:	10 82       	st	Z, r1
                        co_ordinate_queue[j] = 0;
    1e92:	fa 01       	movw	r30, r20
    1e94:	11 82       	std	Z+1, r1	; 0x01
    1e96:	10 82       	st	Z, r1
    1e98:	89 a5       	lds	r24, 0x69
    1e9a:	9a a5       	lds	r25, 0x6a
    1e9c:	02 96       	adiw	r24, 0x02	; 2
    1e9e:	9a a7       	lds	r25, 0x7a
    1ea0:	89 a7       	lds	r24, 0x79
    1ea2:	4e 5f       	subi	r20, 0xFE	; 254
    1ea4:	5f 4f       	sbci	r21, 0xFF	; 255
        }
		
		//after storing it into queue[] and co_ordinate_queue[] erase it from info_table[][].
        for (int i = 0; i <= 11; i++) {
            if (i <= 5 && (current_pos / 10 == 1)) {
                for (int j = 0; j <= 2; j++) {
    1ea6:	80 17       	cp	r24, r16
    1ea8:	91 07       	cpc	r25, r17
    1eaa:	09 f0       	breq	.+2      	; 0x1eae <path_planning+0x328>
    1eac:	b8 cf       	rjmp	.-144    	; 0x1e1e <path_planning+0x298>
    1eae:	46 c0       	rjmp	.+140    	; 0x1f3c <path_planning+0x3b6>
                        co_ordinate_queue[j] = 0;

                    }
                }

            } else if ((i > 5) && (current_pos / 10 == 4)) {
    1eb0:	9a e0       	ldi	r25, 0x0A	; 10
    1eb2:	29 16       	cp	r2, r25
    1eb4:	31 04       	cpc	r3, r1
    1eb6:	08 f0       	brcs	.+2      	; 0x1eba <path_planning+0x334>
    1eb8:	41 c0       	rjmp	.+130    	; 0x1f3c <path_planning+0x3b6>
    1eba:	da a6       	lds	r29, 0xba
    1ebc:	c9 a6       	lds	r28, 0xb9
    1ebe:	a4 01       	movw	r20, r8
    0
};
int co_ordinate_queue[7] = { // stores co-ordinate for the given scanned zone
    0
};
int path_planning(int current_pos) {
    1ec0:	3d 01       	movw	r6, r26
                    }
                }

            } else if ((i > 5) && (current_pos / 10 == 4)) {
                for (int j = 0; j <= 2; j++) {
                    if (info_table[i][2] == 3 || info_table[i][2] == 4 || info_table[i][2] == 5) {
    1ec2:	2d 91       	ld	r18, X+
    1ec4:	3c 91       	ld	r19, X
    1ec6:	11 97       	sbiw	r26, 0x01	; 1
    1ec8:	c9 01       	movw	r24, r18
    1eca:	03 97       	sbiw	r24, 0x03	; 3
    1ecc:	83 30       	cpi	r24, 0x03	; 3
    1ece:	91 05       	cpc	r25, r1
    1ed0:	58 f4       	brcc	.+22     	; 0x1ee8 <path_planning+0x362>
                        if (queue[j] == info_table[i][2]) {
    1ed2:	e9 a5       	lds	r30, 0x69
    1ed4:	fa a5       	lds	r31, 0x6a
    1ed6:	80 81       	ld	r24, Z
    1ed8:	91 81       	ldd	r25, Z+1	; 0x01
    1eda:	28 17       	cp	r18, r24
    1edc:	39 07       	cpc	r19, r25
    1ede:	21 f5       	brne	.+72     	; 0x1f28 <path_planning+0x3a2>
							info_table[i][2] = 0;
    1ee0:	f3 01       	movw	r30, r6
    1ee2:	11 82       	std	Z+1, r1	; 0x01
    1ee4:	10 82       	st	Z, r1
    1ee6:	20 c0       	rjmp	.+64     	; 0x1f28 <path_planning+0x3a2>
                        }
                    } else if (queue[j] == 1 || queue[j] == 2) {
    1ee8:	e9 a5       	lds	r30, 0x69
    1eea:	fa a5       	lds	r31, 0x6a
    1eec:	20 81       	ld	r18, Z
    1eee:	31 81       	ldd	r19, Z+1	; 0x01
    1ef0:	c9 01       	movw	r24, r18
    1ef2:	01 97       	sbiw	r24, 0x01	; 1
    1ef4:	82 30       	cpi	r24, 0x02	; 2
    1ef6:	91 05       	cpc	r25, r1
    1ef8:	b8 f4       	brcc	.+46     	; 0x1f28 <path_planning+0x3a2>
                        leftover_blocks[0][leftover_counter] = queue[j];
    1efa:	c7 01       	movw	r24, r14
    1efc:	88 0f       	add	r24, r24
    1efe:	99 1f       	adc	r25, r25
    1f00:	84 0d       	add	r24, r4
    1f02:	95 1d       	adc	r25, r5
    1f04:	fc 01       	movw	r30, r24
    1f06:	31 83       	std	Z+1, r19	; 0x01
    1f08:	20 83       	st	Z, r18
                        leftover_blocks[1][leftover_counter] = co_ordinate_queue[j];
    1f0a:	c7 01       	movw	r24, r14
    1f0c:	07 96       	adiw	r24, 0x07	; 7
    1f0e:	88 0f       	add	r24, r24
    1f10:	99 1f       	adc	r25, r25
    1f12:	84 0d       	add	r24, r4
    1f14:	95 1d       	adc	r25, r5
    1f16:	fa 01       	movw	r30, r20
    1f18:	20 81       	ld	r18, Z
    1f1a:	31 81       	ldd	r19, Z+1	; 0x01
    1f1c:	fc 01       	movw	r30, r24
    1f1e:	31 83       	std	Z+1, r19	; 0x01
    1f20:	20 83       	st	Z, r18
                        leftover_counter++;
    1f22:	08 94       	sec
    1f24:	e1 1c       	adc	r14, r1
    1f26:	f1 1c       	adc	r15, r1
    1f28:	89 a5       	lds	r24, 0x69
    1f2a:	9a a5       	lds	r25, 0x6a
    1f2c:	02 96       	adiw	r24, 0x02	; 2
    1f2e:	9a a7       	lds	r25, 0x7a
    1f30:	89 a7       	lds	r24, 0x79
    1f32:	4e 5f       	subi	r20, 0xFE	; 254
    1f34:	5f 4f       	sbci	r21, 0xFF	; 255

                    }
                }

            } else if ((i > 5) && (current_pos / 10 == 4)) {
                for (int j = 0; j <= 2; j++) {
    1f36:	80 17       	cp	r24, r16
    1f38:	91 07       	cpc	r25, r17
    1f3a:	19 f6       	brne	.-122    	; 0x1ec2 <path_planning+0x33c>
                }
            }
        }
		
		//after storing it into queue[] and co_ordinate_queue[] erase it from info_table[][].
        for (int i = 0; i <= 11; i++) {
    1f3c:	6f 5f       	subi	r22, 0xFF	; 255
    1f3e:	7f 4f       	sbci	r23, 0xFF	; 255
    1f40:	16 96       	adiw	r26, 0x06	; 6
    1f42:	6c 30       	cpi	r22, 0x0C	; 12
    1f44:	71 05       	cpc	r23, r1
    1f46:	09 f0       	breq	.+2      	; 0x1f4a <path_planning+0x3c4>
    1f48:	5d cf       	rjmp	.-326    	; 0x1e04 <path_planning+0x27e>
    1f4a:	f0 92 09 03 	sts	0x0309, r15
    1f4e:	e0 92 08 03 	sts	0x0308, r14
                        leftover_counter++;
                    }
                }
            }
        }
    }
    1f52:	ac 96       	adiw	r28, 0x2c	; 44
    1f54:	0f b6       	in	r0, 0x3f	; 63
    1f56:	f8 94       	cli
    1f58:	de bf       	out	0x3e, r29	; 62
    1f5a:	0f be       	out	0x3f, r0	; 63
    1f5c:	cd bf       	out	0x3d, r28	; 61
    1f5e:	df 91       	pop	r29
    1f60:	cf 91       	pop	r28
    1f62:	1f 91       	pop	r17
    1f64:	0f 91       	pop	r16
    1f66:	ff 90       	pop	r15
    1f68:	ef 90       	pop	r14
    1f6a:	df 90       	pop	r13
    1f6c:	cf 90       	pop	r12
    1f6e:	bf 90       	pop	r11
    1f70:	af 90       	pop	r10
    1f72:	9f 90       	pop	r9
    1f74:	8f 90       	pop	r8
    1f76:	7f 90       	pop	r7
    1f78:	6f 90       	pop	r6
    1f7a:	5f 90       	pop	r5
    1f7c:	4f 90       	pop	r4
    1f7e:	3f 90       	pop	r3
    1f80:	2f 90       	pop	r2
    1f82:	08 95       	ret

00001f84 <create_info_table>:
 * Output: void
 * Logic: 	Initializes info_table[][] with the co-ordinate values.
 * Example Call: create_info_table()
 */
void create_info_table() {
    for (int i = 0; i <= 11; i++) {
    1f84:	e0 ec       	ldi	r30, 0xC0	; 192
    1f86:	f2 e0       	ldi	r31, 0x02	; 2
    1f88:	40 e0       	ldi	r20, 0x00	; 0
    1f8a:	50 e0       	ldi	r21, 0x00	; 0
        if (i <= 2)
    1f8c:	43 30       	cpi	r20, 0x03	; 3
    1f8e:	51 05       	cpc	r21, r1
    1f90:	2c f4       	brge	.+10     	; 0x1f9c <create_info_table+0x18>
 * Input: void
 * Output: void
 * Logic: 	Initializes info_table[][] with the co-ordinate values.
 * Example Call: create_info_table()
 */
void create_info_table() {
    1f92:	ca 01       	movw	r24, r20
    1f94:	0c 96       	adiw	r24, 0x0c	; 12
    for (int i = 0; i <= 11; i++) {
        if (i <= 2)
            info_table[i][0] = (12 + i);
    1f96:	91 83       	std	Z+1, r25	; 0x01
    1f98:	80 83       	st	Z, r24
    1f9a:	18 c0       	rjmp	.+48     	; 0x1fcc <create_info_table+0x48>
 * Input: void
 * Output: void
 * Logic: 	Initializes info_table[][] with the co-ordinate values.
 * Example Call: create_info_table()
 */
void create_info_table() {
    1f9c:	ca 01       	movw	r24, r20
    for (int i = 0; i <= 11; i++) {
        if (i <= 2)
            info_table[i][0] = (12 + i);
        else if (i > 2 && i <= 5)
    1f9e:	9a 01       	movw	r18, r20
    1fa0:	23 50       	subi	r18, 0x03	; 3
    1fa2:	30 40       	sbci	r19, 0x00	; 0
    1fa4:	23 30       	cpi	r18, 0x03	; 3
    1fa6:	31 05       	cpc	r19, r1
    1fa8:	20 f4       	brcc	.+8      	; 0x1fb2 <create_info_table+0x2e>
 * Input: void
 * Output: void
 * Logic: 	Initializes info_table[][] with the co-ordinate values.
 * Example Call: create_info_table()
 */
void create_info_table() {
    1faa:	0d 96       	adiw	r24, 0x0d	; 13
    for (int i = 0; i <= 11; i++) {
        if (i <= 2)
            info_table[i][0] = (12 + i);
        else if (i > 2 && i <= 5)
            info_table[i][0] = (13 + i);
    1fac:	91 83       	std	Z+1, r25	; 0x01
    1fae:	80 83       	st	Z, r24
    1fb0:	0d c0       	rjmp	.+26     	; 0x1fcc <create_info_table+0x48>
        else if (i > 5 && i <= 8)
    1fb2:	9a 01       	movw	r18, r20
    1fb4:	26 50       	subi	r18, 0x06	; 6
    1fb6:	30 40       	sbci	r19, 0x00	; 0
    1fb8:	23 30       	cpi	r18, 0x03	; 3
    1fba:	31 05       	cpc	r19, r1
    1fbc:	20 f4       	brcc	.+8      	; 0x1fc6 <create_info_table+0x42>
 * Input: void
 * Output: void
 * Logic: 	Initializes info_table[][] with the co-ordinate values.
 * Example Call: create_info_table()
 */
void create_info_table() {
    1fbe:	84 96       	adiw	r24, 0x24	; 36
        if (i <= 2)
            info_table[i][0] = (12 + i);
        else if (i > 2 && i <= 5)
            info_table[i][0] = (13 + i);
        else if (i > 5 && i <= 8)
            info_table[i][0] = (36 + i);
    1fc0:	91 83       	std	Z+1, r25	; 0x01
    1fc2:	80 83       	st	Z, r24
    1fc4:	03 c0       	rjmp	.+6      	; 0x1fcc <create_info_table+0x48>
 * Input: void
 * Output: void
 * Logic: 	Initializes info_table[][] with the co-ordinate values.
 * Example Call: create_info_table()
 */
void create_info_table() {
    1fc6:	85 96       	adiw	r24, 0x25	; 37
            info_table[i][0] = (12 + i);
        else if (i > 2 && i <= 5)
            info_table[i][0] = (13 + i);
        else if (i > 5 && i <= 8)
            info_table[i][0] = (36 + i);
        else info_table[i][0] = (37 + i);
    1fc8:	91 83       	std	Z+1, r25	; 0x01
    1fca:	80 83       	st	Z, r24
 * Output: void
 * Logic: 	Initializes info_table[][] with the co-ordinate values.
 * Example Call: create_info_table()
 */
void create_info_table() {
    for (int i = 0; i <= 11; i++) {
    1fcc:	4f 5f       	subi	r20, 0xFF	; 255
    1fce:	5f 4f       	sbci	r21, 0xFF	; 255
    1fd0:	36 96       	adiw	r30, 0x06	; 6
    1fd2:	4c 30       	cpi	r20, 0x0C	; 12
    1fd4:	51 05       	cpc	r21, r1
    1fd6:	d1 f6       	brne	.-76     	; 0x1f8c <create_info_table+0x8>
            info_table[i][0] = (13 + i);
        else if (i > 5 && i <= 8)
            info_table[i][0] = (36 + i);
        else info_table[i][0] = (37 + i);
    }
}
    1fd8:	08 95       	ret

00001fda <zone_scan>:
 *		  While moving from one node to other keep scanning for presence/absence of packages. If the package is present
 *		  then it would sense the color of the current package and store it in info_table[][].
 * Example Call: zone_scan();
 *
 */
void zone_scan() {
    1fda:	ef 92       	push	r14
    1fdc:	ff 92       	push	r15
    1fde:	0f 93       	push	r16
    1fe0:	1f 93       	push	r17
    1fe2:	cf 93       	push	r28
    1fe4:	df 93       	push	r29
    if (current_position == 15) {
    1fe6:	80 91 5c 03 	lds	r24, 0x035C
    1fea:	90 91 5d 03 	lds	r25, 0x035D
    1fee:	8f 30       	cpi	r24, 0x0F	; 15
    1ff0:	91 05       	cpc	r25, r1
    1ff2:	09 f0       	breq	.+2      	; 0x1ff6 <zone_scan+0x1c>
    1ff4:	8d c0       	rjmp	.+282    	; 0x2110 <zone_scan+0x136>
        if (orie == pointingnorth) {
    1ff6:	20 91 48 03 	lds	r18, 0x0348
    1ffa:	30 91 49 03 	lds	r19, 0x0349
    1ffe:	80 91 93 02 	lds	r24, 0x0293
    2002:	90 91 94 02 	lds	r25, 0x0294
    2006:	28 17       	cp	r18, r24
    2008:	39 07       	cpc	r19, r25
    200a:	09 f0       	breq	.+2      	; 0x200e <zone_scan+0x34>
    200c:	70 c0       	rjmp	.+224    	; 0x20ee <zone_scan+0x114>
    200e:	2a c0       	rjmp	.+84     	; 0x2064 <zone_scan+0x8a>
            while (next_position >= 12) {// keep traveling from 15 to 12
                travel(current_position, next_position);
    2010:	80 91 5c 03 	lds	r24, 0x035C
    2014:	90 91 5d 03 	lds	r25, 0x035D
    2018:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <travel>
                current_position = next_position;
    201c:	80 91 67 03 	lds	r24, 0x0367
    2020:	90 91 68 03 	lds	r25, 0x0368
    2024:	90 93 5d 03 	sts	0x035D, r25
    2028:	80 93 5c 03 	sts	0x035C, r24
                next_position--;
    202c:	01 97       	sbiw	r24, 0x01	; 1
    202e:	90 93 68 03 	sts	0x0368, r25
    2032:	80 93 67 03 	sts	0x0367, r24
    2036:	e7 01       	movw	r28, r14
                for (int i = 0; i <= 11; i++) {
                    if (info_table[i][0] == current_position) {
    2038:	88 81       	ld	r24, Y
    203a:	99 81       	ldd	r25, Y+1	; 0x01
    203c:	20 91 5c 03 	lds	r18, 0x035C
    2040:	30 91 5d 03 	lds	r19, 0x035D
    2044:	82 17       	cp	r24, r18
    2046:	93 07       	cpc	r25, r19
    2048:	41 f4       	brne	.+16     	; 0x205a <zone_scan+0x80>
                        info_table[i][1] = color_sense(); // sense block and it's color on each node
    204a:	0e 94 48 07 	call	0xe90	; 0xe90 <color_sense>
    204e:	9b 83       	std	Y+3, r25	; 0x03
    2050:	8a 83       	std	Y+2, r24	; 0x02
                        order_picking(info_table[i][0]);
    2052:	88 81       	ld	r24, Y
    2054:	99 81       	ldd	r25, Y+1	; 0x01
    2056:	0e 94 48 0c 	call	0x1890	; 0x1890 <order_picking>
    205a:	26 96       	adiw	r28, 0x06	; 6
        if (orie == pointingnorth) {
            while (next_position >= 12) {// keep traveling from 15 to 12
                travel(current_position, next_position);
                current_position = next_position;
                next_position--;
                for (int i = 0; i <= 11; i++) {
    205c:	c0 17       	cp	r28, r16
    205e:	d1 07       	cpc	r29, r17
    2060:	59 f7       	brne	.-42     	; 0x2038 <zone_scan+0x5e>
    2062:	08 c0       	rjmp	.+16     	; 0x2074 <zone_scan+0x9a>
    if (current_position == 15) {
        if (orie == pointingnorth) {
            while (next_position >= 12) {// keep traveling from 15 to 12
                travel(current_position, next_position);
                current_position = next_position;
                next_position--;
    2064:	0f 2e       	mov	r0, r31
    2066:	f0 ec       	ldi	r31, 0xC0	; 192
    2068:	ef 2e       	mov	r14, r31
    206a:	f2 e0       	ldi	r31, 0x02	; 2
    206c:	ff 2e       	mov	r15, r31
    206e:	f0 2d       	mov	r31, r0
 *		  While moving from one node to other keep scanning for presence/absence of packages. If the package is present
 *		  then it would sense the color of the current package and store it in info_table[][].
 * Example Call: zone_scan();
 *
 */
void zone_scan() {
    2070:	08 e0       	ldi	r16, 0x08	; 8
    2072:	13 e0       	ldi	r17, 0x03	; 3
    if (current_position == 15) {
        if (orie == pointingnorth) {
            while (next_position >= 12) {// keep traveling from 15 to 12
    2074:	60 91 67 03 	lds	r22, 0x0367
    2078:	70 91 68 03 	lds	r23, 0x0368
    207c:	6c 30       	cpi	r22, 0x0C	; 12
    207e:	71 05       	cpc	r23, r1
    2080:	3c f6       	brge	.-114    	; 0x2010 <zone_scan+0x36>
                    }
                }
            }
        }

        if (orie != pointingnorth) {
    2082:	20 91 48 03 	lds	r18, 0x0348
    2086:	30 91 49 03 	lds	r19, 0x0349
    208a:	80 91 93 02 	lds	r24, 0x0293
    208e:	90 91 94 02 	lds	r25, 0x0294
    2092:	28 17       	cp	r18, r24
    2094:	39 07       	cpc	r19, r25
    2096:	e1 f1       	breq	.+120    	; 0x2110 <zone_scan+0x136>
    2098:	2a c0       	rjmp	.+84     	; 0x20ee <zone_scan+0x114>
            while ((next_position >= 16) && (next_position <= 18)) {// keep traveling from 16 to 18
                travel(current_position, next_position);
    209a:	80 91 5c 03 	lds	r24, 0x035C
    209e:	90 91 5d 03 	lds	r25, 0x035D
    20a2:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <travel>
                current_position = next_position;
    20a6:	80 91 67 03 	lds	r24, 0x0367
    20aa:	90 91 68 03 	lds	r25, 0x0368
    20ae:	90 93 5d 03 	sts	0x035D, r25
    20b2:	80 93 5c 03 	sts	0x035C, r24
                next_position++;
    20b6:	01 96       	adiw	r24, 0x01	; 1
    20b8:	90 93 68 03 	sts	0x0368, r25
    20bc:	80 93 67 03 	sts	0x0367, r24
    20c0:	e7 01       	movw	r28, r14
                for (int i = 0; i <= 11; i++) {
                    if (info_table[i][0] == current_position) {
    20c2:	88 81       	ld	r24, Y
    20c4:	99 81       	ldd	r25, Y+1	; 0x01
    20c6:	20 91 5c 03 	lds	r18, 0x035C
    20ca:	30 91 5d 03 	lds	r19, 0x035D
    20ce:	82 17       	cp	r24, r18
    20d0:	93 07       	cpc	r25, r19
    20d2:	41 f4       	brne	.+16     	; 0x20e4 <zone_scan+0x10a>
                        info_table[i][1] = color_sense(); // sense block and it's color on each node
    20d4:	0e 94 48 07 	call	0xe90	; 0xe90 <color_sense>
    20d8:	9b 83       	std	Y+3, r25	; 0x03
    20da:	8a 83       	std	Y+2, r24	; 0x02
                        order_picking(info_table[i][0]);
    20dc:	88 81       	ld	r24, Y
    20de:	99 81       	ldd	r25, Y+1	; 0x01
    20e0:	0e 94 48 0c 	call	0x1890	; 0x1890 <order_picking>
    20e4:	26 96       	adiw	r28, 0x06	; 6
        if (orie != pointingnorth) {
            while ((next_position >= 16) && (next_position <= 18)) {// keep traveling from 16 to 18
                travel(current_position, next_position);
                current_position = next_position;
                next_position++;
                for (int i = 0; i <= 11; i++) {
    20e6:	c0 17       	cp	r28, r16
    20e8:	d1 07       	cpc	r29, r17
    20ea:	59 f7       	brne	.-42     	; 0x20c2 <zone_scan+0xe8>
    20ec:	08 c0       	rjmp	.+16     	; 0x20fe <zone_scan+0x124>

        if (orie != pointingnorth) {
            while ((next_position >= 16) && (next_position <= 18)) {// keep traveling from 16 to 18
                travel(current_position, next_position);
                current_position = next_position;
                next_position++;
    20ee:	0f 2e       	mov	r0, r31
    20f0:	f0 ec       	ldi	r31, 0xC0	; 192
    20f2:	ef 2e       	mov	r14, r31
    20f4:	f2 e0       	ldi	r31, 0x02	; 2
    20f6:	ff 2e       	mov	r15, r31
    20f8:	f0 2d       	mov	r31, r0
 *		  While moving from one node to other keep scanning for presence/absence of packages. If the package is present
 *		  then it would sense the color of the current package and store it in info_table[][].
 * Example Call: zone_scan();
 *
 */
void zone_scan() {
    20fa:	08 e0       	ldi	r16, 0x08	; 8
    20fc:	13 e0       	ldi	r17, 0x03	; 3
                }
            }
        }

        if (orie != pointingnorth) {
            while ((next_position >= 16) && (next_position <= 18)) {// keep traveling from 16 to 18
    20fe:	60 91 67 03 	lds	r22, 0x0367
    2102:	70 91 68 03 	lds	r23, 0x0368
    2106:	cb 01       	movw	r24, r22
    2108:	40 97       	sbiw	r24, 0x10	; 16
    210a:	83 30       	cpi	r24, 0x03	; 3
    210c:	91 05       	cpc	r25, r1
    210e:	28 f2       	brcs	.-118    	; 0x209a <zone_scan+0xc0>
                }
            }
        }
    }

    if (current_position == 49) {
    2110:	80 91 5c 03 	lds	r24, 0x035C
    2114:	90 91 5d 03 	lds	r25, 0x035D
    2118:	81 33       	cpi	r24, 0x31	; 49
    211a:	91 05       	cpc	r25, r1
    211c:	d9 f5       	brne	.+118    	; 0x2194 <zone_scan+0x1ba>
    211e:	2a c0       	rjmp	.+84     	; 0x2174 <zone_scan+0x19a>
        while (next_position >= 45) {// keep traveling from 49 to 45
            travel(current_position, next_position);
    2120:	80 91 5c 03 	lds	r24, 0x035C
    2124:	90 91 5d 03 	lds	r25, 0x035D
    2128:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <travel>
            current_position = next_position;
    212c:	80 91 67 03 	lds	r24, 0x0367
    2130:	90 91 68 03 	lds	r25, 0x0368
    2134:	90 93 5d 03 	sts	0x035D, r25
    2138:	80 93 5c 03 	sts	0x035C, r24
            next_position--;
    213c:	01 97       	sbiw	r24, 0x01	; 1
    213e:	90 93 68 03 	sts	0x0368, r25
    2142:	80 93 67 03 	sts	0x0367, r24
    2146:	e7 01       	movw	r28, r14
            for (int i = 0; i <= 11; i++) {
                if (info_table[i][0] == current_position) {
    2148:	88 81       	ld	r24, Y
    214a:	99 81       	ldd	r25, Y+1	; 0x01
    214c:	20 91 5c 03 	lds	r18, 0x035C
    2150:	30 91 5d 03 	lds	r19, 0x035D
    2154:	82 17       	cp	r24, r18
    2156:	93 07       	cpc	r25, r19
    2158:	41 f4       	brne	.+16     	; 0x216a <zone_scan+0x190>
                    info_table[i][1] = color_sense(); // sense block and it's color on each node
    215a:	0e 94 48 07 	call	0xe90	; 0xe90 <color_sense>
    215e:	9b 83       	std	Y+3, r25	; 0x03
    2160:	8a 83       	std	Y+2, r24	; 0x02
                    order_picking(info_table[i][0]);
    2162:	88 81       	ld	r24, Y
    2164:	99 81       	ldd	r25, Y+1	; 0x01
    2166:	0e 94 48 0c 	call	0x1890	; 0x1890 <order_picking>
    216a:	26 96       	adiw	r28, 0x06	; 6
    if (current_position == 49) {
        while (next_position >= 45) {// keep traveling from 49 to 45
            travel(current_position, next_position);
            current_position = next_position;
            next_position--;
            for (int i = 0; i <= 11; i++) {
    216c:	c0 17       	cp	r28, r16
    216e:	d1 07       	cpc	r29, r17
    2170:	59 f7       	brne	.-42     	; 0x2148 <zone_scan+0x16e>
    2172:	08 c0       	rjmp	.+16     	; 0x2184 <zone_scan+0x1aa>

    if (current_position == 49) {
        while (next_position >= 45) {// keep traveling from 49 to 45
            travel(current_position, next_position);
            current_position = next_position;
            next_position--;
    2174:	0f 2e       	mov	r0, r31
    2176:	f0 ec       	ldi	r31, 0xC0	; 192
    2178:	ef 2e       	mov	r14, r31
    217a:	f2 e0       	ldi	r31, 0x02	; 2
    217c:	ff 2e       	mov	r15, r31
    217e:	f0 2d       	mov	r31, r0
 *		  While moving from one node to other keep scanning for presence/absence of packages. If the package is present
 *		  then it would sense the color of the current package and store it in info_table[][].
 * Example Call: zone_scan();
 *
 */
void zone_scan() {
    2180:	08 e0       	ldi	r16, 0x08	; 8
    2182:	13 e0       	ldi	r17, 0x03	; 3
            }
        }
    }

    if (current_position == 49) {
        while (next_position >= 45) {// keep traveling from 49 to 45
    2184:	60 91 67 03 	lds	r22, 0x0367
    2188:	70 91 68 03 	lds	r23, 0x0368
    218c:	6d 32       	cpi	r22, 0x2D	; 45
    218e:	71 05       	cpc	r23, r1
    2190:	3c f6       	brge	.-114    	; 0x2120 <zone_scan+0x146>
    2192:	c9 c0       	rjmp	.+402    	; 0x2326 <__stack+0x127>
                    info_table[i][1] = color_sense(); // sense block and it's color on each node
                    order_picking(info_table[i][0]);
                }
            }
        }
    } else if (current_position == 41) {
    2194:	89 32       	cpi	r24, 0x29	; 41
    2196:	91 05       	cpc	r25, r1
    2198:	d9 f5       	brne	.+118    	; 0x2210 <__stack+0x11>
    219a:	2a c0       	rjmp	.+84     	; 0x21f0 <zone_scan+0x216>

        while (next_position <= 45) {// keep traveling from 41 to 45
            travel(current_position, next_position);
    219c:	80 91 5c 03 	lds	r24, 0x035C
    21a0:	90 91 5d 03 	lds	r25, 0x035D
    21a4:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <travel>
            current_position = next_position;
    21a8:	80 91 67 03 	lds	r24, 0x0367
    21ac:	90 91 68 03 	lds	r25, 0x0368
    21b0:	90 93 5d 03 	sts	0x035D, r25
    21b4:	80 93 5c 03 	sts	0x035C, r24
            next_position++;
    21b8:	01 96       	adiw	r24, 0x01	; 1
    21ba:	90 93 68 03 	sts	0x0368, r25
    21be:	80 93 67 03 	sts	0x0367, r24
    21c2:	e7 01       	movw	r28, r14
            for (int i = 0; i <= 11; i++) {
                if (info_table[i][0] == current_position) {
    21c4:	88 81       	ld	r24, Y
    21c6:	99 81       	ldd	r25, Y+1	; 0x01
    21c8:	20 91 5c 03 	lds	r18, 0x035C
    21cc:	30 91 5d 03 	lds	r19, 0x035D
    21d0:	82 17       	cp	r24, r18
    21d2:	93 07       	cpc	r25, r19
    21d4:	41 f4       	brne	.+16     	; 0x21e6 <zone_scan+0x20c>
                    info_table[i][1] = color_sense(); // sense block and it's color on each node
    21d6:	0e 94 48 07 	call	0xe90	; 0xe90 <color_sense>
    21da:	9b 83       	std	Y+3, r25	; 0x03
    21dc:	8a 83       	std	Y+2, r24	; 0x02
                    order_picking(info_table[i][0]);
    21de:	88 81       	ld	r24, Y
    21e0:	99 81       	ldd	r25, Y+1	; 0x01
    21e2:	0e 94 48 0c 	call	0x1890	; 0x1890 <order_picking>
    21e6:	26 96       	adiw	r28, 0x06	; 6

        while (next_position <= 45) {// keep traveling from 41 to 45
            travel(current_position, next_position);
            current_position = next_position;
            next_position++;
            for (int i = 0; i <= 11; i++) {
    21e8:	c0 17       	cp	r28, r16
    21ea:	d1 07       	cpc	r29, r17
    21ec:	59 f7       	brne	.-42     	; 0x21c4 <zone_scan+0x1ea>
    21ee:	08 c0       	rjmp	.+16     	; 0x2200 <__stack+0x1>
    } else if (current_position == 41) {

        while (next_position <= 45) {// keep traveling from 41 to 45
            travel(current_position, next_position);
            current_position = next_position;
            next_position++;
    21f0:	0f 2e       	mov	r0, r31
    21f2:	f0 ec       	ldi	r31, 0xC0	; 192
    21f4:	ef 2e       	mov	r14, r31
    21f6:	f2 e0       	ldi	r31, 0x02	; 2
    21f8:	ff 2e       	mov	r15, r31
    21fa:	f0 2d       	mov	r31, r0
 *		  While moving from one node to other keep scanning for presence/absence of packages. If the package is present
 *		  then it would sense the color of the current package and store it in info_table[][].
 * Example Call: zone_scan();
 *
 */
void zone_scan() {
    21fc:	08 e0       	ldi	r16, 0x08	; 8
    21fe:	13 e0       	ldi	r17, 0x03	; 3
                }
            }
        }
    } else if (current_position == 41) {

        while (next_position <= 45) {// keep traveling from 41 to 45
    2200:	60 91 67 03 	lds	r22, 0x0367
    2204:	70 91 68 03 	lds	r23, 0x0368
    2208:	6e 32       	cpi	r22, 0x2E	; 46
    220a:	71 05       	cpc	r23, r1
    220c:	3c f2       	brlt	.-114    	; 0x219c <zone_scan+0x1c2>
    220e:	8b c0       	rjmp	.+278    	; 0x2326 <__stack+0x127>
                    info_table[i][1] = color_sense(); // sense block and it's color on each node
                    order_picking(info_table[i][0]);
                }
            }
        }
    } else if ((current_position == 45) && (orie == pointingwest)) {
    2210:	8d 32       	cpi	r24, 0x2D	; 45
    2212:	91 05       	cpc	r25, r1
    2214:	09 f0       	breq	.+2      	; 0x2218 <__stack+0x19>
    2216:	87 c0       	rjmp	.+270    	; 0x2326 <__stack+0x127>
    2218:	80 91 48 03 	lds	r24, 0x0348
    221c:	90 91 49 03 	lds	r25, 0x0349
    2220:	20 91 8d 02 	lds	r18, 0x028D
    2224:	30 91 8e 02 	lds	r19, 0x028E
    2228:	82 17       	cp	r24, r18
    222a:	93 07       	cpc	r25, r19
    222c:	d9 f5       	brne	.+118    	; 0x22a4 <__stack+0xa5>
    222e:	2a c0       	rjmp	.+84     	; 0x2284 <__stack+0x85>
        while (next_position >= 41) {// keep traveling from 45 to 41
            travel(current_position, next_position);
    2230:	80 91 5c 03 	lds	r24, 0x035C
    2234:	90 91 5d 03 	lds	r25, 0x035D
    2238:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <travel>
            current_position = next_position;
    223c:	80 91 67 03 	lds	r24, 0x0367
    2240:	90 91 68 03 	lds	r25, 0x0368
    2244:	90 93 5d 03 	sts	0x035D, r25
    2248:	80 93 5c 03 	sts	0x035C, r24
            next_position--;
    224c:	01 97       	sbiw	r24, 0x01	; 1
    224e:	90 93 68 03 	sts	0x0368, r25
    2252:	80 93 67 03 	sts	0x0367, r24
    2256:	e7 01       	movw	r28, r14
            for (int i = 0; i <= 11; i++) {
                if (info_table[i][0] == current_position) {
    2258:	88 81       	ld	r24, Y
    225a:	99 81       	ldd	r25, Y+1	; 0x01
    225c:	20 91 5c 03 	lds	r18, 0x035C
    2260:	30 91 5d 03 	lds	r19, 0x035D
    2264:	82 17       	cp	r24, r18
    2266:	93 07       	cpc	r25, r19
    2268:	41 f4       	brne	.+16     	; 0x227a <__stack+0x7b>
                    info_table[i][1] = color_sense(); // sense block and it's color on each node
    226a:	0e 94 48 07 	call	0xe90	; 0xe90 <color_sense>
    226e:	9b 83       	std	Y+3, r25	; 0x03
    2270:	8a 83       	std	Y+2, r24	; 0x02
                    order_picking(info_table[i][0]);
    2272:	88 81       	ld	r24, Y
    2274:	99 81       	ldd	r25, Y+1	; 0x01
    2276:	0e 94 48 0c 	call	0x1890	; 0x1890 <order_picking>
    227a:	26 96       	adiw	r28, 0x06	; 6
    } else if ((current_position == 45) && (orie == pointingwest)) {
        while (next_position >= 41) {// keep traveling from 45 to 41
            travel(current_position, next_position);
            current_position = next_position;
            next_position--;
            for (int i = 0; i <= 11; i++) {
    227c:	c0 17       	cp	r28, r16
    227e:	d1 07       	cpc	r29, r17
    2280:	59 f7       	brne	.-42     	; 0x2258 <__stack+0x59>
    2282:	08 c0       	rjmp	.+16     	; 0x2294 <__stack+0x95>
        }
    } else if ((current_position == 45) && (orie == pointingwest)) {
        while (next_position >= 41) {// keep traveling from 45 to 41
            travel(current_position, next_position);
            current_position = next_position;
            next_position--;
    2284:	0f 2e       	mov	r0, r31
    2286:	f0 ec       	ldi	r31, 0xC0	; 192
    2288:	ef 2e       	mov	r14, r31
    228a:	f2 e0       	ldi	r31, 0x02	; 2
    228c:	ff 2e       	mov	r15, r31
    228e:	f0 2d       	mov	r31, r0
 *		  While moving from one node to other keep scanning for presence/absence of packages. If the package is present
 *		  then it would sense the color of the current package and store it in info_table[][].
 * Example Call: zone_scan();
 *
 */
void zone_scan() {
    2290:	08 e0       	ldi	r16, 0x08	; 8
    2292:	13 e0       	ldi	r17, 0x03	; 3
                    order_picking(info_table[i][0]);
                }
            }
        }
    } else if ((current_position == 45) && (orie == pointingwest)) {
        while (next_position >= 41) {// keep traveling from 45 to 41
    2294:	60 91 67 03 	lds	r22, 0x0367
    2298:	70 91 68 03 	lds	r23, 0x0368
    229c:	69 32       	cpi	r22, 0x29	; 41
    229e:	71 05       	cpc	r23, r1
    22a0:	3c f6       	brge	.-114    	; 0x2230 <__stack+0x31>
    22a2:	41 c0       	rjmp	.+130    	; 0x2326 <__stack+0x127>
                    info_table[i][1] = color_sense(); // sense block and it's color on each node
                    order_picking(info_table[i][0]);
                }
            }
        }
    } else if ((current_position == 45) && (orie == pointingeast)) {
    22a4:	20 91 91 02 	lds	r18, 0x0291
    22a8:	30 91 92 02 	lds	r19, 0x0292
    22ac:	82 17       	cp	r24, r18
    22ae:	93 07       	cpc	r25, r19
    22b0:	d1 f5       	brne	.+116    	; 0x2326 <__stack+0x127>
    22b2:	2a c0       	rjmp	.+84     	; 0x2308 <__stack+0x109>
        while (next_position <= 48) {// keep traveling from 45 to 48
            travel(current_position, next_position);
    22b4:	80 91 5c 03 	lds	r24, 0x035C
    22b8:	90 91 5d 03 	lds	r25, 0x035D
    22bc:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <travel>
            current_position = next_position;
    22c0:	80 91 67 03 	lds	r24, 0x0367
    22c4:	90 91 68 03 	lds	r25, 0x0368
    22c8:	90 93 5d 03 	sts	0x035D, r25
    22cc:	80 93 5c 03 	sts	0x035C, r24
            next_position++;
    22d0:	01 96       	adiw	r24, 0x01	; 1
    22d2:	90 93 68 03 	sts	0x0368, r25
    22d6:	80 93 67 03 	sts	0x0367, r24
    22da:	e7 01       	movw	r28, r14
            for (int i = 0; i <= 11; i++) {
                if (info_table[i][0] == current_position) {
    22dc:	88 81       	ld	r24, Y
    22de:	99 81       	ldd	r25, Y+1	; 0x01
    22e0:	20 91 5c 03 	lds	r18, 0x035C
    22e4:	30 91 5d 03 	lds	r19, 0x035D
    22e8:	82 17       	cp	r24, r18
    22ea:	93 07       	cpc	r25, r19
    22ec:	41 f4       	brne	.+16     	; 0x22fe <__stack+0xff>
                    info_table[i][1] = color_sense(); // sense block and it's color on each node
    22ee:	0e 94 48 07 	call	0xe90	; 0xe90 <color_sense>
    22f2:	9b 83       	std	Y+3, r25	; 0x03
    22f4:	8a 83       	std	Y+2, r24	; 0x02
                    order_picking(info_table[i][0]);
    22f6:	88 81       	ld	r24, Y
    22f8:	99 81       	ldd	r25, Y+1	; 0x01
    22fa:	0e 94 48 0c 	call	0x1890	; 0x1890 <order_picking>
    22fe:	26 96       	adiw	r28, 0x06	; 6
    } else if ((current_position == 45) && (orie == pointingeast)) {
        while (next_position <= 48) {// keep traveling from 45 to 48
            travel(current_position, next_position);
            current_position = next_position;
            next_position++;
            for (int i = 0; i <= 11; i++) {
    2300:	c0 17       	cp	r28, r16
    2302:	d1 07       	cpc	r29, r17
    2304:	59 f7       	brne	.-42     	; 0x22dc <__stack+0xdd>
    2306:	08 c0       	rjmp	.+16     	; 0x2318 <__stack+0x119>
        }
    } else if ((current_position == 45) && (orie == pointingeast)) {
        while (next_position <= 48) {// keep traveling from 45 to 48
            travel(current_position, next_position);
            current_position = next_position;
            next_position++;
    2308:	0f 2e       	mov	r0, r31
    230a:	f0 ec       	ldi	r31, 0xC0	; 192
    230c:	ef 2e       	mov	r14, r31
    230e:	f2 e0       	ldi	r31, 0x02	; 2
    2310:	ff 2e       	mov	r15, r31
    2312:	f0 2d       	mov	r31, r0
 *		  While moving from one node to other keep scanning for presence/absence of packages. If the package is present
 *		  then it would sense the color of the current package and store it in info_table[][].
 * Example Call: zone_scan();
 *
 */
void zone_scan() {
    2314:	08 e0       	ldi	r16, 0x08	; 8
    2316:	13 e0       	ldi	r17, 0x03	; 3
                    order_picking(info_table[i][0]);
                }
            }
        }
    } else if ((current_position == 45) && (orie == pointingeast)) {
        while (next_position <= 48) {// keep traveling from 45 to 48
    2318:	60 91 67 03 	lds	r22, 0x0367
    231c:	70 91 68 03 	lds	r23, 0x0368
    2320:	61 33       	cpi	r22, 0x31	; 49
    2322:	71 05       	cpc	r23, r1
    2324:	3c f2       	brlt	.-114    	; 0x22b4 <__stack+0xb5>
                    order_picking(info_table[i][0]);
                }
            }
        }
    }
}
    2326:	df 91       	pop	r29
    2328:	cf 91       	pop	r28
    232a:	1f 91       	pop	r17
    232c:	0f 91       	pop	r16
    232e:	ff 90       	pop	r15
    2330:	ef 90       	pop	r14
    2332:	08 95       	ret

00002334 <change_orientation>:
 * Logic: Changes orientation of the robot on 180 degree turn
 * Example Call: change_orientation();
 *				 change_orientation();
 */
void change_orientation() {
    if (orie == pointingnorth)
    2334:	80 91 48 03 	lds	r24, 0x0348
    2338:	90 91 49 03 	lds	r25, 0x0349
    233c:	20 91 93 02 	lds	r18, 0x0293
    2340:	30 91 94 02 	lds	r19, 0x0294
    2344:	82 17       	cp	r24, r18
    2346:	93 07       	cpc	r25, r19
    2348:	49 f4       	brne	.+18     	; 0x235c <change_orientation+0x28>
        orie = pointingsouth;
    234a:	80 91 8f 02 	lds	r24, 0x028F
    234e:	90 91 90 02 	lds	r25, 0x0290
    2352:	90 93 49 03 	sts	0x0349, r25
    2356:	80 93 48 03 	sts	0x0348, r24
    235a:	08 95       	ret
    else if (orie == pointingsouth)
    235c:	40 91 8f 02 	lds	r20, 0x028F
    2360:	50 91 90 02 	lds	r21, 0x0290
    2364:	84 17       	cp	r24, r20
    2366:	95 07       	cpc	r25, r21
    2368:	29 f4       	brne	.+10     	; 0x2374 <change_orientation+0x40>
        orie = pointingnorth;
    236a:	30 93 49 03 	sts	0x0349, r19
    236e:	20 93 48 03 	sts	0x0348, r18
    2372:	08 95       	ret
    else if (orie == pointingwest)
    2374:	20 91 8d 02 	lds	r18, 0x028D
    2378:	30 91 8e 02 	lds	r19, 0x028E
    237c:	82 17       	cp	r24, r18
    237e:	93 07       	cpc	r25, r19
    2380:	49 f4       	brne	.+18     	; 0x2394 <change_orientation+0x60>
        orie = pointingeast;
    2382:	80 91 91 02 	lds	r24, 0x0291
    2386:	90 91 92 02 	lds	r25, 0x0292
    238a:	90 93 49 03 	sts	0x0349, r25
    238e:	80 93 48 03 	sts	0x0348, r24
    2392:	08 95       	ret
    else if (orie == pointingeast)
    2394:	40 91 91 02 	lds	r20, 0x0291
    2398:	50 91 92 02 	lds	r21, 0x0292
    239c:	84 17       	cp	r24, r20
    239e:	95 07       	cpc	r25, r21
    23a0:	21 f4       	brne	.+8      	; 0x23aa <change_orientation+0x76>
        orie = pointingwest;
    23a2:	30 93 49 03 	sts	0x0349, r19
    23a6:	20 93 48 03 	sts	0x0348, r18
    23aa:	08 95       	ret

000023ac <place_package>:
 *		  Pick up package
 *		  Travel to the deposition zone
 * Example Call: place_package();
 *				 place_package();
 */
void place_package() {
    23ac:	4f 92       	push	r4
    23ae:	5f 92       	push	r5
    23b0:	6f 92       	push	r6
    23b2:	7f 92       	push	r7
    23b4:	8f 92       	push	r8
    23b6:	9f 92       	push	r9
    23b8:	af 92       	push	r10
    23ba:	bf 92       	push	r11
    23bc:	df 92       	push	r13
    23be:	ef 92       	push	r14
    23c0:	ff 92       	push	r15
    23c2:	0f 93       	push	r16
    23c4:	1f 93       	push	r17
    23c6:	cf 93       	push	r28
    23c8:	df 93       	push	r29
    23ca:	cd b7       	in	r28, 0x3d	; 61
    23cc:	de b7       	in	r29, 0x3e	; 62
    23ce:	2c 97       	sbiw	r28, 0x0c	; 12
    23d0:	0f b6       	in	r0, 0x3f	; 63
    23d2:	f8 94       	cli
    23d4:	de bf       	out	0x3e, r29	; 62
    23d6:	0f be       	out	0x3f, r0	; 63
    23d8:	cd bf       	out	0x3d, r28	; 61
    
    char lower_boundary[6] = {
    23da:	de 01       	movw	r26, r28
    23dc:	11 96       	adiw	r26, 0x01	; 1
    23de:	e9 e5       	ldi	r30, 0x59	; 89
    23e0:	f2 e0       	ldi	r31, 0x02	; 2
    23e2:	86 e0       	ldi	r24, 0x06	; 6
    23e4:	01 90       	ld	r0, Z+
    23e6:	0d 92       	st	X+, r0
    23e8:	81 50       	subi	r24, 0x01	; 1
    23ea:	e1 f7       	brne	.-8      	; 0x23e4 <place_package+0x38>
        0, 13, 17, 31, 39, 25
    };
    char upper_boundary[6] = {
    23ec:	de 01       	movw	r26, r28
    23ee:	17 96       	adiw	r26, 0x07	; 7
    23f0:	ef e5       	ldi	r30, 0x5F	; 95
    23f2:	f2 e0       	ldi	r31, 0x02	; 2
    23f4:	86 e0       	ldi	r24, 0x06	; 6
    23f6:	01 90       	ld	r0, Z+
    23f8:	0d 92       	st	X+, r0
    23fa:	81 50       	subi	r24, 0x01	; 1
    23fc:	e1 f7       	brne	.-8      	; 0x23f6 <place_package+0x4a>
    23fe:	0f 2e       	mov	r0, r31
    2400:	f8 e9       	ldi	r31, 0x98	; 152
    2402:	af 2e       	mov	r10, r31
    2404:	f2 e0       	ldi	r31, 0x02	; 2
    2406:	bf 2e       	mov	r11, r31
    2408:	f0 2d       	mov	r31, r0
    240a:	0f 2e       	mov	r0, r31
    240c:	f6 ea       	ldi	r31, 0xA6	; 166
    240e:	8f 2e       	mov	r8, r31
    2410:	f2 e0       	ldi	r31, 0x02	; 2
    2412:	9f 2e       	mov	r9, r31
    2414:	f0 2d       	mov	r31, r0
 *		  Pick up package
 *		  Travel to the deposition zone
 * Example Call: place_package();
 *				 place_package();
 */
void place_package() {
    2416:	0f 2e       	mov	r0, r31
    2418:	f6 e0       	ldi	r31, 0x06	; 6
    241a:	6f 2e       	mov	r6, r31
    241c:	77 24       	eor	r7, r7
    241e:	f0 2d       	mov	r31, r0
    2420:	6a 0c       	add	r6, r10
    2422:	7b 1c       	adc	r7, r11

            if ((orie == pointingeast) && ((next_position % 10) < (current_position % 10))) {
                velocity(220, 223);
                left_degrees(191);
                change_orientation();
            } else if (((next_position % 10) > (current_position % 10)) && (orie == pointingwest)) {
    2424:	0f 2e       	mov	r0, r31
    2426:	fa e0       	ldi	r31, 0x0A	; 10
    2428:	ef 2e       	mov	r14, r31
    242a:	ff 24       	eor	r15, r15
    242c:	f0 2d       	mov	r31, r0
            follow();
            velocity(220, 223);
            left_degrees(191);
            change_orientation();
        }
		drop(blocks_in[queue[i]]);
    242e:	0f 2e       	mov	r0, r31
    2430:	f4 eb       	ldi	r31, 0xB4	; 180
    2432:	4f 2e       	mov	r4, r31
    2434:	f2 e0       	ldi	r31, 0x02	; 2
    2436:	5f 2e       	mov	r5, r31
    2438:	f0 2d       	mov	r31, r0
        0, 21, 29, 43, 47, 35
    };
    char zone_coordinate;
    int block_counter = 0;
    for (int i = 0; i <= 2; i++) {
        forward();
    243a:	0e 94 35 03 	call	0x66a	; 0x66a <forward>
        velocity(252, 255);
    243e:	8c ef       	ldi	r24, 0xFC	; 252
    2440:	6f ef       	ldi	r22, 0xFF	; 255
    2442:	0e 94 2a 03 	call	0x654	; 0x654 <velocity>
		//calculate position of the package 
        if (co_ordinate_queue[i] >= 12 && co_ordinate_queue[i] <= 18)
    2446:	d5 01       	movw	r26, r10
    2448:	2d 91       	ld	r18, X+
    244a:	3d 91       	ld	r19, X+
    244c:	5d 01       	movw	r10, r26
    244e:	c9 01       	movw	r24, r18
    2450:	0c 97       	sbiw	r24, 0x0c	; 12
    2452:	87 30       	cpi	r24, 0x07	; 7
    2454:	91 05       	cpc	r25, r1
    2456:	60 f4       	brcc	.+24     	; 0x2470 <place_package+0xc4>
            zone_coordinate = lower_boundary[queue[i]];
    2458:	f4 01       	movw	r30, r8
    245a:	80 81       	ld	r24, Z
    245c:	91 81       	ldd	r25, Z+1	; 0x01
    245e:	41 e0       	ldi	r20, 0x01	; 1
    2460:	50 e0       	ldi	r21, 0x00	; 0
    2462:	4c 0f       	add	r20, r28
    2464:	5d 1f       	adc	r21, r29
    2466:	84 0f       	add	r24, r20
    2468:	95 1f       	adc	r25, r21
    246a:	dc 01       	movw	r26, r24
    246c:	dc 90       	ld	r13, X
    246e:	10 c0       	rjmp	.+32     	; 0x2490 <place_package+0xe4>
        else if (co_ordinate_queue[i] >= 42 && co_ordinate_queue[i] <= 48)
    2470:	c9 01       	movw	r24, r18
    2472:	8a 97       	sbiw	r24, 0x2a	; 42
    2474:	87 30       	cpi	r24, 0x07	; 7
    2476:	91 05       	cpc	r25, r1
    2478:	58 f4       	brcc	.+22     	; 0x2490 <place_package+0xe4>
            zone_coordinate = upper_boundary[queue[i]];
    247a:	f4 01       	movw	r30, r8
    247c:	80 81       	ld	r24, Z
    247e:	91 81       	ldd	r25, Z+1	; 0x01
    2480:	47 e0       	ldi	r20, 0x07	; 7
    2482:	50 e0       	ldi	r21, 0x00	; 0
    2484:	4c 0f       	add	r20, r28
    2486:	5d 1f       	adc	r21, r29
    2488:	84 0f       	add	r24, r20
    248a:	95 1f       	adc	r25, r21
    248c:	dc 01       	movw	r26, r24
    248e:	dc 90       	ld	r13, X
        if (co_ordinate_queue[i] != 0)
    2490:	21 15       	cp	r18, r1
    2492:	31 05       	cpc	r19, r1
    2494:	09 f4       	brne	.+2      	; 0x2498 <place_package+0xec>
    2496:	8e c1       	rjmp	.+796    	; 0x27b4 <place_package+0x408>
            next_position = co_ordinate_queue[i];
    2498:	30 93 68 03 	sts	0x0368, r19
    249c:	20 93 67 03 	sts	0x0367, r18
        else
            break;
        stop();
    24a0:	0e 94 45 03 	call	0x68a	; 0x68a <stop>
        
        if ((current_position >= 12 && current_position <= 18) || (current_position >= 42 && current_position <= 48)) {
    24a4:	e0 91 5c 03 	lds	r30, 0x035C
    24a8:	f0 91 5d 03 	lds	r31, 0x035D
    24ac:	cf 01       	movw	r24, r30
    24ae:	0c 97       	sbiw	r24, 0x0c	; 12
    24b0:	87 30       	cpi	r24, 0x07	; 7
    24b2:	91 05       	cpc	r25, r1
    24b4:	30 f0       	brcs	.+12     	; 0x24c2 <place_package+0x116>
    24b6:	cf 01       	movw	r24, r30
    24b8:	8a 97       	sbiw	r24, 0x2a	; 42
    24ba:	87 30       	cpi	r24, 0x07	; 7
    24bc:	91 05       	cpc	r25, r1
    24be:	08 f0       	brcs	.+2      	; 0x24c2 <place_package+0x116>
    24c0:	45 c0       	rjmp	.+138    	; 0x254c <place_package+0x1a0>

            if ((orie == pointingeast) && ((next_position % 10) < (current_position % 10))) {
    24c2:	00 91 48 03 	lds	r16, 0x0348
    24c6:	10 91 49 03 	lds	r17, 0x0349
    24ca:	80 91 91 02 	lds	r24, 0x0291
    24ce:	90 91 92 02 	lds	r25, 0x0292
    24d2:	08 17       	cp	r16, r24
    24d4:	19 07       	cpc	r17, r25
    24d6:	d1 f4       	brne	.+52     	; 0x250c <place_package+0x160>
    24d8:	80 91 67 03 	lds	r24, 0x0367
    24dc:	90 91 68 03 	lds	r25, 0x0368
    24e0:	b7 01       	movw	r22, r14
    24e2:	0e 94 70 1b 	call	0x36e0	; 0x36e0 <__divmodhi4>
    24e6:	9c 01       	movw	r18, r24
    24e8:	cf 01       	movw	r24, r30
    24ea:	b7 01       	movw	r22, r14
    24ec:	0e 94 70 1b 	call	0x36e0	; 0x36e0 <__divmodhi4>
    24f0:	28 17       	cp	r18, r24
    24f2:	39 07       	cpc	r19, r25
    24f4:	5c f4       	brge	.+22     	; 0x250c <place_package+0x160>
                velocity(220, 223);
    24f6:	8c ed       	ldi	r24, 0xDC	; 220
    24f8:	6f ed       	ldi	r22, 0xDF	; 223
    24fa:	0e 94 2a 03 	call	0x654	; 0x654 <velocity>
                left_degrees(191);
    24fe:	8f eb       	ldi	r24, 0xBF	; 191
    2500:	90 e0       	ldi	r25, 0x00	; 0
    2502:	0e 94 20 04 	call	0x840	; 0x840 <left_degrees>
                change_orientation();
    2506:	0e 94 9a 11 	call	0x2334	; 0x2334 <change_orientation>
    250a:	20 c0       	rjmp	.+64     	; 0x254c <place_package+0x1a0>
            } else if (((next_position % 10) > (current_position % 10)) && (orie == pointingwest)) {
    250c:	80 91 67 03 	lds	r24, 0x0367
    2510:	90 91 68 03 	lds	r25, 0x0368
    2514:	b7 01       	movw	r22, r14
    2516:	0e 94 70 1b 	call	0x36e0	; 0x36e0 <__divmodhi4>
    251a:	9c 01       	movw	r18, r24
    251c:	cf 01       	movw	r24, r30
    251e:	b7 01       	movw	r22, r14
    2520:	0e 94 70 1b 	call	0x36e0	; 0x36e0 <__divmodhi4>
    2524:	82 17       	cp	r24, r18
    2526:	93 07       	cpc	r25, r19
    2528:	8c f4       	brge	.+34     	; 0x254c <place_package+0x1a0>
    252a:	80 91 8d 02 	lds	r24, 0x028D
    252e:	90 91 8e 02 	lds	r25, 0x028E
    2532:	08 17       	cp	r16, r24
    2534:	19 07       	cpc	r17, r25
    2536:	51 f4       	brne	.+20     	; 0x254c <place_package+0x1a0>
                velocity(220, 223);
    2538:	8c ed       	ldi	r24, 0xDC	; 220
    253a:	6f ed       	ldi	r22, 0xDF	; 223
    253c:	0e 94 2a 03 	call	0x654	; 0x654 <velocity>
                left_degrees(191);
    2540:	8f eb       	ldi	r24, 0xBF	; 191
    2542:	90 e0       	ldi	r25, 0x00	; 0
    2544:	0e 94 20 04 	call	0x840	; 0x840 <left_degrees>
                change_orientation();
    2548:	0e 94 9a 11 	call	0x2334	; 0x2334 <change_orientation>
            }
        }

        stop();
    254c:	0e 94 45 03 	call	0x68a	; 0x68a <stop>
		//travel from current_position to package position
        travel(current_position, next_position);
    2550:	60 91 67 03 	lds	r22, 0x0367
    2554:	70 91 68 03 	lds	r23, 0x0368
    2558:	80 91 5c 03 	lds	r24, 0x035C
    255c:	90 91 5d 03 	lds	r25, 0x035D
    2560:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <travel>
        current_position = next_position;
    2564:	90 91 67 03 	lds	r25, 0x0367
    2568:	80 91 68 03 	lds	r24, 0x0368
    256c:	90 93 5c 03 	sts	0x035C, r25
    2570:	80 93 5d 03 	sts	0x035D, r24
		// align to center of the node
        if ((current_position >= 12) && (current_position <= 18)) {
    2574:	29 2f       	mov	r18, r25
    2576:	38 2f       	mov	r19, r24
    2578:	c9 01       	movw	r24, r18
    257a:	0c 97       	sbiw	r24, 0x0c	; 12
    257c:	87 30       	cpi	r24, 0x07	; 7
    257e:	91 05       	cpc	r25, r1
    2580:	a8 f4       	brcc	.+42     	; 0x25ac <place_package+0x200>

            if (orie == pointingeast)
    2582:	80 91 48 03 	lds	r24, 0x0348
    2586:	90 91 49 03 	lds	r25, 0x0349
    258a:	20 91 91 02 	lds	r18, 0x0291
    258e:	30 91 92 02 	lds	r19, 0x0292
    2592:	82 17       	cp	r24, r18
    2594:	93 07       	cpc	r25, r19
    2596:	29 f4       	brne	.+10     	; 0x25a2 <place_package+0x1f6>
                forward_mm(25);			
    2598:	89 e1       	ldi	r24, 0x19	; 25
    259a:	90 e0       	ldi	r25, 0x00	; 0
    259c:	0e 94 0a 04 	call	0x814	; 0x814 <forward_mm>
    25a0:	1e c0       	rjmp	.+60     	; 0x25de <place_package+0x232>
            else
                back_mm(35);
    25a2:	83 e2       	ldi	r24, 0x23	; 35
    25a4:	90 e0       	ldi	r25, 0x00	; 0
    25a6:	0e 94 15 04 	call	0x82a	; 0x82a <back_mm>
    25aa:	19 c0       	rjmp	.+50     	; 0x25de <place_package+0x232>
        } else if ((current_position >= 42) && (current_position <= 48)) {
    25ac:	c9 01       	movw	r24, r18
    25ae:	8a 97       	sbiw	r24, 0x2a	; 42
    25b0:	87 30       	cpi	r24, 0x07	; 7
    25b2:	91 05       	cpc	r25, r1
    25b4:	a0 f4       	brcc	.+40     	; 0x25de <place_package+0x232>

            if (orie == pointingwest)
    25b6:	80 91 48 03 	lds	r24, 0x0348
    25ba:	90 91 49 03 	lds	r25, 0x0349
    25be:	20 91 8d 02 	lds	r18, 0x028D
    25c2:	30 91 8e 02 	lds	r19, 0x028E
    25c6:	82 17       	cp	r24, r18
    25c8:	93 07       	cpc	r25, r19
    25ca:	29 f4       	brne	.+10     	; 0x25d6 <place_package+0x22a>
                forward_mm(25);
    25cc:	89 e1       	ldi	r24, 0x19	; 25
    25ce:	90 e0       	ldi	r25, 0x00	; 0
    25d0:	0e 94 0a 04 	call	0x814	; 0x814 <forward_mm>
    25d4:	04 c0       	rjmp	.+8      	; 0x25de <place_package+0x232>
            else
                back_mm(35);
    25d6:	83 e2       	ldi	r24, 0x23	; 35
    25d8:	90 e0       	ldi	r25, 0x00	; 0
    25da:	0e 94 15 04 	call	0x82a	; 0x82a <back_mm>
        }
        if (block_counter > 0)
            forward_mm(25);
        else forward_mm(10);
    25de:	c7 01       	movw	r24, r14
    25e0:	0e 94 0a 04 	call	0x814	; 0x814 <forward_mm>
		//pick up the package
        pick();
    25e4:	0e 94 11 06 	call	0xc22	; 0xc22 <pick>
        stop();
    25e8:	0e 94 45 03 	call	0x68a	; 0x68a <stop>
    25ec:	8f ef       	ldi	r24, 0xFF	; 255
    25ee:	9f ef       	ldi	r25, 0xFF	; 255
    25f0:	ac e2       	ldi	r26, 0x2C	; 44
    25f2:	81 50       	subi	r24, 0x01	; 1
    25f4:	90 40       	sbci	r25, 0x00	; 0
    25f6:	a0 40       	sbci	r26, 0x00	; 0
    25f8:	e1 f7       	brne	.-8      	; 0x25f2 <place_package+0x246>
    25fa:	00 c0       	rjmp	.+0      	; 0x25fc <place_package+0x250>
    25fc:	00 00       	nop
        _delay_ms(1000);
        block_counter++;
        if (zone_coordinate != 0)
    25fe:	dd 20       	and	r13, r13
    2600:	09 f4       	brne	.+2      	; 0x2604 <place_package+0x258>
    2602:	d8 c0       	rjmp	.+432    	; 0x27b4 <place_package+0x408>
            next_position = zone_coordinate;
    2604:	8d 2d       	mov	r24, r13
    2606:	90 e0       	ldi	r25, 0x00	; 0
    2608:	d0 92 67 03 	sts	0x0367, r13
    260c:	90 93 68 03 	sts	0x0368, r25
        else break;
        if ((current_position >= 12 && current_position <= 18) || (current_position >= 42 && current_position <= 48)) {
    2610:	e0 91 5c 03 	lds	r30, 0x035C
    2614:	f0 91 5d 03 	lds	r31, 0x035D
    2618:	9f 01       	movw	r18, r30
    261a:	2c 50       	subi	r18, 0x0C	; 12
    261c:	30 40       	sbci	r19, 0x00	; 0
    261e:	27 30       	cpi	r18, 0x07	; 7
    2620:	31 05       	cpc	r19, r1
    2622:	30 f0       	brcs	.+12     	; 0x2630 <place_package+0x284>
    2624:	9f 01       	movw	r18, r30
    2626:	2a 52       	subi	r18, 0x2A	; 42
    2628:	30 40       	sbci	r19, 0x00	; 0
    262a:	27 30       	cpi	r18, 0x07	; 7
    262c:	31 05       	cpc	r19, r1
    262e:	c8 f5       	brcc	.+114    	; 0x26a2 <place_package+0x2f6>
            if ((next_position % 10) < (current_position % 10) && (orie == pointingeast)) {
    2630:	b7 01       	movw	r22, r14
    2632:	0e 94 70 1b 	call	0x36e0	; 0x36e0 <__divmodhi4>
    2636:	8c 01       	movw	r16, r24
    2638:	cf 01       	movw	r24, r30
    263a:	b7 01       	movw	r22, r14
    263c:	0e 94 70 1b 	call	0x36e0	; 0x36e0 <__divmodhi4>
    2640:	08 17       	cp	r16, r24
    2642:	19 07       	cpc	r17, r25
    2644:	b4 f4       	brge	.+44     	; 0x2672 <place_package+0x2c6>
    2646:	20 91 48 03 	lds	r18, 0x0348
    264a:	30 91 49 03 	lds	r19, 0x0349
    264e:	40 91 91 02 	lds	r20, 0x0291
    2652:	50 91 92 02 	lds	r21, 0x0292
    2656:	24 17       	cp	r18, r20
    2658:	35 07       	cpc	r19, r21
    265a:	59 f4       	brne	.+22     	; 0x2672 <place_package+0x2c6>
                velocity(220, 223);
    265c:	8c ed       	ldi	r24, 0xDC	; 220
    265e:	6f ed       	ldi	r22, 0xDF	; 223
    2660:	0e 94 2a 03 	call	0x654	; 0x654 <velocity>
                left_degrees(191);
    2664:	8f eb       	ldi	r24, 0xBF	; 191
    2666:	90 e0       	ldi	r25, 0x00	; 0
    2668:	0e 94 20 04 	call	0x840	; 0x840 <left_degrees>
                change_orientation();
    266c:	0e 94 9a 11 	call	0x2334	; 0x2334 <change_orientation>
    2670:	18 c0       	rjmp	.+48     	; 0x26a2 <place_package+0x2f6>
            } else if ((next_position % 10) > (current_position % 10) && (orie == pointingwest)) {
    2672:	80 17       	cp	r24, r16
    2674:	91 07       	cpc	r25, r17
    2676:	ac f4       	brge	.+42     	; 0x26a2 <place_package+0x2f6>
    2678:	80 91 48 03 	lds	r24, 0x0348
    267c:	90 91 49 03 	lds	r25, 0x0349
    2680:	20 91 8d 02 	lds	r18, 0x028D
    2684:	30 91 8e 02 	lds	r19, 0x028E
    2688:	82 17       	cp	r24, r18
    268a:	93 07       	cpc	r25, r19
    268c:	51 f4       	brne	.+20     	; 0x26a2 <place_package+0x2f6>
                velocity(220, 223);
    268e:	8c ed       	ldi	r24, 0xDC	; 220
    2690:	6f ed       	ldi	r22, 0xDF	; 223
    2692:	0e 94 2a 03 	call	0x654	; 0x654 <velocity>
                left_degrees(191);
    2696:	8f eb       	ldi	r24, 0xBF	; 191
    2698:	90 e0       	ldi	r25, 0x00	; 0
    269a:	0e 94 20 04 	call	0x840	; 0x840 <left_degrees>
                change_orientation();
    269e:	0e 94 9a 11 	call	0x2334	; 0x2334 <change_orientation>
            }
        }
        travel(current_position, next_position);
    26a2:	60 91 67 03 	lds	r22, 0x0367
    26a6:	70 91 68 03 	lds	r23, 0x0368
    26aa:	80 91 5c 03 	lds	r24, 0x035C
    26ae:	90 91 5d 03 	lds	r25, 0x035D
    26b2:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <travel>
        current_position = next_position;
    26b6:	80 91 67 03 	lds	r24, 0x0367
    26ba:	90 91 68 03 	lds	r25, 0x0368
    26be:	90 93 5d 03 	sts	0x035D, r25
    26c2:	80 93 5c 03 	sts	0x035C, r24
        if ((current_position == 25) || (current_position == 35)) {
    26c6:	89 31       	cpi	r24, 0x19	; 25
    26c8:	91 05       	cpc	r25, r1
    26ca:	19 f0       	breq	.+6      	; 0x26d2 <place_package+0x326>
    26cc:	83 32       	cpi	r24, 0x23	; 35
    26ce:	91 05       	cpc	r25, r1
    26d0:	79 f4       	brne	.+30     	; 0x26f0 <place_package+0x344>

            velocity(220, 223);
    26d2:	8c ed       	ldi	r24, 0xDC	; 220
    26d4:	6f ed       	ldi	r22, 0xDF	; 223
    26d6:	0e 94 2a 03 	call	0x654	; 0x654 <velocity>
            left_degrees(191);
    26da:	8f eb       	ldi	r24, 0xBF	; 191
    26dc:	90 e0       	ldi	r25, 0x00	; 0
    26de:	0e 94 20 04 	call	0x840	; 0x840 <left_degrees>
            change_orientation();
    26e2:	0e 94 9a 11 	call	0x2334	; 0x2334 <change_orientation>
            back_mm(60);
    26e6:	8c e3       	ldi	r24, 0x3C	; 60
    26e8:	90 e0       	ldi	r25, 0x00	; 0
    26ea:	0e 94 15 04 	call	0x82a	; 0x82a <back_mm>
    26ee:	3d c0       	rjmp	.+122    	; 0x276a <place_package+0x3be>
        } else if ((current_position == 21) || (current_position == 31)) {
    26f0:	85 31       	cpi	r24, 0x15	; 21
    26f2:	91 05       	cpc	r25, r1
    26f4:	19 f0       	breq	.+6      	; 0x26fc <place_package+0x350>
    26f6:	8f 31       	cpi	r24, 0x1F	; 31
    26f8:	91 05       	cpc	r25, r1
    26fa:	c9 f4       	brne	.+50     	; 0x272e <place_package+0x382>
            right_degrees(88);
    26fc:	88 e5       	ldi	r24, 0x58	; 88
    26fe:	90 e0       	ldi	r25, 0x00	; 0
    2700:	0e 94 2b 04 	call	0x856	; 0x856 <right_degrees>
            orie = pointingeast;
    2704:	80 91 91 02 	lds	r24, 0x0291
    2708:	90 91 92 02 	lds	r25, 0x0292
    270c:	90 93 49 03 	sts	0x0349, r25
    2710:	80 93 48 03 	sts	0x0348, r24
            follow();
    2714:	0e 94 6f 09 	call	0x12de	; 0x12de <follow>
            velocity(220, 223);
    2718:	8c ed       	ldi	r24, 0xDC	; 220
    271a:	6f ed       	ldi	r22, 0xDF	; 223
    271c:	0e 94 2a 03 	call	0x654	; 0x654 <velocity>
            left_degrees(191);
    2720:	8f eb       	ldi	r24, 0xBF	; 191
    2722:	90 e0       	ldi	r25, 0x00	; 0
    2724:	0e 94 20 04 	call	0x840	; 0x840 <left_degrees>
            change_orientation();
    2728:	0e 94 9a 11 	call	0x2334	; 0x2334 <change_orientation>
    272c:	1e c0       	rjmp	.+60     	; 0x276a <place_package+0x3be>
        } else if (current_position == 29 || current_position == 39) {
    272e:	8d 31       	cpi	r24, 0x1D	; 29
    2730:	91 05       	cpc	r25, r1
    2732:	19 f0       	breq	.+6      	; 0x273a <place_package+0x38e>
    2734:	87 32       	cpi	r24, 0x27	; 39
    2736:	91 05       	cpc	r25, r1
    2738:	c1 f4       	brne	.+48     	; 0x276a <place_package+0x3be>
            left_degrees(88);
    273a:	88 e5       	ldi	r24, 0x58	; 88
    273c:	90 e0       	ldi	r25, 0x00	; 0
    273e:	0e 94 20 04 	call	0x840	; 0x840 <left_degrees>
            orie = pointingwest;
    2742:	80 91 8d 02 	lds	r24, 0x028D
    2746:	90 91 8e 02 	lds	r25, 0x028E
    274a:	90 93 49 03 	sts	0x0349, r25
    274e:	80 93 48 03 	sts	0x0348, r24
            follow();
    2752:	0e 94 6f 09 	call	0x12de	; 0x12de <follow>
            velocity(220, 223);
    2756:	8c ed       	ldi	r24, 0xDC	; 220
    2758:	6f ed       	ldi	r22, 0xDF	; 223
    275a:	0e 94 2a 03 	call	0x654	; 0x654 <velocity>
            left_degrees(191);
    275e:	8f eb       	ldi	r24, 0xBF	; 191
    2760:	90 e0       	ldi	r25, 0x00	; 0
    2762:	0e 94 20 04 	call	0x840	; 0x840 <left_degrees>
            change_orientation();
    2766:	0e 94 9a 11 	call	0x2334	; 0x2334 <change_orientation>
        }
		drop(blocks_in[queue[i]]);
    276a:	d4 01       	movw	r26, r8
    276c:	8d 91       	ld	r24, X+
    276e:	9d 91       	ld	r25, X+
    2770:	4d 01       	movw	r8, r26
    2772:	88 0f       	add	r24, r24
    2774:	99 1f       	adc	r25, r25
    2776:	84 0d       	add	r24, r4
    2778:	95 1d       	adc	r25, r5
    277a:	fc 01       	movw	r30, r24
    277c:	80 81       	ld	r24, Z
    277e:	91 81       	ldd	r25, Z+1	; 0x01
    2780:	0e 94 ed 04 	call	0x9da	; 0x9da <drop>
        if ((current_position == 21) || current_position == 29 || current_position == 31 || current_position == 39) {
    2784:	80 91 5c 03 	lds	r24, 0x035C
    2788:	90 91 5d 03 	lds	r25, 0x035D
    278c:	85 31       	cpi	r24, 0x15	; 21
    278e:	91 05       	cpc	r25, r1
    2790:	49 f0       	breq	.+18     	; 0x27a4 <place_package+0x3f8>
    2792:	8d 31       	cpi	r24, 0x1D	; 29
    2794:	91 05       	cpc	r25, r1
    2796:	31 f0       	breq	.+12     	; 0x27a4 <place_package+0x3f8>
    2798:	8f 31       	cpi	r24, 0x1F	; 31
    279a:	91 05       	cpc	r25, r1
    279c:	19 f0       	breq	.+6      	; 0x27a4 <place_package+0x3f8>
    279e:	87 32       	cpi	r24, 0x27	; 39
    27a0:	91 05       	cpc	r25, r1
    27a2:	21 f4       	brne	.+8      	; 0x27ac <place_package+0x400>
            follow();
    27a4:	0e 94 6f 09 	call	0x12de	; 0x12de <follow>
            stop();
    27a8:	0e 94 45 03 	call	0x68a	; 0x68a <stop>
    char upper_boundary[6] = {
        0, 21, 29, 43, 47, 35
    };
    char zone_coordinate;
    int block_counter = 0;
    for (int i = 0; i <= 2; i++) {
    27ac:	a6 14       	cp	r10, r6
    27ae:	b7 04       	cpc	r11, r7
    27b0:	09 f0       	breq	.+2      	; 0x27b4 <place_package+0x408>
    27b2:	43 ce       	rjmp	.-890    	; 0x243a <place_package+0x8e>
            follow();
            stop();
        }
        block_counter = 0;
    }
}
    27b4:	2c 96       	adiw	r28, 0x0c	; 12
    27b6:	0f b6       	in	r0, 0x3f	; 63
    27b8:	f8 94       	cli
    27ba:	de bf       	out	0x3e, r29	; 62
    27bc:	0f be       	out	0x3f, r0	; 63
    27be:	cd bf       	out	0x3d, r28	; 61
    27c0:	df 91       	pop	r29
    27c2:	cf 91       	pop	r28
    27c4:	1f 91       	pop	r17
    27c6:	0f 91       	pop	r16
    27c8:	ff 90       	pop	r15
    27ca:	ef 90       	pop	r14
    27cc:	df 90       	pop	r13
    27ce:	bf 90       	pop	r11
    27d0:	af 90       	pop	r10
    27d2:	9f 90       	pop	r9
    27d4:	8f 90       	pop	r8
    27d6:	7f 90       	pop	r7
    27d8:	6f 90       	pop	r6
    27da:	5f 90       	pop	r5
    27dc:	4f 90       	pop	r4
    27de:	08 95       	ret

000027e0 <main>:
 *
 */


void main()
{
    27e0:	6f 92       	push	r6
    27e2:	7f 92       	push	r7
    27e4:	8f 92       	push	r8
    27e6:	9f 92       	push	r9
    27e8:	af 92       	push	r10
    27ea:	bf 92       	push	r11
    27ec:	cf 92       	push	r12
    27ee:	df 92       	push	r13
    27f0:	ef 92       	push	r14
    27f2:	ff 92       	push	r15
    27f4:	0f 93       	push	r16
    27f6:	1f 93       	push	r17
    27f8:	cf 93       	push	r28
    27fa:	df 93       	push	r29
    init_devices();
    27fc:	0e 94 91 04 	call	0x922	; 0x922 <init_devices>
    lcd_set_4bit();
    2800:	0e 94 d6 00 	call	0x1ac	; 0x1ac <lcd_set_4bit>
    lcd_init();
    2804:	0e 94 6a 04 	call	0x8d4	; 0x8d4 <lcd_init>
    2808:	60 91 31 03 	lds	r22, 0x0331
    280c:	70 91 32 03 	lds	r23, 0x0332
    2810:	40 91 2f 03 	lds	r20, 0x032F
    2814:	50 91 30 03 	lds	r21, 0x0330
    2818:	20 91 2d 03 	lds	r18, 0x032D
    281c:	30 91 2e 03 	lds	r19, 0x032E
    2820:	ad e6       	ldi	r26, 0x6D	; 109
    2822:	b2 e0       	ldi	r27, 0x02	; 2
 * Example Call:		Called automatically by the Operating System
 *
 */


void main()
    2824:	ed 01       	movw	r28, r26
    2826:	26 96       	adiw	r28, 0x06	; 6
{
    init_devices();
    lcd_set_4bit();
    lcd_init();
    for (int i = 1; i < 4; i++) {
        if (deposition_table[0][i] != -1) { 
    2828:	8d 91       	ld	r24, X+
    282a:	9d 91       	ld	r25, X+
    282c:	1f ef       	ldi	r17, 0xFF	; 255
    282e:	8f 3f       	cpi	r24, 0xFF	; 255
    2830:	91 07       	cpc	r25, r17
    2832:	11 f0       	breq	.+4      	; 0x2838 <main+0x58>
            count_red_zone++;//to check the number of red blocks to be considered for deposition
    2834:	6f 5f       	subi	r22, 0xFF	; 255
    2836:	7f 4f       	sbci	r23, 0xFF	; 255
 * Example Call:		Called automatically by the Operating System
 *
 */


void main()
    2838:	fd 01       	movw	r30, r26
    for (int i = 1; i < 4; i++) {
        if (deposition_table[0][i] != -1) { 
            count_red_zone++;//to check the number of red blocks to be considered for deposition
        }

        if (deposition_table[1][i] != -1) {
    283a:	16 96       	adiw	r26, 0x06	; 6
    283c:	8d 91       	ld	r24, X+
    283e:	9c 91       	ld	r25, X
    2840:	17 97       	sbiw	r26, 0x07	; 7
    2842:	1f ef       	ldi	r17, 0xFF	; 255
    2844:	8f 3f       	cpi	r24, 0xFF	; 255
    2846:	91 07       	cpc	r25, r17
    2848:	11 f0       	breq	.+4      	; 0x284e <main+0x6e>
            count_green_zone++;//to check the number of green blocks to be considered for deposition
    284a:	4f 5f       	subi	r20, 0xFF	; 255
    284c:	5f 4f       	sbci	r21, 0xFF	; 255
        }

        if (deposition_table[2][i] != -1) {
    284e:	86 85       	ldd	r24, Z+14	; 0x0e
    2850:	97 85       	ldd	r25, Z+15	; 0x0f
    2852:	ef ef       	ldi	r30, 0xFF	; 255
    2854:	8f 3f       	cpi	r24, 0xFF	; 255
    2856:	9e 07       	cpc	r25, r30
    2858:	11 f0       	breq	.+4      	; 0x285e <main+0x7e>
            count_blue_zone++;//to check the number of blue blocks to be considered for deposition
    285a:	2f 5f       	subi	r18, 0xFF	; 255
    285c:	3f 4f       	sbci	r19, 0xFF	; 255
void main()
{
    init_devices();
    lcd_set_4bit();
    lcd_init();
    for (int i = 1; i < 4; i++) {
    285e:	ac 17       	cp	r26, r28
    2860:	bd 07       	cpc	r27, r29
    2862:	11 f7       	brne	.-60     	; 0x2828 <main+0x48>
        if (deposition_table[2][i] != -1) {
            count_blue_zone++;//to check the number of blue blocks to be considered for deposition
        }
    }
	
    count_blue_zone = count_blue_zone * 2;
    2864:	22 0f       	add	r18, r18
    2866:	33 1f       	adc	r19, r19
    2868:	30 93 2e 03 	sts	0x032E, r19
    286c:	20 93 2d 03 	sts	0x032D, r18
    count_green_zone = count_green_zone * 2;
    2870:	44 0f       	add	r20, r20
    2872:	55 1f       	adc	r21, r21
    2874:	50 93 30 03 	sts	0x0330, r21
    2878:	40 93 2f 03 	sts	0x032F, r20
    count_red_zone = count_red_zone * 2;
    287c:	66 0f       	add	r22, r22
    287e:	77 1f       	adc	r23, r23
    2880:	70 93 32 03 	sts	0x0332, r23
    2884:	60 93 31 03 	sts	0x0331, r22

    flag = 1;
    2888:	81 e0       	ldi	r24, 0x01	; 1
    288a:	90 e0       	ldi	r25, 0x00	; 0
    288c:	90 93 6a 02 	sts	0x026A, r25
    2890:	80 93 69 02 	sts	0x0269, r24
    int last_zone = 0; //has_turned=0;
    orie = pointingnorth;
    2894:	80 91 93 02 	lds	r24, 0x0293
    2898:	90 91 94 02 	lds	r25, 0x0294
    289c:	90 93 49 03 	sts	0x0349, r25
    28a0:	80 93 48 03 	sts	0x0348, r24
    servo_3(5); //initializes lower servo 
    28a4:	85 e0       	ldi	r24, 0x05	; 5
    28a6:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <servo_3>
    servo_2(120); //initializes middle servo
    28aa:	88 e7       	ldi	r24, 0x78	; 120
    28ac:	0e 94 bb 04 	call	0x976	; 0x976 <servo_2>
    servo_1(80); //initializes gripper servo
    28b0:	80 e5       	ldi	r24, 0x50	; 80
    28b2:	0e 94 a2 04 	call	0x944	; 0x944 <servo_1>
    total_boxes = deposition_table[0][0] + deposition_table[1][0] + deposition_table[2][0]; //keeps track of total blocks
    28b6:	80 91 6b 02 	lds	r24, 0x026B
    28ba:	90 91 6c 02 	lds	r25, 0x026C
    28be:	20 91 73 02 	lds	r18, 0x0273
    28c2:	30 91 74 02 	lds	r19, 0x0274
    28c6:	82 0f       	add	r24, r18
    28c8:	93 1f       	adc	r25, r19
    28ca:	20 91 7b 02 	lds	r18, 0x027B
    28ce:	30 91 7c 02 	lds	r19, 0x027C
    28d2:	82 0f       	add	r24, r18
    28d4:	93 1f       	adc	r25, r19
    28d6:	90 93 5f 03 	sts	0x035F, r25
    28da:	80 93 5e 03 	sts	0x035E, r24
    create_info_table(); //creates the information table
    28de:	0e 94 c2 0f 	call	0x1f84	; 0x1f84 <create_info_table>

    follow(); // travel to firt co-ordinate 15
    28e2:	0e 94 6f 09 	call	0x12de	; 0x12de <follow>
    current_position = 15;
    28e6:	8f e0       	ldi	r24, 0x0F	; 15
    28e8:	90 e0       	ldi	r25, 0x00	; 0
    28ea:	90 93 5d 03 	sts	0x035D, r25
    28ee:	80 93 5c 03 	sts	0x035C, r24
    next_position = 14; // next co-ordinate
    28f2:	8e e0       	ldi	r24, 0x0E	; 14
    28f4:	90 e0       	ldi	r25, 0x00	; 0
    28f6:	90 93 68 03 	sts	0x0368, r25
    28fa:	80 93 67 03 	sts	0x0367, r24
    zone_scan(); //scan the co-ordinates 14 to 12
    28fe:	0e 94 ed 0f 	call	0x1fda	; 0x1fda <zone_scan>
    path_planning(current_position); //prioritize deposition of scanned blocks
    2902:	80 91 5c 03 	lds	r24, 0x035C
    2906:	90 91 5d 03 	lds	r25, 0x035D
    290a:	0e 94 c3 0d 	call	0x1b86	; 0x1b86 <path_planning>
    stop();
    290e:	0e 94 45 03 	call	0x68a	; 0x68a <stop>
    velocity(220, 223);//
    2912:	8c ed       	ldi	r24, 0xDC	; 220
    2914:	6f ed       	ldi	r22, 0xDF	; 223
    2916:	0e 94 2a 03 	call	0x654	; 0x654 <velocity>
    left_degrees(191); //take a u-turn
    291a:	8f eb       	ldi	r24, 0xBF	; 191
    291c:	90 e0       	ldi	r25, 0x00	; 0
    291e:	0e 94 20 04 	call	0x840	; 0x840 <left_degrees>
    back_mm(25);	   //
    2922:	89 e1       	ldi	r24, 0x19	; 25
    2924:	90 e0       	ldi	r25, 0x00	; 0
    2926:	0e 94 15 04 	call	0x82a	; 0x82a <back_mm>
    stop();
    292a:	0e 94 45 03 	call	0x68a	; 0x68a <stop>
    orie = pointingeast; //set orientation
    292e:	80 91 91 02 	lds	r24, 0x0291
    2932:	90 91 92 02 	lds	r25, 0x0292
    2936:	90 93 49 03 	sts	0x0349, r25
    293a:	80 93 48 03 	sts	0x0348, r24

    place_package(); //to place packages scanned from co-ordinates 14-12
    293e:	0e 94 d6 11 	call	0x23ac	; 0x23ac <place_package>
    2942:	0f 2e       	mov	r0, r31
    2944:	f6 ea       	ldi	r31, 0xA6	; 166
    2946:	8f 2e       	mov	r8, r31
    2948:	f2 e0       	ldi	r31, 0x02	; 2
    294a:	9f 2e       	mov	r9, r31
    294c:	f0 2d       	mov	r31, r0
    294e:	0f 2e       	mov	r0, r31
    2950:	f8 e9       	ldi	r31, 0x98	; 152
    2952:	af 2e       	mov	r10, r31
    2954:	f2 e0       	ldi	r31, 0x02	; 2
    2956:	bf 2e       	mov	r11, r31
    2958:	f0 2d       	mov	r31, r0
 * Example Call:		Called automatically by the Operating System
 *
 */


void main()
    295a:	0f 2e       	mov	r0, r31
    295c:	fe e0       	ldi	r31, 0x0E	; 14
    295e:	ef 2e       	mov	r14, r31
    2960:	ff 24       	eor	r15, r15
    2962:	f0 2d       	mov	r31, r0
    2964:	e8 0c       	add	r14, r8
    2966:	f9 1c       	adc	r15, r9
    2968:	d5 01       	movw	r26, r10
    296a:	f4 01       	movw	r30, r8
    stop();
    orie = pointingeast; //set orientation

    place_package(); //to place packages scanned from co-ordinates 14-12
    for (int i = 0; i < 7; i++) {
        queue[i] = 0;
    296c:	11 92       	st	Z+, r1
    296e:	11 92       	st	Z+, r1
        co_ordinate_queue[i] = 0; //empties the queue and co-ordinate queue
    2970:	1d 92       	st	X+, r1
    2972:	1d 92       	st	X+, r1
    back_mm(25);	   //
    stop();
    orie = pointingeast; //set orientation

    place_package(); //to place packages scanned from co-ordinates 14-12
    for (int i = 0; i < 7; i++) {
    2974:	ee 15       	cp	r30, r14
    2976:	ff 05       	cpc	r31, r15
    2978:	c9 f7       	brne	.-14     	; 0x296c <main+0x18c>
        queue[i] = 0;
        co_ordinate_queue[i] = 0; //empties the queue and co-ordinate queue
    }
    servo_3(180); //resets servo to 180 degrees for next pick up zone
    297a:	84 eb       	ldi	r24, 0xB4	; 180
    297c:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <servo_3>
	    if (current_position != 31 && current_position != 21) {
    2980:	20 91 5c 03 	lds	r18, 0x035C
    2984:	30 91 5d 03 	lds	r19, 0x035D
    2988:	2f 31       	cpi	r18, 0x1F	; 31
    298a:	31 05       	cpc	r19, r1
    298c:	49 f1       	breq	.+82     	; 0x29e0 <main+0x200>
    298e:	25 31       	cpi	r18, 0x15	; 21
    2990:	31 05       	cpc	r19, r1
    2992:	31 f1       	breq	.+76     	; 0x29e0 <main+0x200>
        if ((orie == pointingwest) || (orie == pointingnorth) || ((current_position > 15) && (orie == pointingeast))) {
    2994:	40 91 48 03 	lds	r20, 0x0348
    2998:	50 91 49 03 	lds	r21, 0x0349
    299c:	80 91 8d 02 	lds	r24, 0x028D
    29a0:	90 91 8e 02 	lds	r25, 0x028E
    29a4:	48 17       	cp	r20, r24
    29a6:	59 07       	cpc	r21, r25
    29a8:	89 f0       	breq	.+34     	; 0x29cc <main+0x1ec>
    29aa:	80 91 93 02 	lds	r24, 0x0293
    29ae:	90 91 94 02 	lds	r25, 0x0294
    29b2:	48 17       	cp	r20, r24
    29b4:	59 07       	cpc	r21, r25
    29b6:	51 f0       	breq	.+20     	; 0x29cc <main+0x1ec>
    29b8:	20 31       	cpi	r18, 0x10	; 16
    29ba:	31 05       	cpc	r19, r1
    29bc:	8c f0       	brlt	.+34     	; 0x29e0 <main+0x200>
    29be:	80 91 91 02 	lds	r24, 0x0291
    29c2:	90 91 92 02 	lds	r25, 0x0292
    29c6:	48 17       	cp	r20, r24
    29c8:	59 07       	cpc	r21, r25
    29ca:	51 f4       	brne	.+20     	; 0x29e0 <main+0x200>
            velocity(220, 223);//
    29cc:	8c ed       	ldi	r24, 0xDC	; 220
    29ce:	6f ed       	ldi	r22, 0xDF	; 223
    29d0:	0e 94 2a 03 	call	0x654	; 0x654 <velocity>
            left_degrees(191);//take a u-turn
    29d4:	8f eb       	ldi	r24, 0xBF	; 191
    29d6:	90 e0       	ldi	r25, 0x00	; 0
    29d8:	0e 94 20 04 	call	0x840	; 0x840 <left_degrees>
            change_orientation();//
    29dc:	0e 94 9a 11 	call	0x2334	; 0x2334 <change_orientation>
        }
    }

    travel(current_position, 15);//to travel to co-ordinate 15
    29e0:	80 91 5c 03 	lds	r24, 0x035C
    29e4:	90 91 5d 03 	lds	r25, 0x035D
    29e8:	6f e0       	ldi	r22, 0x0F	; 15
    29ea:	70 e0       	ldi	r23, 0x00	; 0
    29ec:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <travel>

    if ((orie == pointingwest || orie == pointingnorth) && (current_position >= 12 && current_position <= 18)) {
    29f0:	20 91 48 03 	lds	r18, 0x0348
    29f4:	30 91 49 03 	lds	r19, 0x0349
    29f8:	80 91 8d 02 	lds	r24, 0x028D
    29fc:	90 91 8e 02 	lds	r25, 0x028E
    2a00:	28 17       	cp	r18, r24
    2a02:	39 07       	cpc	r19, r25
    2a04:	39 f0       	breq	.+14     	; 0x2a14 <main+0x234>
    2a06:	80 91 93 02 	lds	r24, 0x0293
    2a0a:	90 91 94 02 	lds	r25, 0x0294
    2a0e:	28 17       	cp	r18, r24
    2a10:	39 07       	cpc	r19, r25
    2a12:	91 f4       	brne	.+36     	; 0x2a38 <main+0x258>
    2a14:	80 91 5c 03 	lds	r24, 0x035C
    2a18:	90 91 5d 03 	lds	r25, 0x035D
    2a1c:	0c 97       	sbiw	r24, 0x0c	; 12
    2a1e:	87 30       	cpi	r24, 0x07	; 7
    2a20:	91 05       	cpc	r25, r1
    2a22:	50 f4       	brcc	.+20     	; 0x2a38 <main+0x258>
        velocity(220, 223);//
    2a24:	8c ed       	ldi	r24, 0xDC	; 220
    2a26:	6f ed       	ldi	r22, 0xDF	; 223
    2a28:	0e 94 2a 03 	call	0x654	; 0x654 <velocity>
        left_degrees(191);//take a u-turn
    2a2c:	8f eb       	ldi	r24, 0xBF	; 191
    2a2e:	90 e0       	ldi	r25, 0x00	; 0
    2a30:	0e 94 20 04 	call	0x840	; 0x840 <left_degrees>
        change_orientation();//
    2a34:	0e 94 9a 11 	call	0x2334	; 0x2334 <change_orientation>
    }
   
    current_position = 15;
    2a38:	8f e0       	ldi	r24, 0x0F	; 15
    2a3a:	90 e0       	ldi	r25, 0x00	; 0
    2a3c:	90 93 5d 03 	sts	0x035D, r25
    2a40:	80 93 5c 03 	sts	0x035C, r24
    next_position = 16; //set co-ordinates
    2a44:	80 e1       	ldi	r24, 0x10	; 16
    2a46:	90 e0       	ldi	r25, 0x00	; 0
    2a48:	90 93 68 03 	sts	0x0368, r25
    2a4c:	80 93 67 03 	sts	0x0367, r24
    zone_scan();//scan the co-ordinates 16 to 18
    2a50:	0e 94 ed 0f 	call	0x1fda	; 0x1fda <zone_scan>
    path_planning(current_position);//to prioritize deposition of scanned blocks
    2a54:	80 91 5c 03 	lds	r24, 0x035C
    2a58:	90 91 5d 03 	lds	r25, 0x035D
    2a5c:	0e 94 c3 0d 	call	0x1b86	; 0x1b86 <path_planning>
    velocity(220, 223);//
    2a60:	8c ed       	ldi	r24, 0xDC	; 220
    2a62:	6f ed       	ldi	r22, 0xDF	; 223
    2a64:	0e 94 2a 03 	call	0x654	; 0x654 <velocity>
    left_degrees(191); //take a u-turn
    2a68:	8f eb       	ldi	r24, 0xBF	; 191
    2a6a:	90 e0       	ldi	r25, 0x00	; 0
    2a6c:	0e 94 20 04 	call	0x840	; 0x840 <left_degrees>
    orie = pointingwest;//
    2a70:	80 91 8d 02 	lds	r24, 0x028D
    2a74:	90 91 8e 02 	lds	r25, 0x028E
    2a78:	90 93 49 03 	sts	0x0349, r25
    2a7c:	80 93 48 03 	sts	0x0348, r24
    //has_turned=1;
    stop();
    2a80:	0e 94 45 03 	call	0x68a	; 0x68a <stop>
    back_mm(40);//to align
    2a84:	88 e2       	ldi	r24, 0x28	; 40
    2a86:	90 e0       	ldi	r25, 0x00	; 0
    2a88:	0e 94 15 04 	call	0x82a	; 0x82a <back_mm>
    place_package(); //to place packages scanned from co-ordinate 16 to 18
    2a8c:	0e 94 d6 11 	call	0x23ac	; 0x23ac <place_package>
    stop();
    2a90:	0e 94 45 03 	call	0x68a	; 0x68a <stop>
    2a94:	d5 01       	movw	r26, r10
    2a96:	f4 01       	movw	r30, r8
    for (int i = 0; i < 7; i++) {
        queue[i] = 0; 
    2a98:	11 92       	st	Z+, r1
    2a9a:	11 92       	st	Z+, r1
        co_ordinate_queue[i] = 0; //empty queue and co-ordinate queue
    2a9c:	1d 92       	st	X+, r1
    2a9e:	1d 92       	st	X+, r1
    //has_turned=1;
    stop();
    back_mm(40);//to align
    place_package(); //to place packages scanned from co-ordinate 16 to 18
    stop();
    for (int i = 0; i < 7; i++) {
    2aa0:	ee 15       	cp	r30, r14
    2aa2:	ff 05       	cpc	r31, r15
    2aa4:	c9 f7       	brne	.-14     	; 0x2a98 <main+0x2b8>
    2aa6:	c0 e0       	ldi	r28, 0x00	; 0
    2aa8:	d0 e0       	ldi	r29, 0x00	; 0
        co_ordinate_queue[i] = 0; //empty queue and co-ordinate queue
    }
    int size = 7;
    int i, j, k;
    for (i = 0; i < size; i++) {
        for (j = i + 1; j < size;) {
    2aaa:	01 e0       	ldi	r16, 0x01	; 1
    2aac:	10 e0       	ldi	r17, 0x00	; 0
    2aae:	41 e0       	ldi	r20, 0x01	; 1
    2ab0:	50 e0       	ldi	r21, 0x00	; 0
    //has_turned=1;
    stop();
    back_mm(40);//to align
    place_package(); //to place packages scanned from co-ordinate 16 to 18
    stop();
    for (int i = 0; i < 7; i++) {
    2ab2:	67 e0       	ldi	r22, 0x07	; 7
    2ab4:	70 e0       	ldi	r23, 0x00	; 0
    }
    int size = 7;
    int i, j, k;
    for (i = 0; i < size; i++) {
        for (j = i + 1; j < size;) {
            if (leftover_blocks[1][j] == leftover_blocks[1][i]) {
    2ab6:	aa e0       	ldi	r26, 0x0A	; 10
    2ab8:	b3 e0       	ldi	r27, 0x03	; 3
    2aba:	08 c0       	rjmp	.+16     	; 0x2acc <main+0x2ec>
        co_ordinate_queue[i] = 0; //empty queue and co-ordinate queue
    }
    int size = 7;
    int i, j, k;
    for (i = 0; i < size; i++) {
        for (j = i + 1; j < size;) {
    2abc:	a8 01       	movw	r20, r16
    2abe:	4f 5f       	subi	r20, 0xFF	; 255
    2ac0:	5f 4f       	sbci	r21, 0xFF	; 255
    2ac2:	46 17       	cp	r20, r22
    2ac4:	57 07       	cpc	r21, r23
    2ac6:	ec f5       	brge	.+122    	; 0x2b42 <main+0x362>
    2ac8:	e8 01       	movw	r28, r16
    2aca:	8a 01       	movw	r16, r20
            if (leftover_blocks[1][j] == leftover_blocks[1][i]) {
    2acc:	ca 01       	movw	r24, r20
    2ace:	07 96       	adiw	r24, 0x07	; 7
    2ad0:	88 0f       	add	r24, r24
    2ad2:	99 1f       	adc	r25, r25
    2ad4:	fd 01       	movw	r30, r26
    2ad6:	e8 0f       	add	r30, r24
    2ad8:	f9 1f       	adc	r31, r25
    2ada:	ce 01       	movw	r24, r28
    2adc:	07 96       	adiw	r24, 0x07	; 7
    2ade:	88 0f       	add	r24, r24
    2ae0:	99 1f       	adc	r25, r25
    2ae2:	8a 0f       	add	r24, r26
    2ae4:	9b 1f       	adc	r25, r27
    2ae6:	20 81       	ld	r18, Z
    2ae8:	31 81       	ldd	r19, Z+1	; 0x01
    2aea:	fc 01       	movw	r30, r24
    2aec:	80 81       	ld	r24, Z
    2aee:	91 81       	ldd	r25, Z+1	; 0x01
    2af0:	28 17       	cp	r18, r24
    2af2:	39 07       	cpc	r19, r25
    2af4:	e9 f4       	brne	.+58     	; 0x2b30 <main+0x350>
                for (k = j; k < size; k++) {
    2af6:	46 17       	cp	r20, r22
    2af8:	57 07       	cpc	r21, r23
    2afa:	bc f4       	brge	.+46     	; 0x2b2a <main+0x34a>
 * Example Call:		Called automatically by the Operating System
 *
 */


void main()
    2afc:	ca 01       	movw	r24, r20
    2afe:	88 0f       	add	r24, r24
    2b00:	99 1f       	adc	r25, r25
    2b02:	fc 01       	movw	r30, r24
    2b04:	e6 5f       	subi	r30, 0xF6	; 246
    2b06:	fc 4f       	sbci	r31, 0xFC	; 252
    2b08:	cb 01       	movw	r24, r22
    2b0a:	88 0f       	add	r24, r24
    2b0c:	99 1f       	adc	r25, r25
    2b0e:	9c 01       	movw	r18, r24
    2b10:	26 5f       	subi	r18, 0xF6	; 246
    2b12:	3c 4f       	sbci	r19, 0xFC	; 252
    int i, j, k;
    for (i = 0; i < size; i++) {
        for (j = i + 1; j < size;) {
            if (leftover_blocks[1][j] == leftover_blocks[1][i]) {
                for (k = j; k < size; k++) {
                    leftover_blocks[1][k] = leftover_blocks[1][k + 1];
    2b14:	80 89       	ldd	r24, Z+16	; 0x10
    2b16:	91 89       	ldd	r25, Z+17	; 0x11
    2b18:	97 87       	std	Z+15, r25	; 0x0f
    2b1a:	86 87       	std	Z+14, r24	; 0x0e
                    leftover_blocks[0][k] = leftover_blocks[0][k + 1]; //procedure to shuffle any leftover blocks in lower boundary
    2b1c:	82 81       	ldd	r24, Z+2	; 0x02
    2b1e:	93 81       	ldd	r25, Z+3	; 0x03
    2b20:	81 93       	st	Z+, r24
    2b22:	91 93       	st	Z+, r25
    int size = 7;
    int i, j, k;
    for (i = 0; i < size; i++) {
        for (j = i + 1; j < size;) {
            if (leftover_blocks[1][j] == leftover_blocks[1][i]) {
                for (k = j; k < size; k++) {
    2b24:	e2 17       	cp	r30, r18
    2b26:	f3 07       	cpc	r31, r19
    2b28:	a9 f7       	brne	.-22     	; 0x2b14 <main+0x334>
                    leftover_blocks[1][k] = leftover_blocks[1][k + 1];
                    leftover_blocks[0][k] = leftover_blocks[0][k + 1]; //procedure to shuffle any leftover blocks in lower boundary
                }
                size--;
    2b2a:	61 50       	subi	r22, 0x01	; 1
    2b2c:	70 40       	sbci	r23, 0x00	; 0
    2b2e:	02 c0       	rjmp	.+4      	; 0x2b34 <main+0x354>
            } else
                j++;
    2b30:	4f 5f       	subi	r20, 0xFF	; 255
    2b32:	5f 4f       	sbci	r21, 0xFF	; 255
        co_ordinate_queue[i] = 0; //empty queue and co-ordinate queue
    }
    int size = 7;
    int i, j, k;
    for (i = 0; i < size; i++) {
        for (j = i + 1; j < size;) {
    2b34:	46 17       	cp	r20, r22
    2b36:	57 07       	cpc	r21, r23
    2b38:	4c f2       	brlt	.-110    	; 0x2acc <main+0x2ec>
        queue[i] = 0; 
        co_ordinate_queue[i] = 0; //empty queue and co-ordinate queue
    }
    int size = 7;
    int i, j, k;
    for (i = 0; i < size; i++) {
    2b3a:	06 17       	cp	r16, r22
    2b3c:	17 07       	cpc	r17, r23
    2b3e:	0c f4       	brge	.+2      	; 0x2b42 <main+0x362>
    2b40:	bd cf       	rjmp	.-134    	; 0x2abc <main+0x2dc>
    2b42:	0f 2e       	mov	r0, r31
    2b44:	fa e0       	ldi	r31, 0x0A	; 10
    2b46:	cf 2e       	mov	r12, r31
    2b48:	f3 e0       	ldi	r31, 0x03	; 3
    2b4a:	df 2e       	mov	r13, r31
    2b4c:	f0 2d       	mov	r31, r0
 * Example Call:		Called automatically by the Operating System
 *
 */


void main()
    2b4e:	0f 2e       	mov	r0, r31
    2b50:	f6 ea       	ldi	r31, 0xA6	; 166
    2b52:	6f 2e       	mov	r6, r31
    2b54:	f2 e0       	ldi	r31, 0x02	; 2
    2b56:	7f 2e       	mov	r7, r31
    2b58:	f0 2d       	mov	r31, r0
    2b5a:	94 01       	movw	r18, r8
    2b5c:	d6 01       	movw	r26, r12
    2b5e:	e5 01       	movw	r28, r10
    2b60:	fd 01       	movw	r30, r26
                j++;
        }
    }

    for (int i = 0; i < 7; i++) {
        co_ordinate_queue[i] = leftover_blocks[1][i];
    2b62:	1e 96       	adiw	r26, 0x0e	; 14
    2b64:	8d 91       	ld	r24, X+
    2b66:	9c 91       	ld	r25, X
    2b68:	1f 97       	sbiw	r26, 0x0f	; 15
    2b6a:	89 93       	st	Y+, r24
    2b6c:	99 93       	st	Y+, r25
    2b6e:	12 96       	adiw	r26, 0x02	; 2
        queue[i] = leftover_blocks[0][i]; //to put all leftover blocks in queue and co-ordinates for same in co-ordinate queue
    2b70:	80 81       	ld	r24, Z
    2b72:	91 81       	ldd	r25, Z+1	; 0x01
    2b74:	f9 01       	movw	r30, r18
    2b76:	81 93       	st	Z+, r24
    2b78:	91 93       	st	Z+, r25
    2b7a:	9f 01       	movw	r18, r30
            } else
                j++;
        }
    }

    for (int i = 0; i < 7; i++) {
    2b7c:	c6 15       	cp	r28, r6
    2b7e:	d7 05       	cpc	r29, r7
    2b80:	79 f7       	brne	.-34     	; 0x2b60 <main+0x380>
        co_ordinate_queue[i] = leftover_blocks[1][i];
        queue[i] = leftover_blocks[0][i]; //to put all leftover blocks in queue and co-ordinates for same in co-ordinate queue
    }

    stop();
    2b82:	0e 94 45 03 	call	0x68a	; 0x68a <stop>
    place_package(); //place left-over packages from lower boundary
    2b86:	0e 94 d6 11 	call	0x23ac	; 0x23ac <place_package>
    2b8a:	f6 01       	movw	r30, r12
    2b8c:	e5 01       	movw	r28, r10
    2b8e:	d4 01       	movw	r26, r8
    for (int i = 0; i < 7; i++) {
        queue[i] = 0;
    2b90:	1d 92       	st	X+, r1
    2b92:	1d 92       	st	X+, r1
        co_ordinate_queue[i] = 0;
    2b94:	19 92       	st	Y+, r1
    2b96:	19 92       	st	Y+, r1
        leftover_blocks[0][i] = 0;
    2b98:	11 92       	st	Z+, r1
    2b9a:	11 92       	st	Z+, r1
        leftover_blocks[1][i] = 0; //empty leftover queue,queue,co-ordinate queue,reset counter
    2b9c:	15 86       	std	Z+13, r1	; 0x0d
    2b9e:	14 86       	std	Z+12, r1	; 0x0c
        queue[i] = leftover_blocks[0][i]; //to put all leftover blocks in queue and co-ordinates for same in co-ordinate queue
    }

    stop();
    place_package(); //place left-over packages from lower boundary
    for (int i = 0; i < 7; i++) {
    2ba0:	ae 15       	cp	r26, r14
    2ba2:	bf 05       	cpc	r27, r15
    2ba4:	a9 f7       	brne	.-22     	; 0x2b90 <main+0x3b0>
    2ba6:	10 92 09 03 	sts	0x0309, r1
    2baa:	10 92 08 03 	sts	0x0308, r1
    2bae:	e4 ec       	ldi	r30, 0xC4	; 196
    2bb0:	f2 e0       	ldi	r31, 0x02	; 2
 * Example Call:		Called automatically by the Operating System
 *
 */


void main()
    2bb2:	8c e0       	ldi	r24, 0x0C	; 12
    2bb4:	93 e0       	ldi	r25, 0x03	; 3
        leftover_blocks[1][i] = 0; //empty leftover queue,queue,co-ordinate queue,reset counter
        leftover_counter = 0;
        //break;	
    }
    for (int i = 0; i <= 11; i++)
        info_table[i][2] = 0; //reset info-table after lower boundary
    2bb6:	11 82       	std	Z+1, r1	; 0x01
    2bb8:	10 82       	st	Z, r1
    2bba:	36 96       	adiw	r30, 0x06	; 6
        leftover_blocks[0][i] = 0;
        leftover_blocks[1][i] = 0; //empty leftover queue,queue,co-ordinate queue,reset counter
        leftover_counter = 0;
        //break;	
    }
    for (int i = 0; i <= 11; i++)
    2bbc:	e8 17       	cp	r30, r24
    2bbe:	f9 07       	cpc	r31, r25
    2bc0:	d1 f7       	brne	.-12     	; 0x2bb6 <main+0x3d6>
        info_table[i][2] = 0; //reset info-table after lower boundary
    if (current_position == 31 || (current_position >= 12 && current_position <= 14)) {
    2bc2:	80 91 5c 03 	lds	r24, 0x035C
    2bc6:	90 91 5d 03 	lds	r25, 0x035D
    2bca:	8f 31       	cpi	r24, 0x1F	; 31
    2bcc:	91 05       	cpc	r25, r1
    2bce:	c1 f0       	breq	.+48     	; 0x2c00 <main+0x420>
    2bd0:	9c 01       	movw	r18, r24
    2bd2:	2c 50       	subi	r18, 0x0C	; 12
    2bd4:	30 40       	sbci	r19, 0x00	; 0
    2bd6:	23 30       	cpi	r18, 0x03	; 3
    2bd8:	31 05       	cpc	r19, r1
    2bda:	08 f4       	brcc	.+2      	; 0x2bde <main+0x3fe>
    2bdc:	0c c2       	rjmp	.+1048   	; 0x2ff6 <main+0x816>
    2bde:	1a c0       	rjmp	.+52     	; 0x2c14 <main+0x434>
        if ((current_position >= 12 && current_position <= 14) && orie == pointingeast) {
            stop();
    2be0:	0e 94 45 03 	call	0x68a	; 0x68a <stop>
            velocity(220, 223);//
    2be4:	8c ed       	ldi	r24, 0xDC	; 220
    2be6:	6f ed       	ldi	r22, 0xDF	; 223
    2be8:	0e 94 2a 03 	call	0x654	; 0x654 <velocity>
            left_degrees(191);//take u-turn
    2bec:	8f eb       	ldi	r24, 0xBF	; 191
    2bee:	90 e0       	ldi	r25, 0x00	; 0
    2bf0:	0e 94 20 04 	call	0x840	; 0x840 <left_degrees>
            change_orientation();//
    2bf4:	0e 94 9a 11 	call	0x2334	; 0x2334 <change_orientation>
            forward_mm(20);
    2bf8:	84 e1       	ldi	r24, 0x14	; 20
    2bfa:	90 e0       	ldi	r25, 0x00	; 0
    2bfc:	0e 94 0a 04 	call	0x814	; 0x814 <forward_mm>
        }
       

        next_position = 41; //set co-ordinate
    2c00:	89 e2       	ldi	r24, 0x29	; 41
    2c02:	90 e0       	ldi	r25, 0x00	; 0
    2c04:	90 93 68 03 	sts	0x0368, r25
    2c08:	80 93 67 03 	sts	0x0367, r24
        servo_3(0); //reset servo to 0 degrees for next pickup zone
    2c0c:	80 e0       	ldi	r24, 0x00	; 0
    2c0e:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <servo_3>
    2c12:	30 c0       	rjmp	.+96     	; 0x2c74 <main+0x494>
    } else if (current_position == 39 || (current_position >= 16 && current_position <= 18)) {
    2c14:	87 32       	cpi	r24, 0x27	; 39
    2c16:	91 05       	cpc	r25, r1
    2c18:	29 f0       	breq	.+10     	; 0x2c24 <main+0x444>
    2c1a:	40 97       	sbiw	r24, 0x10	; 16
    2c1c:	83 30       	cpi	r24, 0x03	; 3
    2c1e:	91 05       	cpc	r25, r1
    2c20:	28 f0       	brcs	.+10     	; 0x2c2c <main+0x44c>
    2c22:	28 c0       	rjmp	.+80     	; 0x2c74 <main+0x494>
        if ((current_position >= 16 && current_position <= 18) && orie == pointingwest) {
    2c24:	40 97       	sbiw	r24, 0x10	; 16
    2c26:	83 30       	cpi	r24, 0x03	; 3
    2c28:	91 05       	cpc	r25, r1
    2c2a:	d8 f4       	brcc	.+54     	; 0x2c62 <main+0x482>
    2c2c:	80 91 48 03 	lds	r24, 0x0348
    2c30:	90 91 49 03 	lds	r25, 0x0349
    2c34:	20 91 8d 02 	lds	r18, 0x028D
    2c38:	30 91 8e 02 	lds	r19, 0x028E
    2c3c:	82 17       	cp	r24, r18
    2c3e:	93 07       	cpc	r25, r19
    2c40:	81 f4       	brne	.+32     	; 0x2c62 <main+0x482>
            stop();
    2c42:	0e 94 45 03 	call	0x68a	; 0x68a <stop>
            //int x=9;
            velocity(220, 223);//
    2c46:	8c ed       	ldi	r24, 0xDC	; 220
    2c48:	6f ed       	ldi	r22, 0xDF	; 223
    2c4a:	0e 94 2a 03 	call	0x654	; 0x654 <velocity>
            left_degrees(191);//take u-turn
    2c4e:	8f eb       	ldi	r24, 0xBF	; 191
    2c50:	90 e0       	ldi	r25, 0x00	; 0
    2c52:	0e 94 20 04 	call	0x840	; 0x840 <left_degrees>
            change_orientation();//
    2c56:	0e 94 9a 11 	call	0x2334	; 0x2334 <change_orientation>
            forward_mm(20);
    2c5a:	84 e1       	ldi	r24, 0x14	; 20
    2c5c:	90 e0       	ldi	r25, 0x00	; 0
    2c5e:	0e 94 0a 04 	call	0x814	; 0x814 <forward_mm>
        }
       
        next_position = 49;//set co-ordinate
    2c62:	81 e3       	ldi	r24, 0x31	; 49
    2c64:	90 e0       	ldi	r25, 0x00	; 0
    2c66:	90 93 68 03 	sts	0x0368, r25
    2c6a:	80 93 67 03 	sts	0x0367, r24
        servo_3(180);//reset servo to 180 degrees for next co-ordinate
    2c6e:	84 eb       	ldi	r24, 0xB4	; 180
    2c70:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <servo_3>
    }

    travel(current_position, next_position); //travel to next pick up zone
    2c74:	60 91 67 03 	lds	r22, 0x0367
    2c78:	70 91 68 03 	lds	r23, 0x0368
    2c7c:	80 91 5c 03 	lds	r24, 0x035C
    2c80:	90 91 5d 03 	lds	r25, 0x035D
    2c84:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <travel>
    current_position = next_position; //set co-ordinate
    2c88:	80 91 67 03 	lds	r24, 0x0367
    2c8c:	90 91 68 03 	lds	r25, 0x0368
    2c90:	90 93 5d 03 	sts	0x035D, r25
    2c94:	80 93 5c 03 	sts	0x035C, r24
    if (current_position == 41) {
    2c98:	89 32       	cpi	r24, 0x29	; 41
    2c9a:	91 05       	cpc	r25, r1
    2c9c:	49 f4       	brne	.+18     	; 0x2cb0 <main+0x4d0>
        next_position = 42;
    2c9e:	8a e2       	ldi	r24, 0x2A	; 42
    2ca0:	90 e0       	ldi	r25, 0x00	; 0
    2ca2:	90 93 68 03 	sts	0x0368, r25
    2ca6:	80 93 67 03 	sts	0x0367, r24
        last_zone = 46; //set next position co-ordinate
    2caa:	ce e2       	ldi	r28, 0x2E	; 46
    2cac:	d0 e0       	ldi	r29, 0x00	; 0
    2cae:	0e c0       	rjmp	.+28     	; 0x2ccc <main+0x4ec>
    } else if (current_position == 49) {
    2cb0:	81 33       	cpi	r24, 0x31	; 49
    2cb2:	91 05       	cpc	r25, r1
    2cb4:	49 f4       	brne	.+18     	; 0x2cc8 <main+0x4e8>
        next_position = 48;
    2cb6:	80 e3       	ldi	r24, 0x30	; 48
    2cb8:	90 e0       	ldi	r25, 0x00	; 0
    2cba:	90 93 68 03 	sts	0x0368, r25
    2cbe:	80 93 67 03 	sts	0x0367, r24
        last_zone = 44; //set next position co-ordinate
    2cc2:	cc e2       	ldi	r28, 0x2C	; 44
    2cc4:	d0 e0       	ldi	r29, 0x00	; 0
    2cc6:	02 c0       	rjmp	.+4      	; 0x2ccc <main+0x4ec>
    count_blue_zone = count_blue_zone * 2;
    count_green_zone = count_green_zone * 2;
    count_red_zone = count_red_zone * 2;

    flag = 1;
    int last_zone = 0; //has_turned=0;
    2cc8:	c0 e0       	ldi	r28, 0x00	; 0
    2cca:	d0 e0       	ldi	r29, 0x00	; 0
        last_zone = 46; //set next position co-ordinate
    } else if (current_position == 49) {
        next_position = 48;
        last_zone = 44; //set next position co-ordinate
    }
    zone_scan(); //scan the next pick up zones
    2ccc:	0e 94 ed 0f 	call	0x1fda	; 0x1fda <zone_scan>
    path_planning(current_position); //prioritize the scanned blocks for deposition
    2cd0:	80 91 5c 03 	lds	r24, 0x035C
    2cd4:	90 91 5d 03 	lds	r25, 0x035D
    2cd8:	0e 94 c3 0d 	call	0x1b86	; 0x1b86 <path_planning>
    stop();
    2cdc:	0e 94 45 03 	call	0x68a	; 0x68a <stop>
    velocity(220, 223);//
    2ce0:	8c ed       	ldi	r24, 0xDC	; 220
    2ce2:	6f ed       	ldi	r22, 0xDF	; 223
    2ce4:	0e 94 2a 03 	call	0x654	; 0x654 <velocity>
    left_degrees(191);//take u-turn
    2ce8:	8f eb       	ldi	r24, 0xBF	; 191
    2cea:	90 e0       	ldi	r25, 0x00	; 0
    2cec:	0e 94 20 04 	call	0x840	; 0x840 <left_degrees>
    change_orientation();//
    2cf0:	0e 94 9a 11 	call	0x2334	; 0x2334 <change_orientation>

    stop();
    2cf4:	0e 94 45 03 	call	0x68a	; 0x68a <stop>
    place_package(); //place the packages of current pick up zone
    2cf8:	0e 94 d6 11 	call	0x23ac	; 0x23ac <place_package>
    stop();
    2cfc:	0e 94 45 03 	call	0x68a	; 0x68a <stop>
    2d00:	d5 01       	movw	r26, r10
    2d02:	f4 01       	movw	r30, r8
    for (int i = 0; i < 7; i++) {
        queue[i] = 0;
    2d04:	11 92       	st	Z+, r1
    2d06:	11 92       	st	Z+, r1
        co_ordinate_queue[i] = 0; //empty queue
    2d08:	1d 92       	st	X+, r1
    2d0a:	1d 92       	st	X+, r1
    change_orientation();//

    stop();
    place_package(); //place the packages of current pick up zone
    stop();
    for (int i = 0; i < 7; i++) {
    2d0c:	ee 15       	cp	r30, r14
    2d0e:	ff 05       	cpc	r31, r15
    2d10:	c9 f7       	brne	.-14     	; 0x2d04 <main+0x524>
        queue[i] = 0;
        co_ordinate_queue[i] = 0; //empty queue
    }
    if (last_zone == 46) {
    2d12:	ce 32       	cpi	r28, 0x2E	; 46
    2d14:	d1 05       	cpc	r29, r1
    2d16:	09 f0       	breq	.+2      	; 0x2d1a <main+0x53a>
    2d18:	63 c0       	rjmp	.+198    	; 0x2de0 <main+0x600>
        if (orie == pointingwest || orie == pointingsouth || (current_position >= 46 && current_position <= 48 && orie == pointingeast)) {
    2d1a:	20 91 48 03 	lds	r18, 0x0348
    2d1e:	30 91 49 03 	lds	r19, 0x0349
    2d22:	80 91 8d 02 	lds	r24, 0x028D
    2d26:	90 91 8e 02 	lds	r25, 0x028E
    2d2a:	28 17       	cp	r18, r24
    2d2c:	39 07       	cpc	r19, r25
    2d2e:	b1 f0       	breq	.+44     	; 0x2d5c <main+0x57c>
    2d30:	80 91 8f 02 	lds	r24, 0x028F
    2d34:	90 91 90 02 	lds	r25, 0x0290
    2d38:	28 17       	cp	r18, r24
    2d3a:	39 07       	cpc	r19, r25
    2d3c:	79 f0       	breq	.+30     	; 0x2d5c <main+0x57c>
    2d3e:	80 91 5c 03 	lds	r24, 0x035C
    2d42:	90 91 5d 03 	lds	r25, 0x035D
    2d46:	8e 97       	sbiw	r24, 0x2e	; 46
    2d48:	83 30       	cpi	r24, 0x03	; 3
    2d4a:	91 05       	cpc	r25, r1
    2d4c:	98 f4       	brcc	.+38     	; 0x2d74 <main+0x594>
    2d4e:	80 91 91 02 	lds	r24, 0x0291
    2d52:	90 91 92 02 	lds	r25, 0x0292
    2d56:	28 17       	cp	r18, r24
    2d58:	39 07       	cpc	r19, r25
    2d5a:	61 f4       	brne	.+24     	; 0x2d74 <main+0x594>
            stop();
    2d5c:	0e 94 45 03 	call	0x68a	; 0x68a <stop>
            velocity(220, 223);//
    2d60:	8c ed       	ldi	r24, 0xDC	; 220
    2d62:	6f ed       	ldi	r22, 0xDF	; 223
    2d64:	0e 94 2a 03 	call	0x654	; 0x654 <velocity>
            left_degrees(191);//take u-turn
    2d68:	8f eb       	ldi	r24, 0xBF	; 191
    2d6a:	90 e0       	ldi	r25, 0x00	; 0
    2d6c:	0e 94 20 04 	call	0x840	; 0x840 <left_degrees>
            change_orientation();//
    2d70:	0e 94 9a 11 	call	0x2334	; 0x2334 <change_orientation>
        }
        travel(current_position, 45); //travel to co-ordinate 45
    2d74:	80 91 5c 03 	lds	r24, 0x035C
    2d78:	90 91 5d 03 	lds	r25, 0x035D
    2d7c:	6d e2       	ldi	r22, 0x2D	; 45
    2d7e:	70 e0       	ldi	r23, 0x00	; 0
    2d80:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <travel>
        if (orie == pointingwest || orie == pointingnorth) {
    2d84:	20 91 48 03 	lds	r18, 0x0348
    2d88:	30 91 49 03 	lds	r19, 0x0349
    2d8c:	80 91 8d 02 	lds	r24, 0x028D
    2d90:	90 91 8e 02 	lds	r25, 0x028E
    2d94:	28 17       	cp	r18, r24
    2d96:	39 07       	cpc	r19, r25
    2d98:	39 f0       	breq	.+14     	; 0x2da8 <main+0x5c8>
    2d9a:	80 91 93 02 	lds	r24, 0x0293
    2d9e:	90 91 94 02 	lds	r25, 0x0294
    2da2:	28 17       	cp	r18, r24
    2da4:	39 07       	cpc	r19, r25
    2da6:	61 f4       	brne	.+24     	; 0x2dc0 <main+0x5e0>
            stop();
    2da8:	0e 94 45 03 	call	0x68a	; 0x68a <stop>
            velocity(220, 223);//
    2dac:	8c ed       	ldi	r24, 0xDC	; 220
    2dae:	6f ed       	ldi	r22, 0xDF	; 223
    2db0:	0e 94 2a 03 	call	0x654	; 0x654 <velocity>
            left_degrees(191);//take u-turn
    2db4:	8f eb       	ldi	r24, 0xBF	; 191
    2db6:	90 e0       	ldi	r25, 0x00	; 0
    2db8:	0e 94 20 04 	call	0x840	; 0x840 <left_degrees>
            change_orientation();//
    2dbc:	0e 94 9a 11 	call	0x2334	; 0x2334 <change_orientation>
        }
        current_position = 45;
    2dc0:	8d e2       	ldi	r24, 0x2D	; 45
    2dc2:	90 e0       	ldi	r25, 0x00	; 0
    2dc4:	90 93 5d 03 	sts	0x035D, r25
    2dc8:	80 93 5c 03 	sts	0x035C, r24
        next_position = 46;//set current and next co-ordiante
    2dcc:	8e e2       	ldi	r24, 0x2E	; 46
    2dce:	90 e0       	ldi	r25, 0x00	; 0
    2dd0:	90 93 68 03 	sts	0x0368, r25
    2dd4:	80 93 67 03 	sts	0x0367, r24
        servo_3(0);//reset servo angle to 0 degrees for last zone
    2dd8:	80 e0       	ldi	r24, 0x00	; 0
    2dda:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <servo_3>
    2dde:	66 c0       	rjmp	.+204    	; 0x2eac <main+0x6cc>
    } else if (last_zone == 44) {
    2de0:	cc 32       	cpi	r28, 0x2C	; 44
    2de2:	d1 05       	cpc	r29, r1
    2de4:	09 f0       	breq	.+2      	; 0x2de8 <main+0x608>
    2de6:	62 c0       	rjmp	.+196    	; 0x2eac <main+0x6cc>
        if (orie == pointingeast || orie == pointingsouth || (current_position >= 42 && current_position <= 44 && orie == pointingwest)) {
    2de8:	20 91 48 03 	lds	r18, 0x0348
    2dec:	30 91 49 03 	lds	r19, 0x0349
    2df0:	80 91 91 02 	lds	r24, 0x0291
    2df4:	90 91 92 02 	lds	r25, 0x0292
    2df8:	28 17       	cp	r18, r24
    2dfa:	39 07       	cpc	r19, r25
    2dfc:	b1 f0       	breq	.+44     	; 0x2e2a <main+0x64a>
    2dfe:	80 91 8f 02 	lds	r24, 0x028F
    2e02:	90 91 90 02 	lds	r25, 0x0290
    2e06:	28 17       	cp	r18, r24
    2e08:	39 07       	cpc	r19, r25
    2e0a:	79 f0       	breq	.+30     	; 0x2e2a <main+0x64a>
    2e0c:	80 91 5c 03 	lds	r24, 0x035C
    2e10:	90 91 5d 03 	lds	r25, 0x035D
    2e14:	8a 97       	sbiw	r24, 0x2a	; 42
    2e16:	83 30       	cpi	r24, 0x03	; 3
    2e18:	91 05       	cpc	r25, r1
    2e1a:	98 f4       	brcc	.+38     	; 0x2e42 <main+0x662>
    2e1c:	80 91 8d 02 	lds	r24, 0x028D
    2e20:	90 91 8e 02 	lds	r25, 0x028E
    2e24:	28 17       	cp	r18, r24
    2e26:	39 07       	cpc	r19, r25
    2e28:	61 f4       	brne	.+24     	; 0x2e42 <main+0x662>
            stop();
    2e2a:	0e 94 45 03 	call	0x68a	; 0x68a <stop>
            velocity(220, 223);//
    2e2e:	8c ed       	ldi	r24, 0xDC	; 220
    2e30:	6f ed       	ldi	r22, 0xDF	; 223
    2e32:	0e 94 2a 03 	call	0x654	; 0x654 <velocity>
            left_degrees(191);//take u-turn
    2e36:	8f eb       	ldi	r24, 0xBF	; 191
    2e38:	90 e0       	ldi	r25, 0x00	; 0
    2e3a:	0e 94 20 04 	call	0x840	; 0x840 <left_degrees>
            change_orientation();//
    2e3e:	0e 94 9a 11 	call	0x2334	; 0x2334 <change_orientation>
        }
        travel(current_position, 45);//travel to co-ordinate 45
    2e42:	80 91 5c 03 	lds	r24, 0x035C
    2e46:	90 91 5d 03 	lds	r25, 0x035D
    2e4a:	6d e2       	ldi	r22, 0x2D	; 45
    2e4c:	70 e0       	ldi	r23, 0x00	; 0
    2e4e:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <travel>
        if (orie == pointingeast || orie == pointingnorth) {
    2e52:	20 91 48 03 	lds	r18, 0x0348
    2e56:	30 91 49 03 	lds	r19, 0x0349
    2e5a:	80 91 91 02 	lds	r24, 0x0291
    2e5e:	90 91 92 02 	lds	r25, 0x0292
    2e62:	28 17       	cp	r18, r24
    2e64:	39 07       	cpc	r19, r25
    2e66:	39 f0       	breq	.+14     	; 0x2e76 <main+0x696>
    2e68:	80 91 93 02 	lds	r24, 0x0293
    2e6c:	90 91 94 02 	lds	r25, 0x0294
    2e70:	28 17       	cp	r18, r24
    2e72:	39 07       	cpc	r19, r25
    2e74:	61 f4       	brne	.+24     	; 0x2e8e <main+0x6ae>
            stop();
    2e76:	0e 94 45 03 	call	0x68a	; 0x68a <stop>
            velocity(220, 223);//
    2e7a:	8c ed       	ldi	r24, 0xDC	; 220
    2e7c:	6f ed       	ldi	r22, 0xDF	; 223
    2e7e:	0e 94 2a 03 	call	0x654	; 0x654 <velocity>
            left_degrees(191);//take u-turn
    2e82:	8f eb       	ldi	r24, 0xBF	; 191
    2e84:	90 e0       	ldi	r25, 0x00	; 0
    2e86:	0e 94 20 04 	call	0x840	; 0x840 <left_degrees>
            change_orientation();//
    2e8a:	0e 94 9a 11 	call	0x2334	; 0x2334 <change_orientation>
        }
        current_position = 45;
    2e8e:	8d e2       	ldi	r24, 0x2D	; 45
    2e90:	90 e0       	ldi	r25, 0x00	; 0
    2e92:	90 93 5d 03 	sts	0x035D, r25
    2e96:	80 93 5c 03 	sts	0x035C, r24
        next_position = 44;//set co-ordinate
    2e9a:	8c e2       	ldi	r24, 0x2C	; 44
    2e9c:	90 e0       	ldi	r25, 0x00	; 0
    2e9e:	90 93 68 03 	sts	0x0368, r25
    2ea2:	80 93 67 03 	sts	0x0367, r24
        servo_3(180); //reset servo angle to 180 degrees for last zone
    2ea6:	84 eb       	ldi	r24, 0xB4	; 180
    2ea8:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <servo_3>
    }
    zone_scan();//scan the zone
    2eac:	0e 94 ed 0f 	call	0x1fda	; 0x1fda <zone_scan>
    path_planning(current_position);//prioritize the scanned blocks for deposition
    2eb0:	80 91 5c 03 	lds	r24, 0x035C
    2eb4:	90 91 5d 03 	lds	r25, 0x035D
    2eb8:	0e 94 c3 0d 	call	0x1b86	; 0x1b86 <path_planning>
    stop();
    2ebc:	0e 94 45 03 	call	0x68a	; 0x68a <stop>
    velocity(220, 223);//
    2ec0:	8c ed       	ldi	r24, 0xDC	; 220
    2ec2:	6f ed       	ldi	r22, 0xDF	; 223
    2ec4:	0e 94 2a 03 	call	0x654	; 0x654 <velocity>
    left_degrees(191);//take u-turn
    2ec8:	8f eb       	ldi	r24, 0xBF	; 191
    2eca:	90 e0       	ldi	r25, 0x00	; 0
    2ecc:	0e 94 20 04 	call	0x840	; 0x840 <left_degrees>
    change_orientation();//
    2ed0:	0e 94 9a 11 	call	0x2334	; 0x2334 <change_orientation>
    place_package();//place packages for last pick up zone
    2ed4:	0e 94 d6 11 	call	0x23ac	; 0x23ac <place_package>
    stop();
    2ed8:	0e 94 45 03 	call	0x68a	; 0x68a <stop>
    2edc:	d5 01       	movw	r26, r10
    2ede:	f4 01       	movw	r30, r8
    

    for (int i = 0; i < 7; i++) {
        queue[i] = 0;
    2ee0:	11 92       	st	Z+, r1
    2ee2:	11 92       	st	Z+, r1
        co_ordinate_queue[i] = 0; //empty queue
    2ee4:	1d 92       	st	X+, r1
    2ee6:	1d 92       	st	X+, r1
    change_orientation();//
    place_package();//place packages for last pick up zone
    stop();
    

    for (int i = 0; i < 7; i++) {
    2ee8:	ee 15       	cp	r30, r14
    2eea:	ff 05       	cpc	r31, r15
    2eec:	c9 f7       	brne	.-14     	; 0x2ee0 <main+0x700>
        co_ordinate_queue[i] = 0; //empty queue
    }
    size = 7;
    //int i,j,k;
    for (i = 0; i < size; i++) {
        for (j = i + 1; j < size;) {
    2eee:	01 e0       	ldi	r16, 0x01	; 1
    2ef0:	10 e0       	ldi	r17, 0x00	; 0
    change_orientation();//
    place_package();//place packages for last pick up zone
    stop();
    

    for (int i = 0; i < 7; i++) {
    2ef2:	c0 e0       	ldi	r28, 0x00	; 0
    2ef4:	d0 e0       	ldi	r29, 0x00	; 0
        co_ordinate_queue[i] = 0; //empty queue
    }
    size = 7;
    //int i,j,k;
    for (i = 0; i < size; i++) {
        for (j = i + 1; j < size;) {
    2ef6:	41 e0       	ldi	r20, 0x01	; 1
    2ef8:	50 e0       	ldi	r21, 0x00	; 0
    change_orientation();//
    place_package();//place packages for last pick up zone
    stop();
    

    for (int i = 0; i < 7; i++) {
    2efa:	67 e0       	ldi	r22, 0x07	; 7
    2efc:	70 e0       	ldi	r23, 0x00	; 0
    }
    size = 7;
    //int i,j,k;
    for (i = 0; i < size; i++) {
        for (j = i + 1; j < size;) {
            if (leftover_blocks[1][j] == leftover_blocks[1][i]) {
    2efe:	aa e0       	ldi	r26, 0x0A	; 10
    2f00:	b3 e0       	ldi	r27, 0x03	; 3
    2f02:	08 c0       	rjmp	.+16     	; 0x2f14 <main+0x734>
        co_ordinate_queue[i] = 0; //empty queue
    }
    size = 7;
    //int i,j,k;
    for (i = 0; i < size; i++) {
        for (j = i + 1; j < size;) {
    2f04:	a8 01       	movw	r20, r16
    2f06:	4f 5f       	subi	r20, 0xFF	; 255
    2f08:	5f 4f       	sbci	r21, 0xFF	; 255
    2f0a:	46 17       	cp	r20, r22
    2f0c:	57 07       	cpc	r21, r23
    2f0e:	ec f5       	brge	.+122    	; 0x2f8a <main+0x7aa>
    2f10:	e8 01       	movw	r28, r16
    2f12:	8a 01       	movw	r16, r20
            if (leftover_blocks[1][j] == leftover_blocks[1][i]) {
    2f14:	ca 01       	movw	r24, r20
    2f16:	07 96       	adiw	r24, 0x07	; 7
    2f18:	88 0f       	add	r24, r24
    2f1a:	99 1f       	adc	r25, r25
    2f1c:	fd 01       	movw	r30, r26
    2f1e:	e8 0f       	add	r30, r24
    2f20:	f9 1f       	adc	r31, r25
    2f22:	ce 01       	movw	r24, r28
    2f24:	07 96       	adiw	r24, 0x07	; 7
    2f26:	88 0f       	add	r24, r24
    2f28:	99 1f       	adc	r25, r25
    2f2a:	8a 0f       	add	r24, r26
    2f2c:	9b 1f       	adc	r25, r27
    2f2e:	20 81       	ld	r18, Z
    2f30:	31 81       	ldd	r19, Z+1	; 0x01
    2f32:	fc 01       	movw	r30, r24
    2f34:	80 81       	ld	r24, Z
    2f36:	91 81       	ldd	r25, Z+1	; 0x01
    2f38:	28 17       	cp	r18, r24
    2f3a:	39 07       	cpc	r19, r25
    2f3c:	e9 f4       	brne	.+58     	; 0x2f78 <main+0x798>
                for (k = j; k < size; k++) {
    2f3e:	46 17       	cp	r20, r22
    2f40:	57 07       	cpc	r21, r23
    2f42:	bc f4       	brge	.+46     	; 0x2f72 <main+0x792>
 * Example Call:		Called automatically by the Operating System
 *
 */


void main()
    2f44:	ca 01       	movw	r24, r20
    2f46:	88 0f       	add	r24, r24
    2f48:	99 1f       	adc	r25, r25
    2f4a:	fc 01       	movw	r30, r24
    2f4c:	e6 5f       	subi	r30, 0xF6	; 246
    2f4e:	fc 4f       	sbci	r31, 0xFC	; 252
    2f50:	cb 01       	movw	r24, r22
    2f52:	88 0f       	add	r24, r24
    2f54:	99 1f       	adc	r25, r25
    2f56:	9c 01       	movw	r18, r24
    2f58:	26 5f       	subi	r18, 0xF6	; 246
    2f5a:	3c 4f       	sbci	r19, 0xFC	; 252
    //int i,j,k;
    for (i = 0; i < size; i++) {
        for (j = i + 1; j < size;) {
            if (leftover_blocks[1][j] == leftover_blocks[1][i]) {
                for (k = j; k < size; k++) {
                    leftover_blocks[1][k] = leftover_blocks[1][k + 1];
    2f5c:	80 89       	ldd	r24, Z+16	; 0x10
    2f5e:	91 89       	ldd	r25, Z+17	; 0x11
    2f60:	97 87       	std	Z+15, r25	; 0x0f
    2f62:	86 87       	std	Z+14, r24	; 0x0e
                    leftover_blocks[0][k] = leftover_blocks[0][k + 1];//shuffle blocks to leftover queue
    2f64:	82 81       	ldd	r24, Z+2	; 0x02
    2f66:	93 81       	ldd	r25, Z+3	; 0x03
    2f68:	81 93       	st	Z+, r24
    2f6a:	91 93       	st	Z+, r25
    size = 7;
    //int i,j,k;
    for (i = 0; i < size; i++) {
        for (j = i + 1; j < size;) {
            if (leftover_blocks[1][j] == leftover_blocks[1][i]) {
                for (k = j; k < size; k++) {
    2f6c:	e2 17       	cp	r30, r18
    2f6e:	f3 07       	cpc	r31, r19
    2f70:	a9 f7       	brne	.-22     	; 0x2f5c <main+0x77c>
                    leftover_blocks[1][k] = leftover_blocks[1][k + 1];
                    leftover_blocks[0][k] = leftover_blocks[0][k + 1];//shuffle blocks to leftover queue
                }
                size--;
    2f72:	61 50       	subi	r22, 0x01	; 1
    2f74:	70 40       	sbci	r23, 0x00	; 0
    2f76:	02 c0       	rjmp	.+4      	; 0x2f7c <main+0x79c>
            } else
                j++;
    2f78:	4f 5f       	subi	r20, 0xFF	; 255
    2f7a:	5f 4f       	sbci	r21, 0xFF	; 255
        co_ordinate_queue[i] = 0; //empty queue
    }
    size = 7;
    //int i,j,k;
    for (i = 0; i < size; i++) {
        for (j = i + 1; j < size;) {
    2f7c:	46 17       	cp	r20, r22
    2f7e:	57 07       	cpc	r21, r23
    2f80:	4c f2       	brlt	.-110    	; 0x2f14 <main+0x734>
        queue[i] = 0;
        co_ordinate_queue[i] = 0; //empty queue
    }
    size = 7;
    //int i,j,k;
    for (i = 0; i < size; i++) {
    2f82:	06 17       	cp	r16, r22
    2f84:	17 07       	cpc	r17, r23
    2f86:	0c f4       	brge	.+2      	; 0x2f8a <main+0x7aa>
    2f88:	bd cf       	rjmp	.-134    	; 0x2f04 <main+0x724>
 * Example Call:		Called automatically by the Operating System
 *
 */


void main()
    2f8a:	f6 01       	movw	r30, r12
                j++;
        }
    }
    
    for (int i = 0; i < 7; i++) {
        co_ordinate_queue[i] = leftover_blocks[1][i];//place leftover blocks in queue
    2f8c:	86 85       	ldd	r24, Z+14	; 0x0e
    2f8e:	97 85       	ldd	r25, Z+15	; 0x0f
    2f90:	d5 01       	movw	r26, r10
    2f92:	8d 93       	st	X+, r24
    2f94:	9d 93       	st	X+, r25
    2f96:	5d 01       	movw	r10, r26
    2f98:	82 e0       	ldi	r24, 0x02	; 2
    2f9a:	90 e0       	ldi	r25, 0x00	; 0
    2f9c:	c8 0e       	add	r12, r24
    2f9e:	d9 1e       	adc	r13, r25
        queue[i] = leftover_blocks[0][i];
    2fa0:	80 81       	ld	r24, Z
    2fa2:	91 81       	ldd	r25, Z+1	; 0x01
    2fa4:	d4 01       	movw	r26, r8
    2fa6:	8d 93       	st	X+, r24
    2fa8:	9d 93       	st	X+, r25
    2faa:	4d 01       	movw	r8, r26
            } else
                j++;
        }
    }
    
    for (int i = 0; i < 7; i++) {
    2fac:	a6 14       	cp	r10, r6
    2fae:	b7 04       	cpc	r11, r7
    2fb0:	61 f7       	brne	.-40     	; 0x2f8a <main+0x7aa>
        co_ordinate_queue[i] = leftover_blocks[1][i];//place leftover blocks in queue
        queue[i] = leftover_blocks[0][i];
    }
    ;
    stop();
    2fb2:	0e 94 45 03 	call	0x68a	; 0x68a <stop>
    place_package(); //place the last packages from upper boundary to zones
    2fb6:	0e 94 d6 11 	call	0x23ac	; 0x23ac <place_package>
    stop();
    2fba:	0e 94 45 03 	call	0x68a	; 0x68a <stop>
    buzzer_on();//
    2fbe:	0e 94 22 03 	call	0x644	; 0x644 <buzzer_on>
    2fc2:	8f ef       	ldi	r24, 0xFF	; 255
    2fc4:	9f e3       	ldi	r25, 0x3F	; 63
    2fc6:	a3 ee       	ldi	r26, 0xE3	; 227
    2fc8:	81 50       	subi	r24, 0x01	; 1
    2fca:	90 40       	sbci	r25, 0x00	; 0
    2fcc:	a0 40       	sbci	r26, 0x00	; 0
    2fce:	e1 f7       	brne	.-8      	; 0x2fc8 <main+0x7e8>
    2fd0:	00 c0       	rjmp	.+0      	; 0x2fd2 <main+0x7f2>
    2fd2:	00 00       	nop
    _delay_ms(5050);//end task
    buzzer_off();//
    2fd4:	0e 94 26 03 	call	0x64c	; 0x64c <buzzer_off>

}
    2fd8:	df 91       	pop	r29
    2fda:	cf 91       	pop	r28
    2fdc:	1f 91       	pop	r17
    2fde:	0f 91       	pop	r16
    2fe0:	ff 90       	pop	r15
    2fe2:	ef 90       	pop	r14
    2fe4:	df 90       	pop	r13
    2fe6:	cf 90       	pop	r12
    2fe8:	bf 90       	pop	r11
    2fea:	af 90       	pop	r10
    2fec:	9f 90       	pop	r9
    2fee:	8f 90       	pop	r8
    2ff0:	7f 90       	pop	r7
    2ff2:	6f 90       	pop	r6
    2ff4:	08 95       	ret
        //break;	
    }
    for (int i = 0; i <= 11; i++)
        info_table[i][2] = 0; //reset info-table after lower boundary
    if (current_position == 31 || (current_position >= 12 && current_position <= 14)) {
        if ((current_position >= 12 && current_position <= 14) && orie == pointingeast) {
    2ff6:	80 91 48 03 	lds	r24, 0x0348
    2ffa:	90 91 49 03 	lds	r25, 0x0349
    2ffe:	20 91 91 02 	lds	r18, 0x0291
    3002:	30 91 92 02 	lds	r19, 0x0292
    3006:	82 17       	cp	r24, r18
    3008:	93 07       	cpc	r25, r19
    300a:	09 f0       	breq	.+2      	; 0x300e <main+0x82e>
    300c:	f9 cd       	rjmp	.-1038   	; 0x2c00 <main+0x420>
    300e:	e8 cd       	rjmp	.-1072   	; 0x2be0 <main+0x400>

00003010 <__subsf3>:
    3010:	50 58       	subi	r21, 0x80	; 128

00003012 <__addsf3>:
    3012:	bb 27       	eor	r27, r27
    3014:	aa 27       	eor	r26, r26
    3016:	0e d0       	rcall	.+28     	; 0x3034 <__addsf3x>
    3018:	4d c1       	rjmp	.+666    	; 0x32b4 <__fp_round>
    301a:	3e d1       	rcall	.+636    	; 0x3298 <__fp_pscA>
    301c:	30 f0       	brcs	.+12     	; 0x302a <__addsf3+0x18>
    301e:	43 d1       	rcall	.+646    	; 0x32a6 <__fp_pscB>
    3020:	20 f0       	brcs	.+8      	; 0x302a <__addsf3+0x18>
    3022:	31 f4       	brne	.+12     	; 0x3030 <__addsf3+0x1e>
    3024:	9f 3f       	cpi	r25, 0xFF	; 255
    3026:	11 f4       	brne	.+4      	; 0x302c <__addsf3+0x1a>
    3028:	1e f4       	brtc	.+6      	; 0x3030 <__addsf3+0x1e>
    302a:	33 c1       	rjmp	.+614    	; 0x3292 <__fp_nan>
    302c:	0e f4       	brtc	.+2      	; 0x3030 <__addsf3+0x1e>
    302e:	e0 95       	com	r30
    3030:	e7 fb       	bst	r30, 7
    3032:	29 c1       	rjmp	.+594    	; 0x3286 <__fp_inf>

00003034 <__addsf3x>:
    3034:	e9 2f       	mov	r30, r25
    3036:	4f d1       	rcall	.+670    	; 0x32d6 <__fp_split3>
    3038:	80 f3       	brcs	.-32     	; 0x301a <__addsf3+0x8>
    303a:	ba 17       	cp	r27, r26
    303c:	62 07       	cpc	r22, r18
    303e:	73 07       	cpc	r23, r19
    3040:	84 07       	cpc	r24, r20
    3042:	95 07       	cpc	r25, r21
    3044:	18 f0       	brcs	.+6      	; 0x304c <__addsf3x+0x18>
    3046:	71 f4       	brne	.+28     	; 0x3064 <__addsf3x+0x30>
    3048:	9e f5       	brtc	.+102    	; 0x30b0 <__addsf3x+0x7c>
    304a:	67 c1       	rjmp	.+718    	; 0x331a <__fp_zero>
    304c:	0e f4       	brtc	.+2      	; 0x3050 <__addsf3x+0x1c>
    304e:	e0 95       	com	r30
    3050:	0b 2e       	mov	r0, r27
    3052:	ba 2f       	mov	r27, r26
    3054:	a0 2d       	mov	r26, r0
    3056:	0b 01       	movw	r0, r22
    3058:	b9 01       	movw	r22, r18
    305a:	90 01       	movw	r18, r0
    305c:	0c 01       	movw	r0, r24
    305e:	ca 01       	movw	r24, r20
    3060:	a0 01       	movw	r20, r0
    3062:	11 24       	eor	r1, r1
    3064:	ff 27       	eor	r31, r31
    3066:	59 1b       	sub	r21, r25
    3068:	99 f0       	breq	.+38     	; 0x3090 <__addsf3x+0x5c>
    306a:	59 3f       	cpi	r21, 0xF9	; 249
    306c:	50 f4       	brcc	.+20     	; 0x3082 <__addsf3x+0x4e>
    306e:	50 3e       	cpi	r21, 0xE0	; 224
    3070:	68 f1       	brcs	.+90     	; 0x30cc <__addsf3x+0x98>
    3072:	1a 16       	cp	r1, r26
    3074:	f0 40       	sbci	r31, 0x00	; 0
    3076:	a2 2f       	mov	r26, r18
    3078:	23 2f       	mov	r18, r19
    307a:	34 2f       	mov	r19, r20
    307c:	44 27       	eor	r20, r20
    307e:	58 5f       	subi	r21, 0xF8	; 248
    3080:	f3 cf       	rjmp	.-26     	; 0x3068 <__addsf3x+0x34>
    3082:	46 95       	lsr	r20
    3084:	37 95       	ror	r19
    3086:	27 95       	ror	r18
    3088:	a7 95       	ror	r26
    308a:	f0 40       	sbci	r31, 0x00	; 0
    308c:	53 95       	inc	r21
    308e:	c9 f7       	brne	.-14     	; 0x3082 <__addsf3x+0x4e>
    3090:	7e f4       	brtc	.+30     	; 0x30b0 <__addsf3x+0x7c>
    3092:	1f 16       	cp	r1, r31
    3094:	ba 0b       	sbc	r27, r26
    3096:	62 0b       	sbc	r22, r18
    3098:	73 0b       	sbc	r23, r19
    309a:	84 0b       	sbc	r24, r20
    309c:	ba f0       	brmi	.+46     	; 0x30cc <__addsf3x+0x98>
    309e:	91 50       	subi	r25, 0x01	; 1
    30a0:	a1 f0       	breq	.+40     	; 0x30ca <__addsf3x+0x96>
    30a2:	ff 0f       	add	r31, r31
    30a4:	bb 1f       	adc	r27, r27
    30a6:	66 1f       	adc	r22, r22
    30a8:	77 1f       	adc	r23, r23
    30aa:	88 1f       	adc	r24, r24
    30ac:	c2 f7       	brpl	.-16     	; 0x309e <__addsf3x+0x6a>
    30ae:	0e c0       	rjmp	.+28     	; 0x30cc <__addsf3x+0x98>
    30b0:	ba 0f       	add	r27, r26
    30b2:	62 1f       	adc	r22, r18
    30b4:	73 1f       	adc	r23, r19
    30b6:	84 1f       	adc	r24, r20
    30b8:	48 f4       	brcc	.+18     	; 0x30cc <__addsf3x+0x98>
    30ba:	87 95       	ror	r24
    30bc:	77 95       	ror	r23
    30be:	67 95       	ror	r22
    30c0:	b7 95       	ror	r27
    30c2:	f7 95       	ror	r31
    30c4:	9e 3f       	cpi	r25, 0xFE	; 254
    30c6:	08 f0       	brcs	.+2      	; 0x30ca <__addsf3x+0x96>
    30c8:	b3 cf       	rjmp	.-154    	; 0x3030 <__addsf3+0x1e>
    30ca:	93 95       	inc	r25
    30cc:	88 0f       	add	r24, r24
    30ce:	08 f0       	brcs	.+2      	; 0x30d2 <__addsf3x+0x9e>
    30d0:	99 27       	eor	r25, r25
    30d2:	ee 0f       	add	r30, r30
    30d4:	97 95       	ror	r25
    30d6:	87 95       	ror	r24
    30d8:	08 95       	ret

000030da <__divsf3>:
    30da:	0c d0       	rcall	.+24     	; 0x30f4 <__divsf3x>
    30dc:	eb c0       	rjmp	.+470    	; 0x32b4 <__fp_round>
    30de:	e3 d0       	rcall	.+454    	; 0x32a6 <__fp_pscB>
    30e0:	40 f0       	brcs	.+16     	; 0x30f2 <__divsf3+0x18>
    30e2:	da d0       	rcall	.+436    	; 0x3298 <__fp_pscA>
    30e4:	30 f0       	brcs	.+12     	; 0x30f2 <__divsf3+0x18>
    30e6:	21 f4       	brne	.+8      	; 0x30f0 <__divsf3+0x16>
    30e8:	5f 3f       	cpi	r21, 0xFF	; 255
    30ea:	19 f0       	breq	.+6      	; 0x30f2 <__divsf3+0x18>
    30ec:	cc c0       	rjmp	.+408    	; 0x3286 <__fp_inf>
    30ee:	51 11       	cpse	r21, r1
    30f0:	15 c1       	rjmp	.+554    	; 0x331c <__fp_szero>
    30f2:	cf c0       	rjmp	.+414    	; 0x3292 <__fp_nan>

000030f4 <__divsf3x>:
    30f4:	f0 d0       	rcall	.+480    	; 0x32d6 <__fp_split3>
    30f6:	98 f3       	brcs	.-26     	; 0x30de <__divsf3+0x4>

000030f8 <__divsf3_pse>:
    30f8:	99 23       	and	r25, r25
    30fa:	c9 f3       	breq	.-14     	; 0x30ee <__divsf3+0x14>
    30fc:	55 23       	and	r21, r21
    30fe:	b1 f3       	breq	.-20     	; 0x30ec <__divsf3+0x12>
    3100:	95 1b       	sub	r25, r21
    3102:	55 0b       	sbc	r21, r21
    3104:	bb 27       	eor	r27, r27
    3106:	aa 27       	eor	r26, r26
    3108:	62 17       	cp	r22, r18
    310a:	73 07       	cpc	r23, r19
    310c:	84 07       	cpc	r24, r20
    310e:	38 f0       	brcs	.+14     	; 0x311e <__divsf3_pse+0x26>
    3110:	9f 5f       	subi	r25, 0xFF	; 255
    3112:	5f 4f       	sbci	r21, 0xFF	; 255
    3114:	22 0f       	add	r18, r18
    3116:	33 1f       	adc	r19, r19
    3118:	44 1f       	adc	r20, r20
    311a:	aa 1f       	adc	r26, r26
    311c:	a9 f3       	breq	.-22     	; 0x3108 <__divsf3_pse+0x10>
    311e:	33 d0       	rcall	.+102    	; 0x3186 <__divsf3_pse+0x8e>
    3120:	0e 2e       	mov	r0, r30
    3122:	3a f0       	brmi	.+14     	; 0x3132 <__divsf3_pse+0x3a>
    3124:	e0 e8       	ldi	r30, 0x80	; 128
    3126:	30 d0       	rcall	.+96     	; 0x3188 <__divsf3_pse+0x90>
    3128:	91 50       	subi	r25, 0x01	; 1
    312a:	50 40       	sbci	r21, 0x00	; 0
    312c:	e6 95       	lsr	r30
    312e:	00 1c       	adc	r0, r0
    3130:	ca f7       	brpl	.-14     	; 0x3124 <__divsf3_pse+0x2c>
    3132:	29 d0       	rcall	.+82     	; 0x3186 <__divsf3_pse+0x8e>
    3134:	fe 2f       	mov	r31, r30
    3136:	27 d0       	rcall	.+78     	; 0x3186 <__divsf3_pse+0x8e>
    3138:	66 0f       	add	r22, r22
    313a:	77 1f       	adc	r23, r23
    313c:	88 1f       	adc	r24, r24
    313e:	bb 1f       	adc	r27, r27
    3140:	26 17       	cp	r18, r22
    3142:	37 07       	cpc	r19, r23
    3144:	48 07       	cpc	r20, r24
    3146:	ab 07       	cpc	r26, r27
    3148:	b0 e8       	ldi	r27, 0x80	; 128
    314a:	09 f0       	breq	.+2      	; 0x314e <__divsf3_pse+0x56>
    314c:	bb 0b       	sbc	r27, r27
    314e:	80 2d       	mov	r24, r0
    3150:	bf 01       	movw	r22, r30
    3152:	ff 27       	eor	r31, r31
    3154:	93 58       	subi	r25, 0x83	; 131
    3156:	5f 4f       	sbci	r21, 0xFF	; 255
    3158:	2a f0       	brmi	.+10     	; 0x3164 <__divsf3_pse+0x6c>
    315a:	9e 3f       	cpi	r25, 0xFE	; 254
    315c:	51 05       	cpc	r21, r1
    315e:	68 f0       	brcs	.+26     	; 0x317a <__divsf3_pse+0x82>
    3160:	92 c0       	rjmp	.+292    	; 0x3286 <__fp_inf>
    3162:	dc c0       	rjmp	.+440    	; 0x331c <__fp_szero>
    3164:	5f 3f       	cpi	r21, 0xFF	; 255
    3166:	ec f3       	brlt	.-6      	; 0x3162 <__divsf3_pse+0x6a>
    3168:	98 3e       	cpi	r25, 0xE8	; 232
    316a:	dc f3       	brlt	.-10     	; 0x3162 <__divsf3_pse+0x6a>
    316c:	86 95       	lsr	r24
    316e:	77 95       	ror	r23
    3170:	67 95       	ror	r22
    3172:	b7 95       	ror	r27
    3174:	f7 95       	ror	r31
    3176:	9f 5f       	subi	r25, 0xFF	; 255
    3178:	c9 f7       	brne	.-14     	; 0x316c <__divsf3_pse+0x74>
    317a:	88 0f       	add	r24, r24
    317c:	91 1d       	adc	r25, r1
    317e:	96 95       	lsr	r25
    3180:	87 95       	ror	r24
    3182:	97 f9       	bld	r25, 7
    3184:	08 95       	ret
    3186:	e1 e0       	ldi	r30, 0x01	; 1
    3188:	66 0f       	add	r22, r22
    318a:	77 1f       	adc	r23, r23
    318c:	88 1f       	adc	r24, r24
    318e:	bb 1f       	adc	r27, r27
    3190:	62 17       	cp	r22, r18
    3192:	73 07       	cpc	r23, r19
    3194:	84 07       	cpc	r24, r20
    3196:	ba 07       	cpc	r27, r26
    3198:	20 f0       	brcs	.+8      	; 0x31a2 <__divsf3_pse+0xaa>
    319a:	62 1b       	sub	r22, r18
    319c:	73 0b       	sbc	r23, r19
    319e:	84 0b       	sbc	r24, r20
    31a0:	ba 0b       	sbc	r27, r26
    31a2:	ee 1f       	adc	r30, r30
    31a4:	88 f7       	brcc	.-30     	; 0x3188 <__divsf3_pse+0x90>
    31a6:	e0 95       	com	r30
    31a8:	08 95       	ret

000031aa <__fixsfsi>:
    31aa:	04 d0       	rcall	.+8      	; 0x31b4 <__fixunssfsi>
    31ac:	68 94       	set
    31ae:	b1 11       	cpse	r27, r1
    31b0:	b5 c0       	rjmp	.+362    	; 0x331c <__fp_szero>
    31b2:	08 95       	ret

000031b4 <__fixunssfsi>:
    31b4:	98 d0       	rcall	.+304    	; 0x32e6 <__fp_splitA>
    31b6:	88 f0       	brcs	.+34     	; 0x31da <__fixunssfsi+0x26>
    31b8:	9f 57       	subi	r25, 0x7F	; 127
    31ba:	90 f0       	brcs	.+36     	; 0x31e0 <__fixunssfsi+0x2c>
    31bc:	b9 2f       	mov	r27, r25
    31be:	99 27       	eor	r25, r25
    31c0:	b7 51       	subi	r27, 0x17	; 23
    31c2:	a0 f0       	brcs	.+40     	; 0x31ec <__fixunssfsi+0x38>
    31c4:	d1 f0       	breq	.+52     	; 0x31fa <__fixunssfsi+0x46>
    31c6:	66 0f       	add	r22, r22
    31c8:	77 1f       	adc	r23, r23
    31ca:	88 1f       	adc	r24, r24
    31cc:	99 1f       	adc	r25, r25
    31ce:	1a f0       	brmi	.+6      	; 0x31d6 <__fixunssfsi+0x22>
    31d0:	ba 95       	dec	r27
    31d2:	c9 f7       	brne	.-14     	; 0x31c6 <__fixunssfsi+0x12>
    31d4:	12 c0       	rjmp	.+36     	; 0x31fa <__fixunssfsi+0x46>
    31d6:	b1 30       	cpi	r27, 0x01	; 1
    31d8:	81 f0       	breq	.+32     	; 0x31fa <__fixunssfsi+0x46>
    31da:	9f d0       	rcall	.+318    	; 0x331a <__fp_zero>
    31dc:	b1 e0       	ldi	r27, 0x01	; 1
    31de:	08 95       	ret
    31e0:	9c c0       	rjmp	.+312    	; 0x331a <__fp_zero>
    31e2:	67 2f       	mov	r22, r23
    31e4:	78 2f       	mov	r23, r24
    31e6:	88 27       	eor	r24, r24
    31e8:	b8 5f       	subi	r27, 0xF8	; 248
    31ea:	39 f0       	breq	.+14     	; 0x31fa <__fixunssfsi+0x46>
    31ec:	b9 3f       	cpi	r27, 0xF9	; 249
    31ee:	cc f3       	brlt	.-14     	; 0x31e2 <__fixunssfsi+0x2e>
    31f0:	86 95       	lsr	r24
    31f2:	77 95       	ror	r23
    31f4:	67 95       	ror	r22
    31f6:	b3 95       	inc	r27
    31f8:	d9 f7       	brne	.-10     	; 0x31f0 <__fixunssfsi+0x3c>
    31fa:	3e f4       	brtc	.+14     	; 0x320a <__fixunssfsi+0x56>
    31fc:	90 95       	com	r25
    31fe:	80 95       	com	r24
    3200:	70 95       	com	r23
    3202:	61 95       	neg	r22
    3204:	7f 4f       	sbci	r23, 0xFF	; 255
    3206:	8f 4f       	sbci	r24, 0xFF	; 255
    3208:	9f 4f       	sbci	r25, 0xFF	; 255
    320a:	08 95       	ret

0000320c <__floatunsisf>:
    320c:	e8 94       	clt
    320e:	09 c0       	rjmp	.+18     	; 0x3222 <__floatsisf+0x12>

00003210 <__floatsisf>:
    3210:	97 fb       	bst	r25, 7
    3212:	3e f4       	brtc	.+14     	; 0x3222 <__floatsisf+0x12>
    3214:	90 95       	com	r25
    3216:	80 95       	com	r24
    3218:	70 95       	com	r23
    321a:	61 95       	neg	r22
    321c:	7f 4f       	sbci	r23, 0xFF	; 255
    321e:	8f 4f       	sbci	r24, 0xFF	; 255
    3220:	9f 4f       	sbci	r25, 0xFF	; 255
    3222:	99 23       	and	r25, r25
    3224:	a9 f0       	breq	.+42     	; 0x3250 <__floatsisf+0x40>
    3226:	f9 2f       	mov	r31, r25
    3228:	96 e9       	ldi	r25, 0x96	; 150
    322a:	bb 27       	eor	r27, r27
    322c:	93 95       	inc	r25
    322e:	f6 95       	lsr	r31
    3230:	87 95       	ror	r24
    3232:	77 95       	ror	r23
    3234:	67 95       	ror	r22
    3236:	b7 95       	ror	r27
    3238:	f1 11       	cpse	r31, r1
    323a:	f8 cf       	rjmp	.-16     	; 0x322c <__floatsisf+0x1c>
    323c:	fa f4       	brpl	.+62     	; 0x327c <__floatsisf+0x6c>
    323e:	bb 0f       	add	r27, r27
    3240:	11 f4       	brne	.+4      	; 0x3246 <__floatsisf+0x36>
    3242:	60 ff       	sbrs	r22, 0
    3244:	1b c0       	rjmp	.+54     	; 0x327c <__floatsisf+0x6c>
    3246:	6f 5f       	subi	r22, 0xFF	; 255
    3248:	7f 4f       	sbci	r23, 0xFF	; 255
    324a:	8f 4f       	sbci	r24, 0xFF	; 255
    324c:	9f 4f       	sbci	r25, 0xFF	; 255
    324e:	16 c0       	rjmp	.+44     	; 0x327c <__floatsisf+0x6c>
    3250:	88 23       	and	r24, r24
    3252:	11 f0       	breq	.+4      	; 0x3258 <__floatsisf+0x48>
    3254:	96 e9       	ldi	r25, 0x96	; 150
    3256:	11 c0       	rjmp	.+34     	; 0x327a <__floatsisf+0x6a>
    3258:	77 23       	and	r23, r23
    325a:	21 f0       	breq	.+8      	; 0x3264 <__floatsisf+0x54>
    325c:	9e e8       	ldi	r25, 0x8E	; 142
    325e:	87 2f       	mov	r24, r23
    3260:	76 2f       	mov	r23, r22
    3262:	05 c0       	rjmp	.+10     	; 0x326e <__floatsisf+0x5e>
    3264:	66 23       	and	r22, r22
    3266:	71 f0       	breq	.+28     	; 0x3284 <__floatsisf+0x74>
    3268:	96 e8       	ldi	r25, 0x86	; 134
    326a:	86 2f       	mov	r24, r22
    326c:	70 e0       	ldi	r23, 0x00	; 0
    326e:	60 e0       	ldi	r22, 0x00	; 0
    3270:	2a f0       	brmi	.+10     	; 0x327c <__floatsisf+0x6c>
    3272:	9a 95       	dec	r25
    3274:	66 0f       	add	r22, r22
    3276:	77 1f       	adc	r23, r23
    3278:	88 1f       	adc	r24, r24
    327a:	da f7       	brpl	.-10     	; 0x3272 <__floatsisf+0x62>
    327c:	88 0f       	add	r24, r24
    327e:	96 95       	lsr	r25
    3280:	87 95       	ror	r24
    3282:	97 f9       	bld	r25, 7
    3284:	08 95       	ret

00003286 <__fp_inf>:
    3286:	97 f9       	bld	r25, 7
    3288:	9f 67       	ori	r25, 0x7F	; 127
    328a:	80 e8       	ldi	r24, 0x80	; 128
    328c:	70 e0       	ldi	r23, 0x00	; 0
    328e:	60 e0       	ldi	r22, 0x00	; 0
    3290:	08 95       	ret

00003292 <__fp_nan>:
    3292:	9f ef       	ldi	r25, 0xFF	; 255
    3294:	80 ec       	ldi	r24, 0xC0	; 192
    3296:	08 95       	ret

00003298 <__fp_pscA>:
    3298:	00 24       	eor	r0, r0
    329a:	0a 94       	dec	r0
    329c:	16 16       	cp	r1, r22
    329e:	17 06       	cpc	r1, r23
    32a0:	18 06       	cpc	r1, r24
    32a2:	09 06       	cpc	r0, r25
    32a4:	08 95       	ret

000032a6 <__fp_pscB>:
    32a6:	00 24       	eor	r0, r0
    32a8:	0a 94       	dec	r0
    32aa:	12 16       	cp	r1, r18
    32ac:	13 06       	cpc	r1, r19
    32ae:	14 06       	cpc	r1, r20
    32b0:	05 06       	cpc	r0, r21
    32b2:	08 95       	ret

000032b4 <__fp_round>:
    32b4:	09 2e       	mov	r0, r25
    32b6:	03 94       	inc	r0
    32b8:	00 0c       	add	r0, r0
    32ba:	11 f4       	brne	.+4      	; 0x32c0 <__fp_round+0xc>
    32bc:	88 23       	and	r24, r24
    32be:	52 f0       	brmi	.+20     	; 0x32d4 <__fp_round+0x20>
    32c0:	bb 0f       	add	r27, r27
    32c2:	40 f4       	brcc	.+16     	; 0x32d4 <__fp_round+0x20>
    32c4:	bf 2b       	or	r27, r31
    32c6:	11 f4       	brne	.+4      	; 0x32cc <__fp_round+0x18>
    32c8:	60 ff       	sbrs	r22, 0
    32ca:	04 c0       	rjmp	.+8      	; 0x32d4 <__fp_round+0x20>
    32cc:	6f 5f       	subi	r22, 0xFF	; 255
    32ce:	7f 4f       	sbci	r23, 0xFF	; 255
    32d0:	8f 4f       	sbci	r24, 0xFF	; 255
    32d2:	9f 4f       	sbci	r25, 0xFF	; 255
    32d4:	08 95       	ret

000032d6 <__fp_split3>:
    32d6:	57 fd       	sbrc	r21, 7
    32d8:	90 58       	subi	r25, 0x80	; 128
    32da:	44 0f       	add	r20, r20
    32dc:	55 1f       	adc	r21, r21
    32de:	59 f0       	breq	.+22     	; 0x32f6 <__fp_splitA+0x10>
    32e0:	5f 3f       	cpi	r21, 0xFF	; 255
    32e2:	71 f0       	breq	.+28     	; 0x3300 <__fp_splitA+0x1a>
    32e4:	47 95       	ror	r20

000032e6 <__fp_splitA>:
    32e6:	88 0f       	add	r24, r24
    32e8:	97 fb       	bst	r25, 7
    32ea:	99 1f       	adc	r25, r25
    32ec:	61 f0       	breq	.+24     	; 0x3306 <__fp_splitA+0x20>
    32ee:	9f 3f       	cpi	r25, 0xFF	; 255
    32f0:	79 f0       	breq	.+30     	; 0x3310 <__fp_splitA+0x2a>
    32f2:	87 95       	ror	r24
    32f4:	08 95       	ret
    32f6:	12 16       	cp	r1, r18
    32f8:	13 06       	cpc	r1, r19
    32fa:	14 06       	cpc	r1, r20
    32fc:	55 1f       	adc	r21, r21
    32fe:	f2 cf       	rjmp	.-28     	; 0x32e4 <__fp_split3+0xe>
    3300:	46 95       	lsr	r20
    3302:	f1 df       	rcall	.-30     	; 0x32e6 <__fp_splitA>
    3304:	08 c0       	rjmp	.+16     	; 0x3316 <__fp_splitA+0x30>
    3306:	16 16       	cp	r1, r22
    3308:	17 06       	cpc	r1, r23
    330a:	18 06       	cpc	r1, r24
    330c:	99 1f       	adc	r25, r25
    330e:	f1 cf       	rjmp	.-30     	; 0x32f2 <__fp_splitA+0xc>
    3310:	86 95       	lsr	r24
    3312:	71 05       	cpc	r23, r1
    3314:	61 05       	cpc	r22, r1
    3316:	08 94       	sec
    3318:	08 95       	ret

0000331a <__fp_zero>:
    331a:	e8 94       	clt

0000331c <__fp_szero>:
    331c:	bb 27       	eor	r27, r27
    331e:	66 27       	eor	r22, r22
    3320:	77 27       	eor	r23, r23
    3322:	cb 01       	movw	r24, r22
    3324:	97 f9       	bld	r25, 7
    3326:	08 95       	ret

00003328 <__mulsf3>:
    3328:	0b d0       	rcall	.+22     	; 0x3340 <__mulsf3x>
    332a:	c4 cf       	rjmp	.-120    	; 0x32b4 <__fp_round>
    332c:	b5 df       	rcall	.-150    	; 0x3298 <__fp_pscA>
    332e:	28 f0       	brcs	.+10     	; 0x333a <__mulsf3+0x12>
    3330:	ba df       	rcall	.-140    	; 0x32a6 <__fp_pscB>
    3332:	18 f0       	brcs	.+6      	; 0x333a <__mulsf3+0x12>
    3334:	95 23       	and	r25, r21
    3336:	09 f0       	breq	.+2      	; 0x333a <__mulsf3+0x12>
    3338:	a6 cf       	rjmp	.-180    	; 0x3286 <__fp_inf>
    333a:	ab cf       	rjmp	.-170    	; 0x3292 <__fp_nan>
    333c:	11 24       	eor	r1, r1
    333e:	ee cf       	rjmp	.-36     	; 0x331c <__fp_szero>

00003340 <__mulsf3x>:
    3340:	ca df       	rcall	.-108    	; 0x32d6 <__fp_split3>
    3342:	a0 f3       	brcs	.-24     	; 0x332c <__mulsf3+0x4>

00003344 <__mulsf3_pse>:
    3344:	95 9f       	mul	r25, r21
    3346:	d1 f3       	breq	.-12     	; 0x333c <__mulsf3+0x14>
    3348:	95 0f       	add	r25, r21
    334a:	50 e0       	ldi	r21, 0x00	; 0
    334c:	55 1f       	adc	r21, r21
    334e:	62 9f       	mul	r22, r18
    3350:	f0 01       	movw	r30, r0
    3352:	72 9f       	mul	r23, r18
    3354:	bb 27       	eor	r27, r27
    3356:	f0 0d       	add	r31, r0
    3358:	b1 1d       	adc	r27, r1
    335a:	63 9f       	mul	r22, r19
    335c:	aa 27       	eor	r26, r26
    335e:	f0 0d       	add	r31, r0
    3360:	b1 1d       	adc	r27, r1
    3362:	aa 1f       	adc	r26, r26
    3364:	64 9f       	mul	r22, r20
    3366:	66 27       	eor	r22, r22
    3368:	b0 0d       	add	r27, r0
    336a:	a1 1d       	adc	r26, r1
    336c:	66 1f       	adc	r22, r22
    336e:	82 9f       	mul	r24, r18
    3370:	22 27       	eor	r18, r18
    3372:	b0 0d       	add	r27, r0
    3374:	a1 1d       	adc	r26, r1
    3376:	62 1f       	adc	r22, r18
    3378:	73 9f       	mul	r23, r19
    337a:	b0 0d       	add	r27, r0
    337c:	a1 1d       	adc	r26, r1
    337e:	62 1f       	adc	r22, r18
    3380:	83 9f       	mul	r24, r19
    3382:	a0 0d       	add	r26, r0
    3384:	61 1d       	adc	r22, r1
    3386:	22 1f       	adc	r18, r18
    3388:	74 9f       	mul	r23, r20
    338a:	33 27       	eor	r19, r19
    338c:	a0 0d       	add	r26, r0
    338e:	61 1d       	adc	r22, r1
    3390:	23 1f       	adc	r18, r19
    3392:	84 9f       	mul	r24, r20
    3394:	60 0d       	add	r22, r0
    3396:	21 1d       	adc	r18, r1
    3398:	82 2f       	mov	r24, r18
    339a:	76 2f       	mov	r23, r22
    339c:	6a 2f       	mov	r22, r26
    339e:	11 24       	eor	r1, r1
    33a0:	9f 57       	subi	r25, 0x7F	; 127
    33a2:	50 40       	sbci	r21, 0x00	; 0
    33a4:	8a f0       	brmi	.+34     	; 0x33c8 <__mulsf3_pse+0x84>
    33a6:	e1 f0       	breq	.+56     	; 0x33e0 <__mulsf3_pse+0x9c>
    33a8:	88 23       	and	r24, r24
    33aa:	4a f0       	brmi	.+18     	; 0x33be <__mulsf3_pse+0x7a>
    33ac:	ee 0f       	add	r30, r30
    33ae:	ff 1f       	adc	r31, r31
    33b0:	bb 1f       	adc	r27, r27
    33b2:	66 1f       	adc	r22, r22
    33b4:	77 1f       	adc	r23, r23
    33b6:	88 1f       	adc	r24, r24
    33b8:	91 50       	subi	r25, 0x01	; 1
    33ba:	50 40       	sbci	r21, 0x00	; 0
    33bc:	a9 f7       	brne	.-22     	; 0x33a8 <__mulsf3_pse+0x64>
    33be:	9e 3f       	cpi	r25, 0xFE	; 254
    33c0:	51 05       	cpc	r21, r1
    33c2:	70 f0       	brcs	.+28     	; 0x33e0 <__mulsf3_pse+0x9c>
    33c4:	60 cf       	rjmp	.-320    	; 0x3286 <__fp_inf>
    33c6:	aa cf       	rjmp	.-172    	; 0x331c <__fp_szero>
    33c8:	5f 3f       	cpi	r21, 0xFF	; 255
    33ca:	ec f3       	brlt	.-6      	; 0x33c6 <__mulsf3_pse+0x82>
    33cc:	98 3e       	cpi	r25, 0xE8	; 232
    33ce:	dc f3       	brlt	.-10     	; 0x33c6 <__mulsf3_pse+0x82>
    33d0:	86 95       	lsr	r24
    33d2:	77 95       	ror	r23
    33d4:	67 95       	ror	r22
    33d6:	b7 95       	ror	r27
    33d8:	f7 95       	ror	r31
    33da:	e7 95       	ror	r30
    33dc:	9f 5f       	subi	r25, 0xFF	; 255
    33de:	c1 f7       	brne	.-16     	; 0x33d0 <__mulsf3_pse+0x8c>
    33e0:	fe 2b       	or	r31, r30
    33e2:	88 0f       	add	r24, r24
    33e4:	91 1d       	adc	r25, r1
    33e6:	96 95       	lsr	r25
    33e8:	87 95       	ror	r24
    33ea:	97 f9       	bld	r25, 7
    33ec:	08 95       	ret

000033ee <pow>:
    33ee:	fa 01       	movw	r30, r20
    33f0:	ee 0f       	add	r30, r30
    33f2:	ff 1f       	adc	r31, r31
    33f4:	30 96       	adiw	r30, 0x00	; 0
    33f6:	21 05       	cpc	r18, r1
    33f8:	31 05       	cpc	r19, r1
    33fa:	99 f1       	breq	.+102    	; 0x3462 <pow+0x74>
    33fc:	61 15       	cp	r22, r1
    33fe:	71 05       	cpc	r23, r1
    3400:	61 f4       	brne	.+24     	; 0x341a <pow+0x2c>
    3402:	80 38       	cpi	r24, 0x80	; 128
    3404:	bf e3       	ldi	r27, 0x3F	; 63
    3406:	9b 07       	cpc	r25, r27
    3408:	49 f1       	breq	.+82     	; 0x345c <pow+0x6e>
    340a:	68 94       	set
    340c:	90 38       	cpi	r25, 0x80	; 128
    340e:	81 05       	cpc	r24, r1
    3410:	61 f0       	breq	.+24     	; 0x342a <pow+0x3c>
    3412:	80 38       	cpi	r24, 0x80	; 128
    3414:	bf ef       	ldi	r27, 0xFF	; 255
    3416:	9b 07       	cpc	r25, r27
    3418:	41 f0       	breq	.+16     	; 0x342a <pow+0x3c>
    341a:	99 23       	and	r25, r25
    341c:	42 f5       	brpl	.+80     	; 0x346e <pow+0x80>
    341e:	ff 3f       	cpi	r31, 0xFF	; 255
    3420:	e1 05       	cpc	r30, r1
    3422:	31 05       	cpc	r19, r1
    3424:	21 05       	cpc	r18, r1
    3426:	11 f1       	breq	.+68     	; 0x346c <pow+0x7e>
    3428:	e8 94       	clt
    342a:	08 94       	sec
    342c:	e7 95       	ror	r30
    342e:	d9 01       	movw	r26, r18
    3430:	aa 23       	and	r26, r26
    3432:	29 f4       	brne	.+10     	; 0x343e <pow+0x50>
    3434:	ab 2f       	mov	r26, r27
    3436:	be 2f       	mov	r27, r30
    3438:	f8 5f       	subi	r31, 0xF8	; 248
    343a:	d0 f3       	brcs	.-12     	; 0x3430 <pow+0x42>
    343c:	10 c0       	rjmp	.+32     	; 0x345e <pow+0x70>
    343e:	ff 5f       	subi	r31, 0xFF	; 255
    3440:	70 f4       	brcc	.+28     	; 0x345e <pow+0x70>
    3442:	a6 95       	lsr	r26
    3444:	e0 f7       	brcc	.-8      	; 0x343e <pow+0x50>
    3446:	f7 39       	cpi	r31, 0x97	; 151
    3448:	50 f0       	brcs	.+20     	; 0x345e <pow+0x70>
    344a:	19 f0       	breq	.+6      	; 0x3452 <pow+0x64>
    344c:	ff 3a       	cpi	r31, 0xAF	; 175
    344e:	38 f4       	brcc	.+14     	; 0x345e <pow+0x70>
    3450:	9f 77       	andi	r25, 0x7F	; 127
    3452:	9f 93       	push	r25
    3454:	0c d0       	rcall	.+24     	; 0x346e <pow+0x80>
    3456:	0f 90       	pop	r0
    3458:	07 fc       	sbrc	r0, 7
    345a:	90 58       	subi	r25, 0x80	; 128
    345c:	08 95       	ret
    345e:	3e f0       	brts	.+14     	; 0x346e <pow+0x80>
    3460:	18 cf       	rjmp	.-464    	; 0x3292 <__fp_nan>
    3462:	60 e0       	ldi	r22, 0x00	; 0
    3464:	70 e0       	ldi	r23, 0x00	; 0
    3466:	80 e8       	ldi	r24, 0x80	; 128
    3468:	9f e3       	ldi	r25, 0x3F	; 63
    346a:	08 95       	ret
    346c:	4f e7       	ldi	r20, 0x7F	; 127
    346e:	9f 77       	andi	r25, 0x7F	; 127
    3470:	5f 93       	push	r21
    3472:	4f 93       	push	r20
    3474:	3f 93       	push	r19
    3476:	2f 93       	push	r18
    3478:	9e d0       	rcall	.+316    	; 0x35b6 <log>
    347a:	2f 91       	pop	r18
    347c:	3f 91       	pop	r19
    347e:	4f 91       	pop	r20
    3480:	5f 91       	pop	r21
    3482:	52 df       	rcall	.-348    	; 0x3328 <__mulsf3>
    3484:	05 c0       	rjmp	.+10     	; 0x3490 <exp>
    3486:	19 f4       	brne	.+6      	; 0x348e <pow+0xa0>
    3488:	0e f0       	brts	.+2      	; 0x348c <pow+0x9e>
    348a:	fd ce       	rjmp	.-518    	; 0x3286 <__fp_inf>
    348c:	46 cf       	rjmp	.-372    	; 0x331a <__fp_zero>
    348e:	01 cf       	rjmp	.-510    	; 0x3292 <__fp_nan>

00003490 <exp>:
    3490:	2a df       	rcall	.-428    	; 0x32e6 <__fp_splitA>
    3492:	c8 f3       	brcs	.-14     	; 0x3486 <pow+0x98>
    3494:	96 38       	cpi	r25, 0x86	; 134
    3496:	c0 f7       	brcc	.-16     	; 0x3488 <pow+0x9a>
    3498:	07 f8       	bld	r0, 7
    349a:	0f 92       	push	r0
    349c:	e8 94       	clt
    349e:	2b e3       	ldi	r18, 0x3B	; 59
    34a0:	3a ea       	ldi	r19, 0xAA	; 170
    34a2:	48 eb       	ldi	r20, 0xB8	; 184
    34a4:	5f e7       	ldi	r21, 0x7F	; 127
    34a6:	4e df       	rcall	.-356    	; 0x3344 <__mulsf3_pse>
    34a8:	0f 92       	push	r0
    34aa:	0f 92       	push	r0
    34ac:	0f 92       	push	r0
    34ae:	4d b7       	in	r20, 0x3d	; 61
    34b0:	5e b7       	in	r21, 0x3e	; 62
    34b2:	0f 92       	push	r0
    34b4:	c0 d0       	rcall	.+384    	; 0x3636 <modf>
    34b6:	e4 ee       	ldi	r30, 0xE4	; 228
    34b8:	f0 e0       	ldi	r31, 0x00	; 0
    34ba:	16 d0       	rcall	.+44     	; 0x34e8 <__fp_powser>
    34bc:	4f 91       	pop	r20
    34be:	5f 91       	pop	r21
    34c0:	ef 91       	pop	r30
    34c2:	ff 91       	pop	r31
    34c4:	e5 95       	asr	r30
    34c6:	ee 1f       	adc	r30, r30
    34c8:	ff 1f       	adc	r31, r31
    34ca:	49 f0       	breq	.+18     	; 0x34de <exp+0x4e>
    34cc:	fe 57       	subi	r31, 0x7E	; 126
    34ce:	e0 68       	ori	r30, 0x80	; 128
    34d0:	44 27       	eor	r20, r20
    34d2:	ee 0f       	add	r30, r30
    34d4:	44 1f       	adc	r20, r20
    34d6:	fa 95       	dec	r31
    34d8:	e1 f7       	brne	.-8      	; 0x34d2 <exp+0x42>
    34da:	41 95       	neg	r20
    34dc:	55 0b       	sbc	r21, r21
    34de:	32 d0       	rcall	.+100    	; 0x3544 <ldexp>
    34e0:	0f 90       	pop	r0
    34e2:	07 fe       	sbrs	r0, 7
    34e4:	26 c0       	rjmp	.+76     	; 0x3532 <inverse>
    34e6:	08 95       	ret

000034e8 <__fp_powser>:
    34e8:	df 93       	push	r29
    34ea:	cf 93       	push	r28
    34ec:	1f 93       	push	r17
    34ee:	0f 93       	push	r16
    34f0:	ff 92       	push	r15
    34f2:	ef 92       	push	r14
    34f4:	df 92       	push	r13
    34f6:	7b 01       	movw	r14, r22
    34f8:	8c 01       	movw	r16, r24
    34fa:	68 94       	set
    34fc:	05 c0       	rjmp	.+10     	; 0x3508 <__fp_powser+0x20>
    34fe:	da 2e       	mov	r13, r26
    3500:	ef 01       	movw	r28, r30
    3502:	1e df       	rcall	.-452    	; 0x3340 <__mulsf3x>
    3504:	fe 01       	movw	r30, r28
    3506:	e8 94       	clt
    3508:	a5 91       	lpm	r26, Z+
    350a:	25 91       	lpm	r18, Z+
    350c:	35 91       	lpm	r19, Z+
    350e:	45 91       	lpm	r20, Z+
    3510:	55 91       	lpm	r21, Z+
    3512:	ae f3       	brts	.-22     	; 0x34fe <__fp_powser+0x16>
    3514:	ef 01       	movw	r28, r30
    3516:	8e dd       	rcall	.-1252   	; 0x3034 <__addsf3x>
    3518:	fe 01       	movw	r30, r28
    351a:	97 01       	movw	r18, r14
    351c:	a8 01       	movw	r20, r16
    351e:	da 94       	dec	r13
    3520:	79 f7       	brne	.-34     	; 0x3500 <__fp_powser+0x18>
    3522:	df 90       	pop	r13
    3524:	ef 90       	pop	r14
    3526:	ff 90       	pop	r15
    3528:	0f 91       	pop	r16
    352a:	1f 91       	pop	r17
    352c:	cf 91       	pop	r28
    352e:	df 91       	pop	r29
    3530:	08 95       	ret

00003532 <inverse>:
    3532:	9b 01       	movw	r18, r22
    3534:	ac 01       	movw	r20, r24
    3536:	60 e0       	ldi	r22, 0x00	; 0
    3538:	70 e0       	ldi	r23, 0x00	; 0
    353a:	80 e8       	ldi	r24, 0x80	; 128
    353c:	9f e3       	ldi	r25, 0x3F	; 63
    353e:	cd cd       	rjmp	.-1126   	; 0x30da <__divsf3>
    3540:	a2 ce       	rjmp	.-700    	; 0x3286 <__fp_inf>
    3542:	ac c0       	rjmp	.+344    	; 0x369c <__fp_mpack>

00003544 <ldexp>:
    3544:	d0 de       	rcall	.-608    	; 0x32e6 <__fp_splitA>
    3546:	e8 f3       	brcs	.-6      	; 0x3542 <inverse+0x10>
    3548:	99 23       	and	r25, r25
    354a:	d9 f3       	breq	.-10     	; 0x3542 <inverse+0x10>
    354c:	94 0f       	add	r25, r20
    354e:	51 1d       	adc	r21, r1
    3550:	bb f3       	brvs	.-18     	; 0x3540 <inverse+0xe>
    3552:	91 50       	subi	r25, 0x01	; 1
    3554:	50 40       	sbci	r21, 0x00	; 0
    3556:	94 f0       	brlt	.+36     	; 0x357c <ldexp+0x38>
    3558:	59 f0       	breq	.+22     	; 0x3570 <ldexp+0x2c>
    355a:	88 23       	and	r24, r24
    355c:	32 f0       	brmi	.+12     	; 0x356a <ldexp+0x26>
    355e:	66 0f       	add	r22, r22
    3560:	77 1f       	adc	r23, r23
    3562:	88 1f       	adc	r24, r24
    3564:	91 50       	subi	r25, 0x01	; 1
    3566:	50 40       	sbci	r21, 0x00	; 0
    3568:	c1 f7       	brne	.-16     	; 0x355a <ldexp+0x16>
    356a:	9e 3f       	cpi	r25, 0xFE	; 254
    356c:	51 05       	cpc	r21, r1
    356e:	44 f7       	brge	.-48     	; 0x3540 <inverse+0xe>
    3570:	88 0f       	add	r24, r24
    3572:	91 1d       	adc	r25, r1
    3574:	96 95       	lsr	r25
    3576:	87 95       	ror	r24
    3578:	97 f9       	bld	r25, 7
    357a:	08 95       	ret
    357c:	5f 3f       	cpi	r21, 0xFF	; 255
    357e:	ac f0       	brlt	.+42     	; 0x35aa <ldexp+0x66>
    3580:	98 3e       	cpi	r25, 0xE8	; 232
    3582:	9c f0       	brlt	.+38     	; 0x35aa <ldexp+0x66>
    3584:	bb 27       	eor	r27, r27
    3586:	86 95       	lsr	r24
    3588:	77 95       	ror	r23
    358a:	67 95       	ror	r22
    358c:	b7 95       	ror	r27
    358e:	08 f4       	brcc	.+2      	; 0x3592 <ldexp+0x4e>
    3590:	b1 60       	ori	r27, 0x01	; 1
    3592:	93 95       	inc	r25
    3594:	c1 f7       	brne	.-16     	; 0x3586 <ldexp+0x42>
    3596:	bb 0f       	add	r27, r27
    3598:	58 f7       	brcc	.-42     	; 0x3570 <ldexp+0x2c>
    359a:	11 f4       	brne	.+4      	; 0x35a0 <ldexp+0x5c>
    359c:	60 ff       	sbrs	r22, 0
    359e:	e8 cf       	rjmp	.-48     	; 0x3570 <ldexp+0x2c>
    35a0:	6f 5f       	subi	r22, 0xFF	; 255
    35a2:	7f 4f       	sbci	r23, 0xFF	; 255
    35a4:	8f 4f       	sbci	r24, 0xFF	; 255
    35a6:	9f 4f       	sbci	r25, 0xFF	; 255
    35a8:	e3 cf       	rjmp	.-58     	; 0x3570 <ldexp+0x2c>
    35aa:	b8 ce       	rjmp	.-656    	; 0x331c <__fp_szero>
    35ac:	0e f0       	brts	.+2      	; 0x35b0 <ldexp+0x6c>
    35ae:	76 c0       	rjmp	.+236    	; 0x369c <__fp_mpack>
    35b0:	70 ce       	rjmp	.-800    	; 0x3292 <__fp_nan>
    35b2:	68 94       	set
    35b4:	68 ce       	rjmp	.-816    	; 0x3286 <__fp_inf>

000035b6 <log>:
    35b6:	97 de       	rcall	.-722    	; 0x32e6 <__fp_splitA>
    35b8:	c8 f3       	brcs	.-14     	; 0x35ac <ldexp+0x68>
    35ba:	99 23       	and	r25, r25
    35bc:	d1 f3       	breq	.-12     	; 0x35b2 <ldexp+0x6e>
    35be:	c6 f3       	brts	.-16     	; 0x35b0 <ldexp+0x6c>
    35c0:	df 93       	push	r29
    35c2:	cf 93       	push	r28
    35c4:	1f 93       	push	r17
    35c6:	0f 93       	push	r16
    35c8:	ff 92       	push	r15
    35ca:	c9 2f       	mov	r28, r25
    35cc:	dd 27       	eor	r29, r29
    35ce:	88 23       	and	r24, r24
    35d0:	2a f0       	brmi	.+10     	; 0x35dc <log+0x26>
    35d2:	21 97       	sbiw	r28, 0x01	; 1
    35d4:	66 0f       	add	r22, r22
    35d6:	77 1f       	adc	r23, r23
    35d8:	88 1f       	adc	r24, r24
    35da:	da f7       	brpl	.-10     	; 0x35d2 <log+0x1c>
    35dc:	20 e0       	ldi	r18, 0x00	; 0
    35de:	30 e0       	ldi	r19, 0x00	; 0
    35e0:	40 e8       	ldi	r20, 0x80	; 128
    35e2:	5f eb       	ldi	r21, 0xBF	; 191
    35e4:	9f e3       	ldi	r25, 0x3F	; 63
    35e6:	88 39       	cpi	r24, 0x98	; 152
    35e8:	20 f0       	brcs	.+8      	; 0x35f2 <log+0x3c>
    35ea:	80 3e       	cpi	r24, 0xE0	; 224
    35ec:	30 f0       	brcs	.+12     	; 0x35fa <log+0x44>
    35ee:	21 96       	adiw	r28, 0x01	; 1
    35f0:	8f 77       	andi	r24, 0x7F	; 127
    35f2:	0f dd       	rcall	.-1506   	; 0x3012 <__addsf3>
    35f4:	ec e0       	ldi	r30, 0x0C	; 12
    35f6:	f1 e0       	ldi	r31, 0x01	; 1
    35f8:	03 c0       	rjmp	.+6      	; 0x3600 <log+0x4a>
    35fa:	0b dd       	rcall	.-1514   	; 0x3012 <__addsf3>
    35fc:	e9 e3       	ldi	r30, 0x39	; 57
    35fe:	f1 e0       	ldi	r31, 0x01	; 1
    3600:	73 df       	rcall	.-282    	; 0x34e8 <__fp_powser>
    3602:	8b 01       	movw	r16, r22
    3604:	be 01       	movw	r22, r28
    3606:	ec 01       	movw	r28, r24
    3608:	fb 2e       	mov	r15, r27
    360a:	6f 57       	subi	r22, 0x7F	; 127
    360c:	71 09       	sbc	r23, r1
    360e:	75 95       	asr	r23
    3610:	77 1f       	adc	r23, r23
    3612:	88 0b       	sbc	r24, r24
    3614:	99 0b       	sbc	r25, r25
    3616:	fc dd       	rcall	.-1032   	; 0x3210 <__floatsisf>
    3618:	28 e1       	ldi	r18, 0x18	; 24
    361a:	32 e7       	ldi	r19, 0x72	; 114
    361c:	41 e3       	ldi	r20, 0x31	; 49
    361e:	5f e3       	ldi	r21, 0x3F	; 63
    3620:	8f de       	rcall	.-738    	; 0x3340 <__mulsf3x>
    3622:	af 2d       	mov	r26, r15
    3624:	98 01       	movw	r18, r16
    3626:	ae 01       	movw	r20, r28
    3628:	ff 90       	pop	r15
    362a:	0f 91       	pop	r16
    362c:	1f 91       	pop	r17
    362e:	cf 91       	pop	r28
    3630:	df 91       	pop	r29
    3632:	00 dd       	rcall	.-1536   	; 0x3034 <__addsf3x>
    3634:	3f ce       	rjmp	.-898    	; 0x32b4 <__fp_round>

00003636 <modf>:
    3636:	fa 01       	movw	r30, r20
    3638:	dc 01       	movw	r26, r24
    363a:	aa 0f       	add	r26, r26
    363c:	bb 1f       	adc	r27, r27
    363e:	9b 01       	movw	r18, r22
    3640:	ac 01       	movw	r20, r24
    3642:	bf 57       	subi	r27, 0x7F	; 127
    3644:	28 f4       	brcc	.+10     	; 0x3650 <modf+0x1a>
    3646:	22 27       	eor	r18, r18
    3648:	33 27       	eor	r19, r19
    364a:	44 27       	eor	r20, r20
    364c:	50 78       	andi	r21, 0x80	; 128
    364e:	1f c0       	rjmp	.+62     	; 0x368e <modf+0x58>
    3650:	b7 51       	subi	r27, 0x17	; 23
    3652:	88 f4       	brcc	.+34     	; 0x3676 <modf+0x40>
    3654:	ab 2f       	mov	r26, r27
    3656:	00 24       	eor	r0, r0
    3658:	46 95       	lsr	r20
    365a:	37 95       	ror	r19
    365c:	27 95       	ror	r18
    365e:	01 1c       	adc	r0, r1
    3660:	a3 95       	inc	r26
    3662:	d2 f3       	brmi	.-12     	; 0x3658 <modf+0x22>
    3664:	00 20       	and	r0, r0
    3666:	69 f0       	breq	.+26     	; 0x3682 <modf+0x4c>
    3668:	22 0f       	add	r18, r18
    366a:	33 1f       	adc	r19, r19
    366c:	44 1f       	adc	r20, r20
    366e:	b3 95       	inc	r27
    3670:	da f3       	brmi	.-10     	; 0x3668 <modf+0x32>
    3672:	0d d0       	rcall	.+26     	; 0x368e <modf+0x58>
    3674:	cd cc       	rjmp	.-1638   	; 0x3010 <__subsf3>
    3676:	61 30       	cpi	r22, 0x01	; 1
    3678:	71 05       	cpc	r23, r1
    367a:	a0 e8       	ldi	r26, 0x80	; 128
    367c:	8a 07       	cpc	r24, r26
    367e:	b9 46       	sbci	r27, 0x69	; 105
    3680:	30 f4       	brcc	.+12     	; 0x368e <modf+0x58>
    3682:	9b 01       	movw	r18, r22
    3684:	ac 01       	movw	r20, r24
    3686:	66 27       	eor	r22, r22
    3688:	77 27       	eor	r23, r23
    368a:	88 27       	eor	r24, r24
    368c:	90 78       	andi	r25, 0x80	; 128
    368e:	30 96       	adiw	r30, 0x00	; 0
    3690:	21 f0       	breq	.+8      	; 0x369a <modf+0x64>
    3692:	20 83       	st	Z, r18
    3694:	31 83       	std	Z+1, r19	; 0x01
    3696:	42 83       	std	Z+2, r20	; 0x02
    3698:	53 83       	std	Z+3, r21	; 0x03
    369a:	08 95       	ret

0000369c <__fp_mpack>:
    369c:	9f 3f       	cpi	r25, 0xFF	; 255
    369e:	31 f0       	breq	.+12     	; 0x36ac <__fp_mpack_finite+0xc>

000036a0 <__fp_mpack_finite>:
    36a0:	91 50       	subi	r25, 0x01	; 1
    36a2:	20 f4       	brcc	.+8      	; 0x36ac <__fp_mpack_finite+0xc>
    36a4:	87 95       	ror	r24
    36a6:	77 95       	ror	r23
    36a8:	67 95       	ror	r22
    36aa:	b7 95       	ror	r27
    36ac:	88 0f       	add	r24, r24
    36ae:	91 1d       	adc	r25, r1
    36b0:	96 95       	lsr	r25
    36b2:	87 95       	ror	r24
    36b4:	97 f9       	bld	r25, 7
    36b6:	08 95       	ret

000036b8 <__udivmodhi4>:
    36b8:	aa 1b       	sub	r26, r26
    36ba:	bb 1b       	sub	r27, r27
    36bc:	51 e1       	ldi	r21, 0x11	; 17
    36be:	07 c0       	rjmp	.+14     	; 0x36ce <__udivmodhi4_ep>

000036c0 <__udivmodhi4_loop>:
    36c0:	aa 1f       	adc	r26, r26
    36c2:	bb 1f       	adc	r27, r27
    36c4:	a6 17       	cp	r26, r22
    36c6:	b7 07       	cpc	r27, r23
    36c8:	10 f0       	brcs	.+4      	; 0x36ce <__udivmodhi4_ep>
    36ca:	a6 1b       	sub	r26, r22
    36cc:	b7 0b       	sbc	r27, r23

000036ce <__udivmodhi4_ep>:
    36ce:	88 1f       	adc	r24, r24
    36d0:	99 1f       	adc	r25, r25
    36d2:	5a 95       	dec	r21
    36d4:	a9 f7       	brne	.-22     	; 0x36c0 <__udivmodhi4_loop>
    36d6:	80 95       	com	r24
    36d8:	90 95       	com	r25
    36da:	bc 01       	movw	r22, r24
    36dc:	cd 01       	movw	r24, r26
    36de:	08 95       	ret

000036e0 <__divmodhi4>:
    36e0:	97 fb       	bst	r25, 7
    36e2:	09 2e       	mov	r0, r25
    36e4:	07 26       	eor	r0, r23
    36e6:	0a d0       	rcall	.+20     	; 0x36fc <__divmodhi4_neg1>
    36e8:	77 fd       	sbrc	r23, 7
    36ea:	04 d0       	rcall	.+8      	; 0x36f4 <__divmodhi4_neg2>
    36ec:	e5 df       	rcall	.-54     	; 0x36b8 <__udivmodhi4>
    36ee:	06 d0       	rcall	.+12     	; 0x36fc <__divmodhi4_neg1>
    36f0:	00 20       	and	r0, r0
    36f2:	1a f4       	brpl	.+6      	; 0x36fa <__divmodhi4_exit>

000036f4 <__divmodhi4_neg2>:
    36f4:	70 95       	com	r23
    36f6:	61 95       	neg	r22
    36f8:	7f 4f       	sbci	r23, 0xFF	; 255

000036fa <__divmodhi4_exit>:
    36fa:	08 95       	ret

000036fc <__divmodhi4_neg1>:
    36fc:	f6 f7       	brtc	.-4      	; 0x36fa <__divmodhi4_exit>
    36fe:	90 95       	com	r25
    3700:	81 95       	neg	r24
    3702:	9f 4f       	sbci	r25, 0xFF	; 255
    3704:	08 95       	ret

00003706 <_exit>:
    3706:	f8 94       	cli

00003708 <__stop_program>:
    3708:	ff cf       	rjmp	.-2      	; 0x3708 <__stop_program>
