

/*
 *
 * Team Id: eYRC-#1874
 * Author List: Manish Yadav, Ganesh Iyer, Balchandra Naik, Vedant Khandelwal 
 * Filename: <Filename>
 * Theme: Warehouse management
 * Functions: color_sense(), follow(), north(), south(), east(), west(), order_picking(int co_ordinate), zone_availability(int color, int border),
 * travel(int from, int to), path_planning(int current_position), order_picking(int co_ordinate), zone_scan(), change_orientation(), sort_leftover(),
 * place_package(), pick(), drop().
 * Global Variables: count_red_zone,count_green_zone,count_blue_zone,center_sensor,left_sensor,right_sensor,pointingnorth,pointingsouth,
 * pointingeast,pointingwest,orie,total_boxes,white_color,red_color_green_color,blue_color,black_color,deposition_table[3][4],info_table[12][3]
 * blocks_in[6],flag,current_position,next_position,value.
 *
 */


#define F_CPU 14745600
#include <avr/io.h> 
#include <avr/interrupt.h> 
#include <util/delay.h> 
#include <math.h> 
#include "lcd.h"

volatile unsigned long int ShaftCountLeft = 0;	//to keep track of left position encoder
volatile unsigned long int ShaftCountRight = 0;	//to keep track of right position encoder
volatile unsigned int Degrees; //to accept angle in degrees for turning
volatile unsigned long int pulse = 0; //to keep the track of the number of pulses generated by the color sensor
volatile unsigned long int red;	//to store the pulse count when read_red function is called
volatile unsigned long int blue; //to store the pulse count when read_blue function is called
volatile unsigned long int green; //to store the pulse count when read_green function is called
volatile unsigned long int black; //to store the pulse count when color_sense function is called
int count_red_zone = 0;	//stores number of valid deposition zone available for red packages
int count_green_zone = 0; //stores number of valid deposition zone available for red packages
int count_blue_zone = 0; //stores number of valid deposition zone available for red packages
unsigned char center_sensor = 0; //stores count from center white line sensor
unsigned char left_sensor = 0; //stores count from center white line sensor
unsigned char right_sensor = 0; //stores count from center white line sensor
int has_turned = 0;
int last_turned = 0;
int pointingnorth = 1; // variable to check if the robot is pointing in the north direction
int pointingeast = 2; // variable to check if the robot is pointing in the east direction
int pointingsouth = 3; // variable to check if the robot is pointing in the south direction
int pointingwest = 4; // variable to check if the robot is pointing in the west direction
int orie; // to keep track of the robot's current orientation
int total_boxes; //stores total number of valid packages
int white_color = 5, black_color = 1, red_color = 2, green_color = 3, blue_color = 4; // variables used as macros
int leftover_blocks[2][7] = {	// stores packages that are left in the lower/upper side of the arena
    0
};
int leftover_counter = 0;	//counter used for the above array
int deposition_table[3][4] = {
    {
        3, 2, -1, -1,		//data for red blocks. 0--> Number of valid boxes, 1--> Deposition zone 1, 2--> Deposition zone 2, 3--> Deposition zone 3
    },
    {
        1, 1, 5, -1,		//data for green blocks.  0--> Number of valid boxes, 1--> Deposition zone 1, 2--> Deposition zone 2, 3--> Deposition zone 3
    }, 
    {
        1, 3, 4, -1			//data for blue blocks.  0--> Number of valid boxes, 1--> Deposition zone 1, 2--> Deposition zone 2, 3--> Deposition zone 3
    }
}; 
int info_table[12][3] = {	//stores information about each and every block i.e [0]-->co-ordinates, [1]-->color of the box at that co-ordinate, 
    0						//[2]--> zone at which block is to be deposited
};
int blocks_in[6] = {		// stores the number of blocks stored in each deposition zone.
    0
};
int flag = 1;
int current_position, next_position; // variables used to store current and next co-ordinate value respectively
unsigned char ADC_Conversion(unsigned char);
unsigned char ADC_Value;
unsigned char sharp, distance, adc_reading;
unsigned int value;	//stores sharp sensor values in mm.

void buzzer_pin_config(void) {
    DDRC = DDRC | 0x08; //Setting PORTC 3 as output
    PORTC = PORTC & 0xF7; //Setting PORTC 3 logic low to turnoff buzzer
}

void color_sensor_pin_config(void) {
    DDRD = DDRD | 0xFE; //set PD0 as input for color sensor output
    PORTD = PORTD | 0x01; //Enable internal pull-up for PORTD 0 pin
}

void color_sensor_pin_interrupt_init(void) //Interrupt 0 enable
    {
        cli(); //Clears the global interrupt
        EICRA = EICRA | 0x02; // INT0 is set to trigger with falling edge
        EIMSK = EIMSK | 0x01; // Enable Interrupt INT0 for color sensor
        sei(); // Enables the global interrupt
    }


ISR(INT0_vect) {
    pulse++; //increment on receiving pulse from the color sensor
}

void left_encoder_pin_config(void) {
    DDRE = DDRE & 0xEF; //Set the direction of the PORTE 4 pin as input
    PORTE = PORTE | 0x10; //Enable internal pull-up for PORTE 4 pin
}

void right_encoder_pin_config(void) {
    DDRE = DDRE & 0xDF; //Set the direction of the PORTE 4 pin as input
    PORTE = PORTE | 0x20; //Enable internal pull-up for PORTE 4 pin
}

void servo1_pin_config(void) {
    DDRB = DDRB | 0x20; //making PORTB 5 pin output
    PORTB = PORTB | 0x20; //setting PORTB 5 pin to logic 1
}

void servo2_pin_config(void) {
    DDRB = DDRB | 0x40; //making PORTB 6 pin output
    PORTB = PORTB | 0x40; //setting PORTB 6 pin to logic 1
}

void servo3_pin_config(void) {
    DDRB = DDRB | 0x80; //making PORTB 7 pin output
    PORTB = PORTB | 0x80; //setting PORTB 7 pin to logic 1
}

void lcd_port_config(void) {
    DDRC = DDRC | 0xF7; //all the LCD pin's direction set as output
    PORTC = PORTC & 0x80; // all the LCD pins are set to logic 0 except PORTC 7
}

void adc_pin_config(void) {
    DDRF = 0x00; //set PORTF direction as input
    PORTF = 0x00; //set PORTF pins floating
    DDRK = 0x00; //set PORTK direction as input
    PORTK = 0x00; //set PORTK pins floating
}

void motion_pin_config(void) {
    DDRA = DDRA | 0x0F; //set direction of the PORTA 3 to PORTA 0 pins as output
    PORTA = PORTA & 0xF0; // set initial value of the PORTA 3 to PORTA 0 pins to logic 0
    DDRL = DDRL | 0x18; //Setting PL3 and PL4 pins as output for PWM generation
    PORTL = PORTL | 0x18; //PL3 and PL4 pins are for velocity control using PWM
}

void LED_bargraph_config(void) {
    DDRJ = 0xFF; //PORT J is configured as output
    PORTJ = 0x00; //Output is set to 0
}

void port_init(void) {
    buzzer_pin_config();
    lcd_port_config();
    LED_bargraph_config();
    left_encoder_pin_config();
    right_encoder_pin_config();
    servo1_pin_config();
    servo2_pin_config();
    servo3_pin_config();
    adc_pin_config();
    motion_pin_config();
    color_sensor_pin_config();
}

unsigned int Sharp_GP2D12_estimation(unsigned char adc_reading) {
    float distance;
    unsigned int distanceInt;
    distance = (int)(10.00 * (2799.6 * (1.00 / (pow(adc_reading, 1.1546)))));
    distanceInt = (int) distance;
    if (distanceInt > 800) {
        distanceInt = 800;
    }
    return distanceInt;
}

void timer1_init(void) {
    TCCR1B = 0x00; //stop
    TCNT1H = 0xFC; //Counter high value to which OCR1xH value is to be compared with
    TCNT1L = 0x01; //Counter low value to which OCR1xH value is to be compared with
    OCR1AH = 0x03; //Output compare Register high value for servo 1
    OCR1AL = 0xFF; //Output Compare Register low Value For servo 1
    OCR1BH = 0x03; //Output compare Register high value for servo 2
    OCR1BL = 0xFF; //Output Compare Register low Value For servo 2
    OCR1CH = 0x03; //Output compare Register high value for servo 3
    OCR1CL = 0xFF; //Output Compare Register low Value For servo 3
    ICR1H = 0x03;
    ICR1L = 0xFF;
    TCCR1A = 0xAB;
    /*{COM1A1=1, COM1A0=0; COM1B1=1, COM1B0=0; COM1C1=1 COM1C0=0}
     					For Overriding normal port functionality to OCRnA outputs.
    				  {WGM11=1, WGM10=1} Along With WGM12 in TCCR1B for Selecting FAST PWM Mode*/
    TCCR1C = 0x00;
    TCCR1B = 0x0C; //WGM12=1; CS12=1, CS11=0, CS10=0 (Prescaler=256)
}

void timer5_init() {
    TCCR5B = 0x00; //Stop
    TCNT5H = 0xFF; //Counter higher 8-bit value to which OCR5xH value is compared with
    TCNT5L = 0x01; //Counter lower 8-bit value to which OCR5xH value is compared with
    OCR5AH = 0x00; //Output compare register high value for Left Motor
    OCR5AL = 0xFF; //Output compare register low value for Left Motor
    OCR5BH = 0x00; //Output compare register high value for Right Motor
    OCR5BL = 0xFF; //Output compare register low value for Right Motor
    OCR5CH = 0x00; //Output compare register high value for Motor C1
    OCR5CL = 0xFF; //Output compare register low value for Motor C1
    TCCR5A = 0xA9; //COM5A1=1, COM5A0=0; COM5B1=1, COM5B0=0; COM5C1=1
    // COM5C0=0
    //For Overriding normal port functionality to OCRnA outputs. WGM51=0, WGM50=1 Along With GM52 //in TCCR5B for Selecting FAST PWM 8-bit Mode
    TCCR5B = 0x0B; //WGM12=1; CS12=0, CS11=1, CS10=1 (Prescaler=64)
}

void buzzer_on(void) {
    unsigned char port_restore = 0;
    port_restore = PINC;
    port_restore = port_restore | 0x08;
    PORTC = port_restore;
}

void buzzer_off(void) {
    unsigned char port_restore = 0;
    port_restore = PINC;
    port_restore = port_restore & 0xF7;
    PORTC = port_restore;
}

void velocity(unsigned char left_motor, unsigned char right_motor) {
    OCR5AL = (unsigned char) left_motor;
    OCR5BL = (unsigned char) right_motor;
}

void motion_set(unsigned char Direction) {
    unsigned char PortARestore = 0;
    Direction &= 0x0F; // removing upper nibble as it is not needed
    PortARestore = PORTA; // reading the PORTA's original status
    PortARestore &= 0xF0; // setting lower direction nibble to 0
    PortARestore |= Direction; // adding lower nibble for direction command and
    // restoring the PORTA status
    PORTA = PortARestore; // setting the command to the port
}

void forward(void) //both wheels forward
    {
        motion_set(0x06);
    }

void reverse(void) //both wheels backward
    {
        motion_set(0x09);
    }

void left(void) //Left wheel backward, Right wheel forward
    {
        motion_set(0x05);
    }

void right(void) //Left wheel forward, Right wheel backward
    {
        motion_set(0x0A);
    }

void stop(void) //hard stop if PORTL 3 and PORTL 4 pins are at logic 1
    {
        motion_set(0x00);
    }

ISR(INT5_vect) {
    ShaftCountRight++; //increment right shaft position count
}

ISR(INT4_vect) {
    ShaftCountLeft++; //increment left shaft position count
}

void angle_rotate(unsigned int Degrees) {
    float ReqdShaftCount = 0;
    unsigned long int ReqdShaftCountInt = 0;
    ReqdShaftCount = (float) Degrees / 4.090; // division by resolution to get shaft count
    ReqdShaftCountInt = (unsigned int) ReqdShaftCount;
    ShaftCountRight = 0;
    ShaftCountLeft = 0;
    while (1) {
        if ((ShaftCountRight >= ReqdShaftCountInt) | (ShaftCountLeft >= ReqdShaftCountInt))
            break;
    }
    stop(); //Stop robot
}

void linear_distance_mm(unsigned int DistanceInMM) {
    float ReqdShaftCount = 0;
    unsigned long int ReqdShaftCountInt = 0;
    ReqdShaftCount = DistanceInMM / 5.338; // division by resolution to get shaft count
    ReqdShaftCountInt = (unsigned long int) ReqdShaftCount;
    ShaftCountRight = 0;
    while (1) {
        if (ShaftCountRight > ReqdShaftCountInt) {
            break;
        }
    }
    stop(); //Stop robot
}

void forward_mm(unsigned int DistanceInMM) {
    forward();
    linear_distance_mm(DistanceInMM);
}

void back_mm(unsigned int DistanceInMM) {
    reverse();
    linear_distance_mm(DistanceInMM);
}

void left_degrees(unsigned int Degrees) {
    // 88 pulses for 360 degrees rotation 4.090 degrees per count
    left(); //Turn left
    angle_rotate(Degrees);
}

void right_degrees(unsigned int Degrees) {
    // 88 pulses for 360 degrees rotation 4.090 degrees per count
    right(); //Turn right
    angle_rotate(Degrees);
}

unsigned char ADC_Conversion(unsigned char Ch) {
    unsigned char a;
    if (Ch > 7) {
        ADCSRB = 0x08;
    }
    Ch = Ch & 0x07;
    ADMUX = 0x20 | Ch;
    ADCSRA = ADCSRA | 0x40; //Set start conversion bit
    while ((ADCSRA & 0x10) == 0); //Wait for ADC conversion to complete
    a = ADCH;
    ADCSRA = ADCSRA | 0x10; //clear ADIF (ADC Interrupt Flag) by writing 1 to it
    ADCSRB = 0x00;
    return a;
}

void turn_on_ir_proxi_sensors(void) //turn on IR Proximity sensors
    {
        PORTH = PORTH & 0xF7;
    }

void turn_off_ir_proxi_sensors(void) //turn off IR Proximity sensors
    {
        PORTH = PORTH | 0x08;
    }

void adc_init() {
    ADCSRA = 0x00;
    ADCSRB = 0x00; //MUX5 = 0
    ADMUX = 0x20; //Vref=5V external --- ADLAR=1 --- MUX4:0 = 0000
    ACSR = 0x80;
    ADCSRA = 0x86; //ADEN=1 --- ADIE=1 --- ADPS2:0 = 1 1 0
}

void lcd_init() {
    _delay_ms(1);
    lcd_wr_command(0x28); //4-bit mode and 5x8 dot character font
    lcd_wr_command(0x01); //Clear LCD display
    lcd_wr_command(0x06); //Auto increment cursor position
    lcd_wr_command(0x0E); //Turn on LCD and cursor
    lcd_wr_command(0x80); //Set cursor position
}

void left_position_encoder_interrupt_init(void) //Interrupt 4 enable
    {
        cli(); //Clears the global interrupt
        EICRB = EICRB | 0x02; // INT4 is set to trigger with falling edge
        EIMSK = EIMSK | 0x10; // Enable Interrupt INT4 for left position encoder
        sei(); // Enables the global interrupt
    }

void right_position_encoder_interrupt_init(void) //Interrupt 5 enable
    {
        cli(); //Clears the global interrupt
        EICRB = EICRB | 0x08; // INT5 is set to trigger with falling edge
        EIMSK = EIMSK | 0x20; // Enable Interrupt INT5 for right position encoder
        sei(); // Enables the global interrupt
    }

void init_devices(void) {
    cli(); //Clears the global interrupts
    port_init();
    adc_init();
    timer1_init();
    timer5_init();
    left_position_encoder_interrupt_init();
    right_position_encoder_interrupt_init();
    color_sensor_pin_interrupt_init();
    sei(); //Enables the global interrupts
}

void servo_1(unsigned char degrees) {
    float PositionPanServo = 0;
    PositionPanServo = ((float) degrees / 1.86) + 35.0;
    OCR1AH = 0x00;
    OCR1AL = (unsigned char) PositionPanServo;
}


//Function to rotate Servo 2 by a specified angle in the multiples of 1.86 degrees
void servo_2(unsigned char degrees) {
    float PositionTiltServo = 0;
    PositionTiltServo = ((float) degrees / 1.86) + 35.0;
    OCR1BH = 0x00;
    OCR1BL = (unsigned char) PositionTiltServo;
}

//Function to rotate Servo 3 by a specified angle in the multiples of 1.86 degrees
void servo_3(unsigned char degrees) {
    float PositionServo = 0;
    PositionServo = ((float) degrees / 1.86) + 35.0;
    OCR1CH = 0x00;
    OCR1CL = (unsigned char) PositionServo;
}

//servo_free functions unlocks the servo motors from the any angle
//and make them free by giving 100% duty cycle at the PWM. This function can be used to
//reduce the power consumption of the motor if it is holding load against the gravity.

void servo_1_free(void) //makes servo 1 free rotating
    {
        OCR1AH = 0x03;
        OCR1AL = 0xFF; //Servo 1 off
    }

void servo_2_free(void) //makes servo 2 free rotating
    {
        OCR1BH = 0x03;
        OCR1BL = 0xFF; //Servo 2 off
    }

void servo_3_free(void) //makes servo 3 free rotating
    {
        OCR1CH = 0x03;
        OCR1CL = 0xFF; //Servo 3 off
    }
void filter_red(void) //Used to select red filter
    {
        //Filter Select - red filter
        PORTD = PORTD & 0xBF; //set S2 low
        PORTD = PORTD & 0x7F; //set S3 low
    }

void filter_green(void) //Used to select green filter
    {
        //Filter Select - green filter
        PORTD = PORTD | 0x40; //set S2 High
        PORTD = PORTD | 0x80; //set S3 High
    }

void filter_blue(void) //Used to select blue filter
    {
        //Filter Select - blue filter
        PORTD = PORTD & 0xBF; //set S2 low
        PORTD = PORTD | 0x80; //set S3 High
    }

void filter_clear(void) //select no filter
    {
        //Filter Select - no filter
        PORTD = PORTD | 0x40; //set S2 High
        PORTD = PORTD & 0x7F; //set S3 Low
    }

//Color Sensing Scaling
void color_sensor_scaling() //This function is used to select the scaled down version of the original frequency of the output generated by the color sensor, generally 20% scaling is preferable, though you can change the values as per your application by referring datasheet
    {
        //Output Scaling 20% from datasheet
        //PORTD = PORTD & 0xEF;
        PORTD = PORTD | 0x10; //set S0 high
        //PORTD = PORTD & 0xDF; //set S1 low
        PORTD = PORTD | 0x20; //set S1 high
    }

void red_read(void) // function to select red filter and display the count generated by the sensor on LCD. The count will be more if the color is red. The count will be very less if its blue or green.
    {
        //Red
        filter_red(); //select red filter
        pulse = 0; //reset the count to 0
        _delay_ms(100); //capture the pulses for 100 ms or 0.1 second
        red = pulse; //store the count in variable called red
    }

void green_read(void) // function to select green filter and display the count generated by the sensor on LCD. The count will be more if the color is green. The count will be very less if its blue or red.
    {
        //Green
        filter_green(); //select green filter
        pulse = 0; //reset the count to 0
        _delay_ms(100); //capture the pulses for 100 ms or 0.1 second
        green = pulse; //store the count in variable called green
    }

void blue_read(void) // function to select blue filter and display the count generated by the sensor on LCD. The count will be more if the color is blue. The count will be very less if its red or green.
    {
        //Blue
        filter_blue(); //select blue filter
        pulse = 0; //reset the count to 0
        _delay_ms(100); //capture the pulses for 100 ms or 0.1 second
        blue = pulse; //store the count in variable called blue
    }




/*
 *
 * Function Name: color_sense()
 * Input: void
 * Output: color of the block
 * Logic: Use sharp sensor to senses the presence of block.
 *		  Compare red,blue and green pulses to get find the color of the block i.e if less than black threshold then the package is invalid
 *		  else the greatest among the red, green or blue pulse is the color of the block.  
 * Example Call: int color_of_box = color_sense();
 *
*/
int color_sense(void) {
    color_sensor_scaling();
    while (1) {
        sharp = ADC_Conversion(11); //Stores the Analog value of front sharp connected to ADC channel 11 into variable "sharp"
        value = Sharp_GP2D12_estimation(sharp); //Stores Distance calculated in a variable "value".
        volatile unsigned long int pulse_value = 0;
        red_read();
        _delay_ms(500);
        blue_read();
        _delay_ms(500);
        green_read();
        _delay_ms(500);
 
        lcd_init();
        lcd_print(2, 1, value, 5); //Print the count on second row
        if ((red <= 1700) && (blue <= 1700) && (green <= 1700) && (value > 0 && value <= 350)) {
            lcd_cursor(1, 1); //set the cursor on row 1, column 1
            lcd_string("Black Pulses"); // Display "Black Pulses" on LCD
            lcd_print(2, 1, value, 5); //Print the count on second row
            buzzer_on();
            _delay_ms(1000); // Display for 1000ms or 1 second
            buzzer_off();
            lcd_wr_command(0x01);
            return;
            break;
        } else if ((red > blue) && (red > green) && (value > 0 && value <= 350)) {
            pulse_value = red;
            PORTJ = 0xFB; //need to replace by led
            lcd_cursor(1, 1); //set the cursor on row 1, column 1
            lcd_string("Red Pulses"); // Display "Red Pulses" on LCD
            lcd_print(2, 1, pulse_value, 5); //Print the count on second row111111
            _delay_ms(500); // Display for 1000ms or 1 second
            lcd_wr_command(0x01); //Clear the LCD	
            PORTJ = 0x00;
            if (count_red_zone-- > 0)
                return red_color;
            else return;
            break;

        } else if ((blue > green) && (blue > red) && (value > 0 && value <= 350)) {
            pulse_value = blue;
            PORTJ = 0xFE; //need to replace by led
            lcd_cursor(1, 1); //set the cursor on row 1, column 1
            lcd_string("Blue Pulses"); // Display "Blue Pulses" on LCD
            lcd_print(2, 1, pulse_value, 5); //Print the count on second row111111
            _delay_ms(500); // Display for 1000ms or 1 second
            lcd_wr_command(0x01); //Clear the LCD
            PORTJ = 0x00;
            if (count_blue_zone-- > 0)
                return blue_color;
            else return;
            break;

        } else if ((green > red) && (green > blue) && (value > 0 && value <= 350)) {
            pulse_value = green;
            PORTJ = 0xEF; //need to replace by led
            lcd_cursor(1, 1); //set the cursor on row 1, column 1
            lcd_string("Green Pulses"); // Display "Green Pulses" on LCD
            lcd_print(2, 1, pulse_value, 5); //Print the count on second row111111
            _delay_ms(500); // Display for 1000ms or 1 second
            lcd_wr_command(0x01); //Clear the LCD
            PORTJ = 0x00;
            if (count_green_zone-- > 0)
                return green_color;
            else return;
            break;
        } else return;
    }
}



/*
 *
 * Function Name: follow()
 * Input: void
 * Output: void
 * Logic: Uses PID line following algorithm to follow line from one node to another
 * Example Call: follow();
 *
*/


void follow() {

    unsigned char black_threshold = 80;
    int lastproportional = 0, integral = 0;
    int error = 0;
    float kp = 1.8, ki = 0, kd = 4.75;
    while (1) {
        center_sensor = ADC_Conversion(2);
        left_sensor = ADC_Conversion(3);
        right_sensor = ADC_Conversion(1);
        lcd_print(1, 1, left_sensor, 3);
        lcd_print(1, 5, center_sensor, 3);
        lcd_print(1, 9, right_sensor, 3);
        int sum = (center_sensor + left_sensor + right_sensor);
        if (sum >= black_threshold) {
            stop();
            buzzer_on();
            _delay_ms(10);
            buzzer_off();
            has_turned = 0;
            forward();
            velocity(252, 255);
            if (flag == 1)
                forward_mm(35);
            else if (flag == 0)
                forward_mm(10);
            stop();
            break;
        } else {
            has_turned = 0;
            int position = (((right_sensor * 2) + center_sensor) * 250) / sum;
            int set_point = 250;
            int proportional = position - set_point;
            integral += proportional;
            int derivative = proportional - lastproportional;
            lastproportional = proportional;
            error = (proportional * kp + integral * ki + derivative * kd);
            int left_speed, right_speed;
            //Restricting the error value between +256.
            if (error < -255)
                error = -255;

            if (error > 255)
                error = 255;
            if (error < 0) {
                right_speed = 255 + error;
                left_speed = 255;
                //last_turned=3;
            }
            // If error_value is greater than zero calculate left turn values
            else {
                right_speed = 255;
                left_speed = 255 - error;
                //last_turned=-3;
            }
            forward();
            velocity(right_speed, left_speed);
        }
    }
}

/*
 *
 * Function Name: north
 * Input: current orientation of the robot
 * Output: void
 * Logic: 1) If the bot faces in north and has to move north then it must go forward
 *  	  2) If the bot faces in north and has to move east then it must go right
 *		  3) If the bot faces in north and has to move west then it must go left		
 * Example Call: north(pointing_east);
 *
 */
void north(unsigned int current_orientation) {
	
    if (current_orientation == pointingnorth) { //go forward
        follow();
    } else if (current_orientation == pointingeast) { // go right
        forward_mm(15);
        velocity(220, 223);
        left_degrees(90);
        follow();
    } else if (current_orientation == pointingwest) { // go left
        forward_mm(15);
        velocity(220, 223);
        right_degrees(90);
        follow();
    }
    orie = pointingnorth;
}

/*
 *
 * Function Name: south
 * Input: current orientation of the robot
 * Output: void
 * Logic: 1) If the bot faces in south and has to move south then it must go forward
 *        2) If the bot faces in south and has to move east then it must go left
 *        3) If the bot faces in south and has to move west then it must go right		
 * Example Call: south(pointing_east);
 *
 */
void south(unsigned int current_orientation) {

    if (current_orientation == pointingsouth) { //go forward
        follow();
    } else if (current_orientation == pointingeast) { // go left
        forward_mm(15);
        velocity(220, 223);
        right_degrees(90);
        follow();
    } else if (current_orientation == pointingwest) { // go right
        forward_mm(15);
        velocity(220, 223);
        left_degrees(90);
        follow();
    }
    orie = pointingsouth;
}

/*
 *
 * Function Name: west
 * Input: current orientation of the robot
 * Output: void
 * Logic: 1) If the bot faces in west and has to move west then it must go forward
 *		  2) If the bot faces in west and has to move north then it must go right
 *		  3) If the bot faces in west and has to move south then it must go left		
 * Example Call: north(pointing_east);
 *
 */
void west(unsigned int current_orientation) { 

    if (current_orientation == pointingwest) { // go forward
        follow();
    } else if (current_orientation == pointingnorth) { //go right
        forward_mm(15);
        velocity(220, 223);
        left_degrees(90);
        follow();
    } else if (current_orientation == pointingsouth) { // go left

        forward_mm(15);
        velocity(220, 223);
        right_degrees(90);
        follow();
    }
    orie = pointingwest;
}

/*
 *
 * Function Name: east()
 * Input: current orientation of the robot
 * Output: void
 * Logic: 1) If the bot faces in east and has to move east then it must go forward
 *        2) If the bot faces in east and has to move north then it must go left
 *		  3) If the bot faces in east and has to move south then it must go right		
 * Example Call: south(pointing_east);
 *
 */
void east(int current_orientation) {
    if (current_orientation == pointingeast) {	// go forward
        follow();
    } else if (current_orientation == pointingnorth) {	// go left
        forward_mm(15);
        velocity(220, 223);
        right_degrees(90);
        follow();
    } else if (current_orientation == pointingsouth) { // go right
        forward_mm(15);
        velocity(220, 223);
        left_degrees(90);
        follow();
    }
    orie = pointingeast;
}

/*
 *
 * Function Name: order_picking(int co_ordinate)
 * Input: current co-ordinate of the robot
 * Output: void
 * Logic: Assign best possible zone for the given co-ordinate block
 *		  Check the color of the block from info_table[][] at that co-ordinate.
 *		  Check for the available zone for that package in the given co-ordinate and store it in info_table[][]
 * Example Call: order_picking(12);
 *					OR
 *				  order_picking(current_position)
 */
void order_picking(int co_ordinate) {
    for (int i = 0; i <= 11; i++) {
        if (info_table[i][0] == co_ordinate && i <= 5) {
            if (info_table[i][1] == red_color) {
                info_table[i][2] = zone_availability(red_color, 1);	// 1 signifies lower boundary of the arena i.e co-ordinate 11-19.
                break;
            } else if (info_table[i][1] == blue_color) {
                info_table[i][2] = zone_availability(blue_color, 1); // 1 signifies lower boundary of the arena i.e co-ordinate 11-19.
                break;
            } else if (info_table[i][1] == green_color) {
                info_table[i][2] = zone_availability(green_color, 1); // 1 signifies lower boundary of the arena i.e co-ordinate 11-19.
                break;
            } else break;
        } else if (info_table[i][0] == co_ordinate && i > 5) {
            if (info_table[i][1] == red_color) {
                info_table[i][2] = zone_availability(red_color, 2); // 2 signifies upper boundary of the arena i.e co-ordinate 41-49.
                break;
            } else if (info_table[i][1] == blue_color) {
                info_table[i][2] = zone_availability(blue_color, 2); // 2 signifies upper boundary of the arena i.e co-ordinate 41-49.
                break;
            } else if (info_table[i][1] == green_color) {
                info_table[i][2] = zone_availability(green_color, 2); // 2 signifies upper boundary of the arena i.e co-ordinate 41-49.
                break;
            } else break;
        }
    }
}

/*
 *
 * Function Name: order_picking(int co_ordinate)
 * Input: current co-ordinate of the robot
 * Output: void
 * Logic: assign a deposition zone for the given the color.
 *		  checks for the zone availability in the deposition table 
 *		  increases blocks_in[i] by 1 if the zone is available for deposition  
 * Example Call: order_picking(12);
 *					OR
 *				  order_picking(current_position)
 */

int zone_availability(int color, int border) {
    int row;
    if (color == red_color)
        row = 0;
    else if (color == green_color)
        row = 1;
    else if (color == blue_color)
        row = 2;

    for (int j = 1; j <= 3; j++) {
        int zone = deposition_table[row][j];

        if (j == 1) {
            if ((border == 1) && (zone == 1 || zone == 2 || zone == 5)) {
                if (blocks_in[zone] < 2) {
                    blocks_in[zone] ++;
                    return zone;
                }
            } else if ((border == 2) && (zone == 3 || zone == 4 || zone == 5)) {
                if (blocks_in[zone] < 2) {
                    blocks_in[zone] ++;
                    return zone;
                }
            }

        } else if (j >= 2) {
            if ((border == 1) && (zone == 5 || zone == 1 || zone == 2 || zone == 3 || zone == 4)) {
                if (blocks_in[zone] < 2) {
                    blocks_in[zone] ++;
                    return zone;
                }
            } else if ((border == 2) && (zone == 5 || zone == 3 || zone == 4 || zone == 1 || zone == 2)) {
                if (blocks_in[zone] < 2) {
                    blocks_in[zone] ++;
                    return zone;
                }
            }

        }
    }
}

/*
 *
 * Function Name: travel(from , to)
 * Input: (from_co-ordinate , to_co-ordinate)
 * Output: void
 * Logic: Split from and to co-ordinate value into x and y co-ordinate.
 *		  travel node to node until from(x co-ordinate) = to (x co-ordinate)
 *		  travel node to node until from(y co-ordinate) = to (y co-ordinate)	 	
 * Example Call: travel(12,13);
 *					OR
 *				  travel(current_position,next_position)
 */
void travel(int from, int to) {
        int x1 = from / 10;
        int y1 = from % 10;
        int x2 = to / 10;
        int y2 = to % 10;
        if (from == 21 || from == 29 || from == 25 || from == 31 || from == 39 || from == 35) {
            if (from != to) {
                if (x1 != x2) { 
                    if (x1 > x2) // e.g travel(21,11) in this case one has to travel south
                        while (x1 != x2) {
                            south(orie);
                            x1--;
                        } else if (x2 > x1)// e.g travel(11,21) in this case one has to travel north
                        while (x2 != x1) {
                            north(orie);
                            x1++;
                        }
                }
                if (y1 != y2) {
                    if (y1 > y2)// e.g travel(12,11) in this case one has to travel west
                        while (y1 != y2) {
                            west(orie);
                            y1--;

                        } else if (y2 > y1)// e.g travel(11,12) in this case one has to travel east
                        while (y1 != y2) {
                            east(orie);
                            y1++;

                        }
                }
            }
        } else {
            if (from != to) {

                if (y1 != y2) {
                    if (y1 > y2)// e.g travel(12,11) in this case one has to travel west
                        while (y1 != y2) {
                            west(orie);
                            y1--;

                        } else if (y2 > y1)// e.g travel(11,12) in this case one has to travel east
                        while (y1 != y2) {
                            east(orie);
                            y1++;

                        }
                }
                if (x1 != x2) {
                    if (x1 > x2) // e.g travel(21,11) in this case one has to travel south
                        while (x1 != x2) {
                            south(orie);
                            x1--;
                        } else if (x2 > x1)// e.g travel(11,21) in this case one has to travel north
                        while (x2 != x1) {
                            north(orie);
                            x1++;
                        }
                }
            }
        }
    }
    /*
     *
     * Function Name: path_planning(current_position)
     * Input: Current co-ordinate of the bot.
     * Output: set of co-ordinates values from where packages have to picked up.
     * Logic: 
     * Example Call: path_planning(13);
     *					OR
     *				  path_planning(current_position)
     */

int queue[7] = {	//stores deposition zone for the given scanned zone
    0
};
int co_ordinate_queue[7] = { // stores co-ordinate for the given scanned zone
    0
};
int path_planning(int current_pos) {

        int head = 0;
        int priority_1[] = { //priority for storing blocks in deposition zone if the bot is near deposition block 1
            1, 5, 2, 3, 4
        };
        int priority_2[] = { //priority for storing blocks in deposition zone if the bot is near deposition block 2
            2, 5, 1, 4, 3
        };
        int priority_3[] = { //priority for storing blocks in deposition zone if the bot is near deposition block 3
            3, 5, 4, 1, 2
        };
        int priority_4[] = { //priority for storing blocks in deposition zone if the bot is near deposition block 4
            4, 5, 3, 2, 1
        };
		//store the recently added information from info_table[][] into queue[] and co_ordinate_queue[].
        for (int j = 0; j <= 4; j++) {
            for (int i = 0; i <= 11; i++) {
                if (current_pos == 12) {
                    if (priority_1[j] == info_table[i][2]) {
                        queue[head] = info_table[i][2];
                        co_ordinate_queue[head] = info_table[i][0];
                        head++;
                    }
                } else if (current_pos == 18) {
                    if (priority_2[j] == info_table[i][2]) {
                        queue[head] = info_table[i][2];
                        co_ordinate_queue[head] = info_table[i][0];
                        head++;
                    }
                } else if (current_pos == 45 && orie == pointingwest) {
                    if (priority_4[j] == info_table[i][2]) {
                        queue[head] = info_table[i][2];
                        co_ordinate_queue[head] = info_table[i][0];
                        head++;
					}  
                } else
				{
                    if (priority_3[j] == info_table[i][2]) {
                        queue[head] = info_table[i][2];
                        co_ordinate_queue[head] = info_table[i][0];
                        head++;
					}						
                }
            }
        }
		
		//after storing it into queue[] and co_ordinate_queue[] erase it from info_table[][].
        for (int i = 0; i <= 11; i++) {
            if (i <= 5 && (current_pos / 10 == 1)) {
                for (int j = 0; j <= 2; j++) {

                    if (info_table[i][2] == 1 || info_table[i][2] == 2 || info_table[i][2] == 5) {
                        if (queue[j] == info_table[i][2]) {
                            info_table[i][2] = 0;
                        }
                    } else if ((queue[j] == 3) || (queue[j] == 4)) {
                        leftover_blocks[0][leftover_counter] = queue[j];
                        leftover_blocks[1][leftover_counter] = co_ordinate_queue[j];
                        leftover_counter++;
                        queue[j] = 0;
                        co_ordinate_queue[j] = 0;

                    }
                }

            } else if ((i > 5) && (current_pos / 10 == 4)) {
                for (int j = 0; j <= 2; j++) {
                    if (info_table[i][2] == 3 || info_table[i][2] == 4 || info_table[i][2] == 5) {
                        if (queue[j] == info_table[i][2]) {
							info_table[i][2] = 0;
                        }
                    } else if (queue[j] == 1 || queue[j] == 2) {
                        leftover_blocks[0][leftover_counter] = queue[j];
                        leftover_blocks[1][leftover_counter] = co_ordinate_queue[j];
                        leftover_counter++;
                    }
                }
            }
        }
    }


/*
 *
 * Function Name: order_picking(int co_ordinate)
 * Input: void
 * Output: void
 * Logic: 	Initializes info_table[][] with the co-ordinate values.
 * Example Call: create_info_table()
 */
void create_info_table() {
    for (int i = 0; i <= 11; i++) {
        if (i <= 2)
            info_table[i][0] = (12 + i);
        else if (i > 2 && i <= 5)
            info_table[i][0] = (13 + i);
        else if (i > 5 && i <= 8)
            info_table[i][0] = (36 + i);
        else info_table[i][0] = (37 + i);
    }
}



/*
 *
 * Function Name: zone_scan()
 * Input: void
 * Output: void
 * Logic: Moves bot from one node to other until it has reached the extreme most node of the
 *		  current pick-up zone.
 *		  While moving from one node to other keep scanning for presence/absence of packages. If the package is present
 *		  then it would sense the color of the current package and store it in info_table[][].
 * Example Call: zone_scan();
 *
 */
void zone_scan() {
    if (current_position == 15) {
        if (orie == pointingnorth) {
            while (next_position >= 12) {// keep traveling from 15 to 12
                travel(current_position, next_position);
                current_position = next_position;
                next_position--;
                for (int i = 0; i <= 11; i++) {
                    if (info_table[i][0] == current_position) {
                        info_table[i][1] = color_sense(); // sense block and it's color on each node
                        order_picking(info_table[i][0]);
                    }
                }
            }
        }

        if (orie != pointingnorth) {
            while ((next_position >= 16) && (next_position <= 18)) {// keep traveling from 16 to 18
                travel(current_position, next_position);
                current_position = next_position;
                next_position++;
                for (int i = 0; i <= 11; i++) {
                    if (info_table[i][0] == current_position) {
                        info_table[i][1] = color_sense(); // sense block and it's color on each node
                        order_picking(info_table[i][0]);
                    }
                }
            }
        }
    }

    if (current_position == 49) {
        while (next_position >= 45) {// keep traveling from 49 to 45
            travel(current_position, next_position);
            current_position = next_position;
            next_position--;
            for (int i = 0; i <= 11; i++) {
                if (info_table[i][0] == current_position) {
                    info_table[i][1] = color_sense(); // sense block and it's color on each node
                    order_picking(info_table[i][0]);
                }
            }
        }
    } else if (current_position == 41) {

        while (next_position <= 45) {// keep traveling from 41 to 45
            travel(current_position, next_position);
            current_position = next_position;
            next_position++;
            for (int i = 0; i <= 11; i++) {
                if (info_table[i][0] == current_position) {
                    info_table[i][1] = color_sense(); // sense block and it's color on each node
                    order_picking(info_table[i][0]);
                }
            }
        }
    } else if ((current_position == 45) && (orie == pointingwest)) {
        while (next_position >= 41) {// keep traveling from 45 to 41
            travel(current_position, next_position);
            current_position = next_position;
            next_position--;
            for (int i = 0; i <= 11; i++) {
                if (info_table[i][0] == current_position) {
                    info_table[i][1] = color_sense(); // sense block and it's color on each node
                    order_picking(info_table[i][0]);
                }
            }
        }
    } else if ((current_position == 45) && (orie == pointingeast)) {
        while (next_position <= 48) {// keep traveling from 45 to 48
            travel(current_position, next_position);
            current_position = next_position;
            next_position++;
            for (int i = 0; i <= 11; i++) {
                if (info_table[i][0] == current_position) {
                    info_table[i][1] = color_sense(); // sense block and it's color on each node
                    order_picking(info_table[i][0]);
                }
            }
        }
    }
}
/*
 *
 * Function Name: change_orientation()
 * Input: void
 * Output: void
 * Logic: Changes orientation of the robot on 180 degree turn
 * Example Call: change_orientation();
 *				 change_orientation();
 */
void change_orientation() {
    if (orie == pointingnorth)
        orie = pointingsouth;
    else if (orie == pointingsouth)
        orie = pointingnorth;
    else if (orie == pointingwest)
        orie = pointingeast;
    else if (orie == pointingeast)
        orie = pointingwest;

}


/*
 *
 * Function Name: place_package()
 * Input: void
 * Output: void
 * Logic: Go to package
 *		  Pick up package
 *		  Travel to the deposition zone
 * Example Call: place_package();
 *				 place_package();
 */
void place_package() {
    
    char lower_boundary[6] = {
        0, 13, 17, 31, 39, 25
    };
    char upper_boundary[6] = {
        0, 21, 29, 43, 47, 35
    };
    char zone_coordinate;
    int block_counter = 0;
    for (int i = 0; i <= 2; i++) {
        forward();
        velocity(252, 255);
		//calculate position of the package 
        if (co_ordinate_queue[i] >= 12 && co_ordinate_queue[i] <= 18)
            zone_coordinate = lower_boundary[queue[i]];
        else if (co_ordinate_queue[i] >= 42 && co_ordinate_queue[i] <= 48)
            zone_coordinate = upper_boundary[queue[i]];
        if (co_ordinate_queue[i] != 0)
            next_position = co_ordinate_queue[i];
        else
            break;
        stop();
        
        if ((current_position >= 12 && current_position <= 18) || (current_position >= 42 && current_position <= 48)) {

            if ((orie == pointingeast) && ((next_position % 10) < (current_position % 10))) {
                velocity(220, 223);
                left_degrees(191);
                change_orientation();
            } else if (((next_position % 10) > (current_position % 10)) && (orie == pointingwest)) {
                velocity(220, 223);
                left_degrees(191);
                change_orientation();
            }
        }

        stop();
		//travel from current_position to package position
        travel(current_position, next_position);
        current_position = next_position;
		// align to center of the node
        if ((current_position >= 12) && (current_position <= 18)) {

            if (orie == pointingeast)
                forward_mm(25);			
            else
                back_mm(35);
        } else if ((current_position >= 42) && (current_position <= 48)) {

            if (orie == pointingwest)
                forward_mm(25);
            else
                back_mm(35);
        }
        if (block_counter > 0)
            forward_mm(25);
        else forward_mm(10);
		//pick up the package
        pick();
        stop();
        _delay_ms(1000);
        block_counter++;
        if (zone_coordinate != 0)
            next_position = zone_coordinate;
        else break;
        if ((current_position >= 12 && current_position <= 18) || (current_position >= 42 && current_position <= 48)) {
            if ((next_position % 10) < (current_position % 10) && (orie == pointingeast)) {
                velocity(220, 223);
                left_degrees(191);
                change_orientation();
            } else if ((next_position % 10) > (current_position % 10) && (orie == pointingwest)) {
                velocity(220, 223);
                left_degrees(191);
                change_orientation();
            }
        }
        travel(current_position, next_position);
        current_position = next_position;
        if ((current_position == 25) || (current_position == 35)) {

            velocity(220, 223);
            left_degrees(191);
            change_orientation();
            back_mm(60);
        } else if ((current_position == 21) || (current_position == 31)) {
            right_degrees(88);
            orie = pointingeast;
            follow();
            velocity(220, 223);
            left_degrees(191);
            change_orientation();
        } else if (current_position == 29 || current_position == 39) {
            left_degrees(88);
            orie = pointingwest;
            follow();
            velocity(220, 223);
            left_degrees(191);
            change_orientation();
        }
		drop(blocks_in[queue[i]]);
        if ((current_position == 21) || current_position == 29 || current_position == 31 || current_position == 39) {
            follow();
            stop();
        }
        block_counter = 0;
    }
}

int arm_right = 5;
int arm_left = 180;
int arm_position = 0;
/*
 *
 * Function Name: pick()
 * Input: void
 * Output: void
 * Logic: Adjust arm position according to co-ordinate and orientation of the bot
 *		  Pick up the package.
 * Example Call: pick();
 */
void pick() {
    int i;
    if ((current_position >= 12) && (current_position <= 18)) {
        if (orie == pointingeast) {
            servo_3(0);
            arm_position = arm_right;
        } else if (orie == pointingwest) {
            servo_3(180);
            arm_position = arm_left;
        }
    } else if ((current_position >= 42) && (current_position <= 48)) {
        if (orie == pointingeast) {
            servo_3(180);
            arm_position = arm_left;
        } else if (orie == pointingwest) {
            servo_3(0);
            arm_position = arm_right;
        }
    }

    for (i = 120; i <= 180; i++) {
        servo_2(i);
        _delay_ms(25);
    }
    _delay_ms(500);
    for (i = 77; i <= 130; i++) {
        _delay_ms(25);
        servo_1(i);

    }
    _delay_ms(500);
    for (i = 180; i >= 120; i--) {
        _delay_ms(25);
        servo_2(i);

    }
}

/*
 *
 * Function Name: drop(int block_count)
 * Input: block_count: Number of blocks already placed in that zone
 * Output: void
 * Logic: Drop the package if it is the first package to be deposited in the zone
 *		  If it is the second package then move forward to avoid collisions with the previously placed block. 
 * Example Call: drop();
 */
void drop(int block_count) {
    _delay_ms(500);
    int i;
    if ((current_position / 10 == 2) || (current_position / 10 == 3)) {
        servo_3(90);
    } else if (current_position >= 12 && current_position <= 18) {
        if ((arm_position == arm_left) && (orie == pointingwest)) {

            for (i = 180; i >= 0; i--) {
                servo_3(i);
                _delay_ms(10);
            }
        } else if ((arm_position == arm_right) && (orie == pointingeast)) {
            for (i = 0; i <= 180; i++) {
                servo_3(i);
                _delay_ms(10);
            }

        }
    } else if (current_position >= 42 && current_position <= 48) {
        if ((arm_position == arm_left) && (orie == pointingeast)) {

            for (i = 180; i >= 0; i--) {
                servo_3(i);
                _delay_ms(10);
            }
        } else if ((arm_position == arm_right) && (orie == pointingwest)) {
            for (i = 0; i <= 180; i++) {
                servo_3(180);
                _delay_ms(10);
            }

        }
    }
	if(block_count == 2)
    for (i = 120; i <= 180; i++) {
        servo_2(i);
        _delay_ms(25);
    }
	else if (block_count == 1){
		for (i = 120; i <= 150; i++) {
			servo_2(i);
			_delay_ms(25);
		}		
	}

    _delay_ms(500);
    for (i = 130; i >= 77; i--) {
        _delay_ms(25);
        servo_1(i);



    }
    _delay_ms(500);
	if(block_count == 2)
    for (i = 180; i >= 120; i--) {
        _delay_ms(25);
        servo_2(i);
    }
	else if (block_count == 1)
	for (i = 150; i >= 120; i--) {
		_delay_ms(25);
		servo_2(i);
	}
}

/*
 * Function Name:	main
 * Input:		None
 * Output:		void
 * Logic:		Complete procedure to travel to a pick up zone and place the scanned blocks in respective zones. Placing the left over blocks
				to upper boundary zones. Then traveling to upper boundary and placing these in the respective deposition zones. Then placing 
				blocks into respective depostion zones
 *
 * Example Call:		Called automatically by the Operating System
 *
 */


void main()
{
    init_devices();
    lcd_set_4bit();
    lcd_init();
    for (int i = 1; i < 4; i++) {
        if (deposition_table[0][i] != -1) { 
            count_red_zone++;//to check the number of red blocks to be considered for deposition
        }

        if (deposition_table[1][i] != -1) {
            count_green_zone++;//to check the number of green blocks to be considered for deposition
        }

        if (deposition_table[2][i] != -1) {
            count_blue_zone++;//to check the number of blue blocks to be considered for deposition
        }
    }
	
    count_blue_zone = count_blue_zone * 2;
    count_green_zone = count_green_zone * 2;
    count_red_zone = count_red_zone * 2;

    flag = 1;
    int last_zone = 0; //has_turned=0;
    orie = pointingnorth;
    servo_3(5); //initializes lower servo 
    servo_2(120); //initializes middle servo
    servo_1(80); //initializes gripper servo
    total_boxes = deposition_table[0][0] + deposition_table[1][0] + deposition_table[2][0]; //keeps track of total blocks
    create_info_table(); //creates the information table

    follow(); // travel to firt co-ordinate 15
    current_position = 15;
    next_position = 14; // next co-ordinate
    zone_scan(); //scan the co-ordinates 14 to 12
    path_planning(current_position); //prioritize deposition of scanned blocks
    stop();
    velocity(220, 223);//
    left_degrees(191); //take a u-turn
    back_mm(25);	   //
    stop();
    orie = pointingeast; //set orientation

    place_package(); //to place packages scanned from co-ordinates 14-12
    for (int i = 0; i < 7; i++) {
        queue[i] = 0;
        co_ordinate_queue[i] = 0; //empties the queue and co-ordinate queue
    }
    servo_3(180); //resets servo to 180 degrees for next pick up zone
	    if (current_position != 31 && current_position != 21) {
        if ((orie == pointingwest) || (orie == pointingnorth) || ((current_position > 15) && (orie == pointingeast))) {
            velocity(220, 223);//
            left_degrees(191);//take a u-turn
            change_orientation();//
        }
    }

    travel(current_position, 15);//to travel to co-ordinate 15

    if ((orie == pointingwest || orie == pointingnorth) && (current_position >= 12 && current_position <= 18)) {
        velocity(220, 223);//
        left_degrees(191);//take a u-turn
        change_orientation();//
    }
   
    current_position = 15;
    next_position = 16; //set co-ordinates
    zone_scan();//scan the co-ordinates 16 to 18
    path_planning(current_position);//to prioritize deposition of scanned blocks
    velocity(220, 223);//
    left_degrees(191); //take a u-turn
    orie = pointingwest;//
    //has_turned=1;
    stop();
    back_mm(40);//to align
    place_package(); //to place packages scanned from co-ordinate 16 to 18
    stop();
    for (int i = 0; i < 7; i++) {
        queue[i] = 0; 
        co_ordinate_queue[i] = 0; //empty queue and co-ordinate queue
    }
    int size = 7;
    int i, j, k;
    for (i = 0; i < size; i++) {
        for (j = i + 1; j < size;) {
            if (leftover_blocks[1][j] == leftover_blocks[1][i]) {
                for (k = j; k < size; k++) {
                    leftover_blocks[1][k] = leftover_blocks[1][k + 1];
                    leftover_blocks[0][k] = leftover_blocks[0][k + 1]; //procedure to shuffle any leftover blocks in lower boundary
                }
                size--;
            } else
                j++;
        }
    }

    for (int i = 0; i < 7; i++) {
        co_ordinate_queue[i] = leftover_blocks[1][i];
        queue[i] = leftover_blocks[0][i]; //to put all leftover blocks in queue and co-ordinates for same in co-ordinate queue
    }

    stop();
    place_package(); //place left-over packages from lower boundary
    for (int i = 0; i < 7; i++) {
        queue[i] = 0;
        co_ordinate_queue[i] = 0;
        leftover_blocks[0][i] = 0;
        leftover_blocks[1][i] = 0; //empty leftover queue,queue,co-ordinate queue,reset counter
        leftover_counter = 0;
        //break;	
    }
    for (int i = 0; i <= 11; i++)
        info_table[i][2] = 0; //reset info-table after lower boundary
    if (current_position == 31 || (current_position >= 12 && current_position <= 14)) {
        if ((current_position >= 12 && current_position <= 14) && orie == pointingeast) {
            stop();
            velocity(220, 223);//
            left_degrees(191);//take u-turn
            change_orientation();//
            forward_mm(20);
        }
       

        next_position = 41; //set co-ordinate
        servo_3(0); //reset servo to 0 degrees for next pickup zone
    } else if (current_position == 39 || (current_position >= 16 && current_position <= 18)) {
        if ((current_position >= 16 && current_position <= 18) && orie == pointingwest) {
            stop();
            //int x=9;
            velocity(220, 223);//
            left_degrees(191);//take u-turn
            change_orientation();//
            forward_mm(20);
        }
       
        next_position = 49;//set co-ordinate
        servo_3(180);//reset servo to 180 degrees for next co-ordinate
    }

    travel(current_position, next_position); //travel to next pick up zone
    current_position = next_position; //set co-ordinate
    if (current_position == 41) {
        next_position = 42;
        last_zone = 46; //set next position co-ordinate
    } else if (current_position == 49) {
        next_position = 48;
        last_zone = 44; //set next position co-ordinate
    }
    zone_scan(); //scan the next pick up zones
    path_planning(current_position); //prioritize the scanned blocks for deposition
    stop();
    velocity(220, 223);//
    left_degrees(191);//take u-turn
    change_orientation();//

    stop();
    place_package(); //place the packages of current pick up zone
    stop();
    for (int i = 0; i < 7; i++) {
        queue[i] = 0;
        co_ordinate_queue[i] = 0; //empty queue
    }
    if (last_zone == 46) {
        if (orie == pointingwest || orie == pointingsouth || (current_position >= 46 && current_position <= 48 && orie == pointingeast)) {
            stop();
            velocity(220, 223);//
            left_degrees(191);//take u-turn
            change_orientation();//
        }
        travel(current_position, 45); //travel to co-ordinate 45
        if (orie == pointingwest || orie == pointingnorth) {
            stop();
            velocity(220, 223);//
            left_degrees(191);//take u-turn
            change_orientation();//
        }
        current_position = 45;
        next_position = 46;//set current and next co-ordiante
        servo_3(0);//reset servo angle to 0 degrees for last zone
    } else if (last_zone == 44) {
        if (orie == pointingeast || orie == pointingsouth || (current_position >= 42 && current_position <= 44 && orie == pointingwest)) {
            stop();
            velocity(220, 223);//
            left_degrees(191);//take u-turn
            change_orientation();//
        }
        travel(current_position, 45);//travel to co-ordinate 45
        if (orie == pointingeast || orie == pointingnorth) {
            stop();
            velocity(220, 223);//
            left_degrees(191);//take u-turn
            change_orientation();//
        }
        current_position = 45;
        next_position = 44;//set co-ordinate
        servo_3(180); //reset servo angle to 180 degrees for last zone
    }
    zone_scan();//scan the zone
    path_planning(current_position);//prioritize the scanned blocks for deposition
    stop();
    velocity(220, 223);//
    left_degrees(191);//take u-turn
    change_orientation();//
    place_package();//place packages for last pick up zone
    stop();
    

    for (int i = 0; i < 7; i++) {
        queue[i] = 0;
        co_ordinate_queue[i] = 0; //empty queue
    }
    size = 7;
    //int i,j,k;
    for (i = 0; i < size; i++) {
        for (j = i + 1; j < size;) {
            if (leftover_blocks[1][j] == leftover_blocks[1][i]) {
                for (k = j; k < size; k++) {
                    leftover_blocks[1][k] = leftover_blocks[1][k + 1];
                    leftover_blocks[0][k] = leftover_blocks[0][k + 1];//shuffle blocks to leftover queue
                }
                size--;
            } else
                j++;
        }
    }
    
    for (int i = 0; i < 7; i++) {
        co_ordinate_queue[i] = leftover_blocks[1][i];//place leftover blocks in queue
        queue[i] = leftover_blocks[0][i];
    }
    ;
    stop();
    place_package(); //place the last packages from upper boundary to zones
    stop();
    buzzer_on();//
    _delay_ms(5050);//end task
    buzzer_off();//

}
/*
                                               .vLYv:                                                                                                 
                                              ii,..,:i.                                                                                               
                                            .1r.,,,.,:LY,       ::.                                                                                   
                                            1i.,,:,,.,.:Yi    iE:ivji      .,irv1i                                                                    
                                           77 ... . ....:uL .iE7v  .rLjY1SXkPkSu@F                                                                    
                                           1,::;rvLUU55X1155UuJu7v:   YUruu2U1viLB                                                                    
                                ..::irLL2UqP52UYL7L7vrii::;r7rJ17vJ7i. 2Y7r;ii:,:M:                                                                   
                           iP8ukFk22JL77ii:::iir7v77rr;7vJJYr7v.iFvJjk17,,,::::::vG                                                                   
                          0@1S,,::iirr7777vvjJuLLvv7vvYLvr;i5v:LY::i7ri:r7LvL7i::vk                                                                   
                          r8rXv7vYv7777vvJYYvv77r777r;:::::virJr:i::::;777;i:i:i:j1                                                                   
                           M7uY:;r7vLYjLvrr:::::::::::i::iL:77::iii:i:i::::::::::.Ni                                                                  
                           EULSrr7rri::::::i:i:iii::::::;7i27;ii:i:::::i:::irLLJLLGJ                                                                  
                           vOrS,::::::i:i:iiiiiii:rvu2FUJi1uLv7:i:r72L:::71Jjvv77iJN                                                                  
                           :B7F7,i:i:i:i:i:i:i:i:ii7r;:::i,,.,,:,:Lv7i,:;@i..,,:,,,M                                                                  
                            BvjL.,::::::::::iiri:::,::rr7rrrrr77v77rrrLvJ7ii77vvL77OL                                                                 
                            F0JFrrrv7vvLJuuuJJJuuuJujjvv77;r7vvJuUu1u12FU215uY77rr:r8                                                                 
                             OSJGULLUu21r::,,.,,:ir;ii;r7vjJuYYv7rr;i::::.,...,,::iiMv                                                                
                             OUU0P2UJuuuiiir7YJuYv77r7r7rrii::,:::i77LLuu21SFPP0PkUjr                                                                 
                             Evv5:iirr77v7v77ii:::::iivvuUFSX552PXYYYLL7v7rii::.                                                                      
                             UF75iirii::irrvY22k52LL7LLY77i:.:.  :                                                                                    
                             :@kBkUFkFX0S12YLr:  .iJEM:   .  O@@@BPri                                                                                 
                              ir::,.  :v . .  .1B@@@B@B:.:.,O@B@B@B@B                                                                                 
                                      vr..,,, 7@@B@B@qv.,,:,...:rYBBq                                                                                 
                                      Ui.:,:,, FEui.   ,,:,:..    i                                                                                   
                                      S:,,:::,,     . . ..,.,,,.. :i                                                                                  
                                     ,5:.:,:,:,,.,. :LuULr. ., .:r7q                                                                                  
                                     :1.:,:,:,:,, iBBur::v8E: UO1ii7kXi                                                                               
                                     ij.,:,:,:,, 5Bi       iB@Y  LU. .Z@                                                                              
                                     rL.:,:::,, JB     B@BZ  @7 YB@Br  i@.                                                                            
                                     J7,,:,:,,.,B:     @B@@.  B :@B@B   :@                                                                            
                                     ur.:,:,:, P@      B@B@   ;B M@@@    ZP                                         .:7vuS:      i777LXi              
                                     Si.,:,:,, @u       qMi    @  iY     .B                                        7MP1UYuL77j  7J.. vLSr             
                                    .1:.:,:,:..B:              Bi         @                                     .vri:........Si,N...:uiiq             
                                    :S,,,:,:,, @:              @:         B                                     1L ......,.,.::i:...iu::Ur            
                                    iU:,,,:,:, @P              B         iB                                   .iZ; .,.,.,.,...   ., ;J::J7            
                                    7u.,,:,:,,.rB             XB         @,                                 ,7r:Fv ... . ....,7L2i..,u::Ur            
                                    u7,,:,:,:,, MB           :@         @L                                .YuiirkY  .:ii;ir;..P 7k . Lr:0.            
                                    5r.,,:,:,:,. @@.        r@EMi    .L@Z                                iOU7Yu5kP:rvv7LvJ77LFF  P7i:rXPL             
                                   .k:,,:,:,:,:,. uBM7,  .vMB, iE88EG02,7                               iBSL0PSL7LU1uYP1:JXJr:    :irir:              
                                   :2,.:,:::,:::,, .v8BBOG5i ... .,:....rr                                  :;.       2Z:vX.                          
                                   rJ.,,:,:,:,:,:,:..  .....,,:,,,,.,,,.:J                                            iMi:k:                          
                                   jr,,:,:,:::,:,:,:,,,,,,,,,,,,.,....   7                                            .Mji7L                          
                                   1i.:,:,:,:,:,:,:,:,:,,,... . .,irvJ1FP8M2S1r                                        NUvLF                          
                                  .F,,,:,:::,:,:,:,,,,.. .,i7US0ZOZEk5YL7rrvYPB.                                       k:LSN                          
                                  ij,,:::,:::,:,,.. .,rJXNZNSj7::.. . ...... .U                                        Y7Jv7r7v7r.                    
                                  Yv.:,:,:,:,,,,.:rSE8Xur:.. ....,.:,,,:,,,,.7L                                        Lv:...,,:ijv                   
                                  F:,,:,:::,::,,v557:.  ..,,,,:,:,:,:,:,:,:,,L;                                       :L,.,,:,:,,.rU.                 
                                 :5,.:,:,:,::Y:::, ..,,,,:,:,:,:::,:,:,:,:::.L7                                       j:,:,:,:,:,:.rJ                 
                                 vL.:,:::,:,::7i:,:,:,:,:,:::,:,:,:,:,:::,:,,i5                                      .u.:,:,:,:,:,,.U,                
                                 F:,,:::,:,:,,,:,:,:,:,:,:,:,:,:,:,:,:,:,:,:,,vL                                     .2,.:,:,:,:,:,.r7                
                                iJ.,:,:,:,:,:,:,:,:,:,:,:,:,:::,:,:,:,:,:::,:,,L7                                     rL,.,,:,:,:,:.77                
                                u7::,:,:,:::::,:::,:,:,:,:::,:,:,:,:,:,:,:,:,:,,rkLri:                               .iv7i,,...:,:,,v:                
                               iki:,:,:,:,:,:,:,:,:,:::,:::,:,:,:,:::,:::,:,:,:,.:Lr:rLv7i:.                    ,:r77r:.:Pvv;r:,,.,.2.                
                              :S:.,:,:,:,:,:,:,:,:,:,:,:,:::,:::,:,:,:,:,:,:,:::,,,vr..::r7LLL77ii::,::::ii7rv7vr;::,,,,.0;YiG,.:J:rL                 
                             rF,.,:,:,:,:,:::,:,:,:,:,:,:,:,:,:::,:,:,:,:,:,:,:,:,,.;Li..,,.:::ir;rr7rririi::,:,,,:,:,:,.577iq; :i:U.                 
                            r1,,,:,:,:,:,:,:::,:,:,:,:,:,:,:,:,:,:,:,:,:,:,:,:::,:,,.:v7,.,:,,,,,,,,,,,,,,,:,:,:,:,:,:,, uJv:Fv...jr                  
                           r2,,,:,:,:,:,:,:::::,:,:::,:::::,:::,:,:,:::,,,:,:,:::,:,:.,rJ:..:,:,:,,,:,:,:,:,:,:::,:,:::,.7PL.v2 :u7                   
                          ;2,.,:,:,:,:,:,:,:::,:,:,:,:,:,:,:,:::,:,:,:,:ir,:::::::,:,:..:Jr..:,:::,,,:,:,:,:,:,:,:,:,:,:.i0L:vFiY:                    
                         :F,.,:,:,:,:::,:,:::,:,:,:,:,:,:,:::::,:::,:::,ir:,:,:::,:::,:,,,vL:.:,:,vL:,:::,:,:,:,:,:,:,:,.:ELLJ0:                      
                         F:.:u:,,:,:,:,:,:,:,:,:,:,:,:,:,:,:,:,:::,:,:,:,,,:,:,:::::,:,:,,.iJi.,,,:r:,,:,:,:,:,:,:,:::,,.:kYv7Z                       
                        Ui.,:::,:,:,:,:,:::,:,:,:,:,:,:,:,:::,:,:,:,:,:,:,:::,:,:,:,:,:,:,:.:L7.,,,.:,:,:,:::,:::,:,:,,..:X7:iMi                      
                       rL,,:,,,:,:,:,:,:,:::,,,:,:,:,:,:,:,:,:,:,:,:::,:,:::,:,:,:,:,:,:,:,,.,7L,,,:,:,:::,:,:,:,:,,,..ir1Frr7uU                      
                      .U:.:,:,:,:,:,:,:,:,:,,:7,:,:,:,:::,:,:,:,:::,:,:,:,:,:,:,:::,:,:,:,:,:..ru:.,:::,:,:,:,:,,.,:rvUL,:8J5uE7                      
                      v7.:,:,:,:,:::,:,:,:,,:Li:,:,:,:,:,:,:::,:,:::,:,:,:,:,:::,:,:,:,:::,:,:,.iu:.,:,:,,.,.,,:ivYj7:    ,i:,                        
                     .2,,,:,:,:::,:,:,:,:,,,jvi,:,:,:,:,:,:,:::,:,:,:::,:,:,:,:::,:,:,:,:,,,:,:,.:u:....,,:i7LuL7:.                                   
                     vr.,:,:,:::::::,:,:,:.Lv:.:,:,:,:,:::,:,:,:,:,:,:,:,:,:,:,:::,:,:,:,:7:,:,:,.:ui;vJYJL7:,                                        
                     U:.:,:,:,:,:,:,:::,:.rv..,,:,:,:,:,:,:,:,:,:::,:,:,:,:,:,:::,:,::::::7:,::,:,.:Fr..                                              
                    :Y.:,:,:,:,:,:::,:::.:J:.:,:,:::,:,:,:,:,:,:::,:,:,:,:,:,:,:::::,:,:,,.,,:,:,:,.:L                                                
                    L;,,:,:,:,:,:,:,:,:,.77.:,:::,:,:,:,:,:::,:,:,,.:,:,:,:,:,:,:,:,:::,:,:,:,:,:,:,.7J                                               
                    u:,:,:,:,:,:,:,:,:,,:u,,,:,:,:,:,:::::,:,:::,,i7,:::,:,:,:,:,:::::,:,:,:::,:,:,:.,Ui                                              
                   .2.,,:,:,:,:,:,:,:,,.Lr.,:::::,:,:,:,:,:,:,:,:.i;,,:,:,:,:,:::,:,:::,:::,:,:,:,:,:.:1                                              
                   iY,,:,:,:::,:,:,:,:.:u:,:,:,:,:,:,:,:,:,:,:,:::.,,:,:,:,:,:,:::,:,:,:,:,:::,:,:::,:.ji                                             
                   rv.:,:::,:,:,:,:,:,.v7.,,:,:::,:,:::,:::,:,:,:,:,:,:,:,:,:,:,:,....,,.,:,:,:,:,:,:,.rv                                             
                   Lr,,:::,:,:,:,:,:,.:u,,,:,:,:,:,:,:::,:,:,:,:,:::,:,:,:,:,:,:..rrJu..S:,:,:,:,:,,,. i;                                             
                   Lr.:,:,:::::,:,:,,.Jr.,:::::,:::::,:,:,:,:,:,:,:,:,:,:::,:,:,i,:77. 7@.,,:,:,:.,   :N.                                             
                   ji,,:::::::,:::,,.iL..,,,,:,:,:::::,:,:::,:,:,:,:,:::::,:,::,78Li:rS@i..,,,..   :JMB@.                                             
                   Yr.:,:,:::,:,:,:..Li     ....,,:,:,:,:,:,:,:,:,:,:,:,:,:,:,:,..7Y52L. ..   .:72GB@BM@,                                             
                   Jr.,:::,:,:.,,:,.rk0Ek5L7i:.      ......,.,.,,,,:,,,,,,,,,,...       .:iLukqOMM8qU: @                                              
                   L7.,,:,:,:,vi,,.:YY0O@B@@@MMEN5UL7ii:,.... .   .   .   . ....::r7JukPZZEEENqF5v;,:,iB                                              
                   vv.,:,:,:,:L:,,:2:  .:r7u1qEMB@M@BMMMGGqPSSUujjLJLJLvLYYUU5FqP00NNNXPSk1UYvi:,::ii:S@UuJYY1kEGZ082.                                
                   :1.,,:,:,:,,..,Ui..,..     .,i;vvjJ11SkPkEE80Z00PNq0XPSqkk1SFF1FuUYL7ri::::i;i:ii7ir:.ivJjv7:.rY:Y@7                               
                    5i.,,:,:,:,,,ur..,.,.,.,....         ....:::::::::;177rri;ii:::::::::iiii7iivriiLi ...      MOJr iB                               
                    :u,.,,:,:..:Ur..,......,,,,,,.,.,.,.,....         :r::::i:i:r7r;7iiiiiiivi  :vvL7.,.,,,.. ,BM,:i:.@                               
                     r5:...,.,rUi....:i7r7:.,:,:,,,,.,,,,,,,.:irrr:.  :L:iiiiirv7:  iLiiiiii;v:. ,::.,.:,:,, .BM ..::;Ui                              
                     v@77rr;7Lv,....7L7irru:.,,,,.....,,:,,,,,irJFOBML.:7r77vv7:....v;iiiiiiiiJ;....,.,,,,,. B@ .,,,,..iv7:                           
                     UB. :iri:.,...Lvii;ii77...:.:7v7:.,,,...       :NBu :i;::....:LriiiiiiiiiiU:.,:,,,,,,. r@, ,:,:,:,,,:rLi                         
                     u@  .....,,,.7viiiiiiiL..,.,L7i7L,..   :;Ju5uuu7..B@   ..,..iLiii;iiiiiii;J,.:,,,:,:,. @8 .:,:,:::,:,,,rYr                       
                     7B: ,,,,,,:.,Yriiiiiii77..,vriiiL:  ;FM8E1Y7r;YSF  BP .,,..rviiiiiii;iiirJi.,,:,:,,,, :@i ,,:,:::,:,:,:.,ru.                     
                      @L .:,,,:,.,Yiiiii;iii77rvr:ii::ru@GY:. ..... .,7,OB .:,.iLiiiiiiiiiii7Yi.,,,,,,,,,. N@ .,:,:,:,:,:,:,:,.:1.                    
                      B@ ..:,:,,.:Liiiiiiiiiiiiiiii:.1BG:  ..,,:,:,:,..:u0 ..,.Liiiiiiiii;rLr:.,.,,,,,,:,. @8 .:,:,:::,:,:,:,:,.i2                    
                      :@L ..,,:,,.Yiii;iiiii;i;iii:,BB: ..,,:,:,:,:,:,,.,77....rviiiiirrv7r:..,,:,:,:,:,,. @U ,,:,:,:,:,:,:,:,:.:S.                   
                       Z@: ..,,,..77:iiiiii;iiiii:.BB  ,,:,:,:,:,:,:,:,,.,L7.,.,rL7777ri:. ..,,,,,,,,,,:,. @J .:,:,:,:,:,:,,.,,iLr                    
                        MBY  ...,.:Yiiiiiiiiii;ii.SB. ,,:,:::,:,:,:,,,:,:.,Jr.,..,:,,..   .,......,...,.,. MB ......,.,.:::irvYr.                     
                         2B@7.     r7i:;;iiiiiii::BJ ,,:,:::,:,:,:,:i:,:,:.:U:.,....    :qB5.,..           .BSii:i7vvLLLLJv7i,                        
                           O@B@Oui. ,:i:ir;iiiii:7@..,:::::,:,:::,:,7L:,:,:.rL.     .7M@@B@B@@@B@B@@@BMSJi. .L .@B:.,..                               
                             .7OB@@@BBFi :::iiii:LB..,,:,:,:,:,:,:,:.:,:,:,,.J. :YO@B@E:        .,:rLPO@B@B@MEB@B:                                    
                                   .iL8B@@F,,:ii::@: .,,:,:,:,:,:,:,:,:,:,:,.i@B@BM7                       .i7v,                                      
                                         LB@1,.i:,E@,::,...,,,,:,:,:,:,:::,,.vj:                                                                      
                                           L@B1,,,:BNrvv7i:...,.,,:,:,:,:,:.,2                                                                        
                                             uB@Nr..7:.:::iPOLvvii:,.,.,,,.,YL                                                                        
                                                2GOP5112SPOE:   ,:iii::::::i:                                                                         


*/
